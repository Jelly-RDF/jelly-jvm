package eu.neverblink.protoc.java.gen

import com.google.protobuf.compiler.PluginProtos
import com.google.protobuf.compiler.PluginProtos.{CodeGeneratorRequest, CodeGeneratorResponse}
import com.palantir.javapoet.{JavaFile, TypeSpec}

import java.io.{IOException, InputStream}
import java.util
import javax.lang.model.element.Modifier
import scala.collection.mutable.ListBuffer
import scala.jdk.CollectionConverters.*

/*-
 * #%L
 * quickbuf-generator / CrunchyProtocPlugin
 * %%
 * Copyright (C) 2019 HEBI Robotics
 * %%
 * Copyright (C) 2025 NeverBlink
 * %%
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 * #L%
 */

/**
 * Protoc plugin that gets called by the protoc executable. The communication happens
 * via protobuf messages on System.in / System.out
 *
 * @author Florian Enner
 * @author Piotr SowiÅ„ski
 */
object CrunchyProtocPlugin:
  /**
   * The protoc-gen-plugin communicates via proto messages on System.in and System.out
   *
   * @param args
   * @throws IOException
   */
  @throws[IOException]
  def main(args: Array[String]): Unit = {
    if (args.length > 0) {
      System.out.println("This protobuf plugin should be called by protoc. Example:\n\n" +
        "    1) protoc --plugin=protoc-gen-crunchy=${executable} --crunchy_out=store_unknown_fields=true:. type.proto\n" +
        "    2) protoc --crunchy_out=store_unknown_fields=true:. type.proto\n\n" +
        "Note that if you are calling this plugin from the PATH (2), the executable\n" +
        "file or wrapper script needs to be called \"protoc-gen-crunchy\"."
      )
      return
    }
    handleRequest(System.in).writeTo(System.out)
  }

  @throws[IOException]
  def handleRequest(input: InputStream): CodeGeneratorResponse =
    try handleRequest(CodeGeneratorRequest.parseFrom(input))
    catch {
      case ex: Exception =>
        ParserUtil.asErrorWithStackTrace(ex)
    }

  def handleRequest(requestProto: PluginProtos.CodeGeneratorRequest): CodeGeneratorResponse =
    val response = CodeGeneratorResponse.newBuilder
    val request = RequestInfo.withTypeRegistry(requestProto)
    val filesToGenerate = new util.HashSet[String](requestProto.getFileToGenerateList)
    for (
      // Only generate files that were specifically selected (see issue #62)
      file <- request.files.asScala if filesToGenerate.contains(file.fileName)
    ) {
      // Generate type specifications
      val topLevelTypes = new ListBuffer[TypeSpec]
      val outerClassSpec = TypeSpec.classBuilder(file.outerClassName).addModifiers(Modifier.PUBLIC, Modifier.FINAL)
      val list: TypeSpec => Unit = if (file.generateMultipleFiles) topLevelTypes.addOne
      else outerClassSpec.addType
      for (t <- file.enumTypes.asScala) {
        list(new EnumGenerator(t).generate)
      }
      for (t <- file.messageTypes.asScala) {
        list(new MessageGenerator(t).generate)
      }
      if (file.generateDescriptors) new DescriptorGenerator(file).generate(outerClassSpec)
      // Omit completely empty outer classes
      if (file.generateDescriptors || !file.generateMultipleFiles)
        topLevelTypes.append(outerClassSpec.build)
      // Generate Java files
      for (typeSpec <- topLevelTypes) {
        val javaFile = JavaFile.builder(file.javaPackage, typeSpec)
          .addFileComment("Code generated by NeverBlink protoc-java-fast. Do not edit!")
          .indent(request.pluginOptions.indentString).skipJavaLangImports(true)
          .build
        val content = new java.lang.StringBuilder(1000)
        try javaFile.writeTo(content)
        catch {
          case e: IOException =>
            throw new AssertionError("Could not write to StringBuilder?")
        }
        response.addFile(CodeGeneratorResponse.File.newBuilder
          .setName(file.outputDirectory + typeSpec.name + ".java")
          .setContent(content.toString)
          .build
        )
      }
    }
    response.build

