{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jelly-JVM","text":"<p>Jelly-JVM is an implementation of the Jelly serialization format and the gRPC streaming protocol for the Java Virtual Machine (JVM), written in Scala 3. The supported RDF libraries are Apache Jena and Eclipse RDF4J.</p> <p>This collection of libraries aims to provide the full stack of utilities for fast and scalable RDF streaming with the Jelly protocol.</p> <p>Getting started with plugins \u2013 no code required</p> <p>See the Getting started guide for a quick way to use Jelly with your Apache Jena or RDF4J application without writing any code.</p> <p>Getting started for developers</p> <p>If you want to use the full feature set of Jelly-JVM in your code, see the Getting started guide for developers.</p> <p>TODO: versioning \u2013 point to the version selector in the navbar </p> <p>0.11.2</p> <p>dev </p>"},{"location":"#library-modules","title":"Library modules","text":"<p>The implementation is split into a few modules that can be used separately:</p> <ul> <li> <p><code>jelly-core</code> \u2013 implementation of the Jelly serialization format (using the scalapb library), along with generic utilities for converting the deserialized RDF data to/from the representations of RDF libraries (like Apache Jena or RDF4J). </p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-jena</code> \u2013 conversions and interop code for the Apache Jena library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-rdf4j</code> \u2013 conversions and interop code for the RDF4J library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-stream</code> \u2013 utilities for building Reactive Streams of RDF data (based on Pekko Streams). Useful for integrating with gRPC or other streaming protocols (e.g., Kafka, MQTT).</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-grpc</code> \u2013 implementation of a gRPC client and server for the Jelly gRPC streaming protocol.</p> <ul> <li> </li> </ul> </li> </ul>"},{"location":"#todo-plugin-jars","title":"TODO: PLUGIN JARS","text":""},{"location":"#compatibility","title":"Compatibility","text":"<p>The Jelly-JVM implementation is compatible with Java 11 and newer. Java 11, 17, and 21 are tested in CI and are guaranteed to work. Jelly is built with Scala 3 LTS releases.</p> <p>The following table shows the compatibility of the Jelly-JVM implementation with other libraries:</p> Jelly Scala Java RDF4J Apache Jena Apache Pekko 1.0.x (current) 3.3.x (LTS) 11+ 4.x.y 4.x.y 1.0.x"},{"location":"#documentation","title":"Documentation","text":"<p>Below is a list of all documentation pages about Jelly-JVM. You can also browse the Javadoc using the badges in the module list above. The documentation uses examples written in Scala, but the libraries can be used from Java as well.</p> <ul> <li>Getting started with Jena/RDF4J plugins \u2013 how to use Jelly-JVM as a plugin for Apache Jena or RDF4J, without writing any code.</li> <li>Getting started for developers \u2013 how to use Jelly-JVM in code.</li> <li>User guide<ul> <li>Apache Jena integration</li> <li>RDF4J integration</li> <li>Reactive streaming</li> <li>gRPC</li> <li>Userful utilities</li> </ul> </li> <li>Developer guide<ul> <li>Releases</li> <li>Implementing Jelly for other libraries</li> </ul> </li> <li>Main Jelly website \u2013 including the Jelly protocol specification and explanation of the the various stream types.</li> </ul>"},{"location":"getting-started-devs/","title":"Jelly-JVM \u2013 getting started for developers","text":"<p>If you don't want to code anything and only use Jelly with your Apache Jena/RDF4J application, see the dedicated guide about using Jelly-JVM as a plugin.</p> <p>TODO: for </p>"},{"location":"getting-started-plugins/","title":"Jelly-JVM \u2013 getting started with Jena/RDF4J plugins","text":"<p>This guide explains how to use Jelly-JVM with Apache Jena or RDF4J as a plugin, without writing a single line of code. Jelly-JVM provides plugin JARs that you can simply drop in the appropriate directory to get Jelly format support in your application.</p>"},{"location":"getting-started-plugins/#installation","title":"Installation","text":""},{"location":"getting-started-plugins/#apache-jena-apache-jena-fuseki","title":"Apache Jena, Apache Jena Fuseki","text":"<p>You can simply add Jelly format support to Apache Jena or Apacha Jena Fuseki with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  version 0.11.2 from here,  or you can go the the releases page on GitHub to download a different version of the <code>jelly-jena-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your Apache Jena version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath:<ul> <li>For Apache Jena Fuseki, simply place the file in <code>$FUSEKI_BASE/extra/</code> directory. <code>$FUSEKI_BASE</code> is the directory usually called <code>run</code> where you have files such as <code>config.ttl</code> and <code>shiro.ini</code>. You will most likely need to create the <code>extra</code> directory yourself.</li> <li>For Apache Jena, place the file in the <code>lib/</code> directory of your Jena installation.</li> <li>For other applications, consult the manual of the application.</li> </ul> </li> <li>You can now use Jelly format for parsing, serialization, and streaming serialization in your Jena application.</li> </ul>"},{"location":"getting-started-plugins/#eclipse-rdf4j","title":"Eclipse RDF4J","text":"<p>You can simply add Jelly format support to an application based on RDF4J with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  version 0.11.2 from here,  or you can go the the releases page on GitHub to download a specific version of the <code>jelly-rdf4j-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your RDF4J version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath. Consult the manual of your application for the exact location.</li> <li>You can now use Jelly format for parsing, serialization, and streaming serialization in your RDF4J application.</li> </ul>"},{"location":"getting-started-plugins/#supported-features","title":"Supported features","text":"<p>The Jelly-JVM plugin JARs provide the following features:</p> <ul> <li>Full support for parsing and serialization of RDF data (triples and quads) in the Jelly format.<ul> <li>In Apache Jena also the stream serialization is supported.</li> </ul> </li> <li>Recognizing the <code>.jelly</code> file extension.</li> <li>Recognizing the <code>application/x-jelly-rdf</code> media type.</li> </ul> <p>The Jelly format is registered under the name <code>jelly</code> in the RDF libraries, so you can use it in the same way as other formats like Turtle, RDF/XML, or JSON-LD.</p>"},{"location":"getting-started-plugins/#see-also","title":"See also","text":"<ul> <li>Getting started for developers \u2013 if you want to get your hands dirty with code and get more features out of Jelly.</li> </ul>"},{"location":"dev/implementing/","title":"Developer guide \u2013 implementing conversions for other libraries","text":"<p>Currently converters for the two most popular RDF JVM libraries are implemented \u2013 RDF4J and Jena. But it is possible to implement your own converters and adapt the Jelly serialization code to any RDF library with little effort.</p> <p>To do this, you will need to implement three traits (interfaces in Java) from the <code>jelly-core</code> module: <code>ProtoEncoder</code>, <code>ProtoDecoderConverter</code>, and <code>ConverterFactory</code>.</p> <ul> <li> <p>ProtoEncoder (serialization)</p> <ul> <li><code>get*</code> methods deconstruct triple statements, quad statements, and quoted triples (RDF-star). You can make them <code>inline</code>.</li> <li><code>nodeToProto</code> and <code>graphToProto</code> should translate into Jelly's representation all possible variations of RDF terms in the SPO and G positions, respectively.</li> <li>Example implementation for Jena: JenaProtoEncoder</li> <li>You can skip implementing this trait if you don't need serialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</li> </ul> </li> <li> <p>ProtoDecoderConverter (deserialization)</p> <ul> <li>The <code>make*</code> methods should construct new RDF terms and statements. You can make them <code>inline</code>.</li> <li>Example implementation for Jena: JenaDecoderConverter</li> <li>You can skip implementing this trait if you don't need deserialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</li> </ul> </li> <li> <p>ConverterFactory \u2013 wrapper that allows other modules to use your converter.</p> <ul> <li>The methods should just return new instances of your <code>ProtoEncoder</code> and <code>ProtoDecoderConverter</code> implementations.</li> <li>Example for Jena: JenaConverterFactory</li> </ul> </li> </ul>"},{"location":"dev/releases/","title":"Developer guide \u2013 releases","text":""},{"location":"dev/releases/#full-versioned-releases","title":"Full (versioned) releases","text":"<p>Full (versioned) releases are created manually and follow the Semantic Versioning scheme for binary compatibility.</p> <p>To create a new tagged release (example for version 1.2.3): <pre><code>$ git checkout main\n$ git pull\n$ git tag v1.2.3\n$ git push origin v1.2.3\n</code></pre></p> <p>The rest (packaging and release creation) will be handled automatically by the CI. The release will be pushed to Maven Central.</p>"},{"location":"dev/releases/#snapshot-releases","title":"Snapshot releases","text":"<p>Snapshot releases are triggered automatically by commits in the <code>main</code> branch. Snapshots are pushed to the Sonatype snapshot repository.</p>"},{"location":"user/grpc/","title":"User guide \u2013 gRPC","text":""},{"location":"user/grpc/#example-grpc-pubsub","title":"Example \u2013 gRPC pub/sub","text":""},{"location":"user/jena/","title":"Apache Jena integration","text":"<p>...</p> <p>If you just want to use Jelly with your Apache Jena / Apache Jena Fuseki, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/rdf4j/","title":"RDF4J integration","text":"<p>...</p> <p>If you just want to use Jelly with your RDF4J application, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/reactive/","title":"User guide \u2013 reactive streaming","text":"<p>TODO</p>"},{"location":"user/reactive/#example-streaming-with-kafka","title":"Example: streaming with Kafka","text":""},{"location":"user/reactive/#byte-streams","title":"Byte streams","text":"<p>TODO</p> <p>(referenced by specification/serialization.md)</p>"},{"location":"user/utilities/","title":"Useful utilities","text":"<p>TODO: all utilities defined in <code>core</code>, including obtaining RDF-STaX annotations (describe its potential uses \u2013 external metadata, etc. \u2013 in the docs.) and constructing logical types from RDF-STaX IRIs.</p>"}]}