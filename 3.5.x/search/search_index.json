{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jelly-JVM","text":"<p>Jelly-JVM is an implementation of the Jelly serialization format and gRPC streaming protocol for the Java Virtual Machine (JVM). It supports Apache Jena, Eclipse RDF4J, the Titanium RDF API, and Neo4j.</p> <p>Jelly-JVM provides a full stack of utilities for fast and scalable RDF streaming with Jelly. Oh, and it's blazing-fast, too!</p> <p>Getting started with plugins \u2013 no code required</p> <p>Use our plugins for Neo4j, Apache Jena, and RDF4J to quickly add Jelly support to your applications without writing any code.</p> <p>Getting started for application developers</p> <p>If you want to use the full feature set of Jelly-JVM in your code, see the getting started guide for application developers.</p> <p>This documentation is for Jelly-JVM version 3.5.2, which uses the Jelly protocol version dev. If you are looking for the documentation of a different version, use the version selector on the left of the top navigation bar. See: latest stable version, latest development version.</p>"},{"location":"#library-modules","title":"Library modules","text":"<p>The implementation is split into a few modules that can be used separately:</p> <ul> <li> <p><code>jelly-core</code> \u2013 core generic code for serializing/deserializing Jelly data. You need an additional module (like <code>jelly-jena</code>) to integrate it with a specific RDF library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-jena</code> \u2013 integration with Apache Jena.  Learn more</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-rdf4j</code> \u2013 integration with Eclipse RDF4J.  Learn more</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-titanium-rdf-api</code> \u2013 integration with the Titanium RDF API.  Learn more</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-neo4j-plugin</code> \u2013 integration with the Neo4j graph database via the neosemantics plugin.  Learn more</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-pekko-stream</code> \u2013 utilities for building Reactive Streams of RDF data, based on Pekko Streams. Useful for integrating with for example gRPC, Kafka, or MQTT.  Learn more</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-pekko-grpc</code> \u2013 implementation of a gRPC client and server for the Jelly gRPC streaming protocol.  Learn more</p> <ul> <li> </li> </ul> </li> </ul>"},{"location":"#jelly-patch-experimental","title":"Jelly-Patch (experimental)","text":"<p>Jelly-Patch is an efficient format for recording changes to RDF datasets. Jelly-JVM has an experimental implementation of Jelly-Patch:</p> <ul> <li><code>jelly-core-patch</code> \u2013 core generic code for serializing/deserializing Jelly-Patch data. You need an additional module (like <code>jelly-jena-patch</code>) to integrate it with a specific RDF library.<ul> <li> </li> </ul> </li> <li><code>jelly-jena-patch</code> \u2013 integration with Apache Jena.<ul> <li> </li> </ul> </li> <li><code>jelly-rdf4j-patch</code> \u2013 partial integration with Eclipse RDF4J. RDF4J does not support RDF Patch, so this module only provides low-level Jelly-Patch support.<ul> <li> </li> </ul> </li> </ul>"},{"location":"#plugin-jars","title":"Plugin JARs","text":"<p>We also publish plugin JARs which allow you to use Jelly-JVM with Apache Jena, RDF4J, and Neo4j just by dropping the JARs into the classpath.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>Jelly-JVM is compatible with Java 17 and newer. Java 17, 21, and 24 are tested in CI and are guaranteed to work. The modules integrating with Pekko Streams use Scala and are built with Scala 3 LTS releases.</p> <p>The following table shows the compatibility of the Jelly-JVM implementation with other libraries:</p> Jelly-JVM Java Scala RDF4J Jena Pekko Neo4j 3.5.x\u20133.5.2 17+ 3.3.x (LTS)<sup>1</sup> 4.3.x\u20135.x.x 5.x.x 1.1.x\u20131.2.x 5.1.0\u20135.26.0 3.0.x\u20133.4.x 17+ 3.3.x (LTS)<sup>1</sup> 5.x.x 5.x.x 1.1.x \u2013 2.0.x\u20132.10.x 17+ 3.3.x (LTS) 5.x.x 5.x.x 1.1.x \u2013 1.0.x 11+ 3.3.x (LTS)2.13.x<sup>2</sup> 4.x.x 4.x.x 1.0.x \u2013 <p>See the compatibility policy for more details and the release notes on GitHub.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Below is a list of all documentation pages about Jelly-JVM. You can also browse the Javadoc using the badges in the module list above. The documentation uses examples written in Scala, but the libraries can be used from Java as well.</p> <ul> <li>Getting started<ul> <li>Jena/RDF4J plugins \u2013 how to use Jelly-JVM as a plugin for Apache Jena or RDF4J, without writing any code.</li> <li>Neo4j plugin \u2013 how to use the Jelly plugin with Neo4j and neosemantics.</li> <li>Application developers \u2013 how to use Jelly-JVM in code.</li> </ul> </li> <li>User guide<ul> <li>Apache Jena integration</li> <li>RDF4J integration</li> <li>Titanium RDF API integration (new in 2.9.0!)</li> <li>Reactive streaming with Apache Pekko</li> <li>gRPC</li> <li>Useful utilities</li> <li>Compatibility policy</li> <li>Implementing Jelly for other libraries</li> </ul> </li> <li>Contributing to Jelly-JVM<ul> <li>Releases</li> </ul> </li> <li>License and citation</li> <li>Release notes on GitHub</li> <li>Main Jelly website \u2013 including the Jelly protocol specification and explanation of the various stream types.</li> </ul>"},{"location":"#commercial-and-community-support","title":"Commercial and community support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new frameworks, benchmarking, and more.</p> <p>Community support is available on the Jelly Discord chat.</p> <p>The development of the Jelly protocol, its implementations, and supporting tooling was co-funded by the European Union. More details.</p> <p></p> <ol> <li> <p>Scala version applies only to the <code>jelly-pekko-*</code> modules. The other modules do not depend on Scala and are compatible with any version of Java 17+.\u00a0\u21a9\u21a9</p> </li> <li> <p>Scala 2.13-compatible builds of Jelly-JVM are available for Jelly-JVM 1.0.x. Scala 2 support was removed in subsequent versions. See more details.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started-devs/","title":"Getting started for developers","text":"<p>If you don't want to code anything and only use Jelly with your Apache Jena/RDF4J application, see the dedicated guide about using Jelly-JVM as a plugin.</p> <p>This guide explains a few of the basic functionalities of Jelly-JVM and how to use them in your code. The core of Jelly-JVM is written in Java, but the reactive streaming module for Apache Pekko is written entirely in Scala, along with unit and integration tests.</p>"},{"location":"getting-started-devs/#quick-start-apache-jena","title":"Quick start \u2013 Apache Jena","text":"<p>Depending on your RDF library of choice (Apache Jena, RDF4J, Titanium), you should import one of the dependencies: <code>jelly-jena</code>, <code>jelly-rdf4j</code>, <code>jelly-titanium-rdf-api</code><sup>1</sup>. In our examples we will use Jena, so let's add this to your <code>build.sbt</code> file:</p> MavenGradleSBT pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.neverblink.jelly&lt;/groupId&gt;\n    &lt;artifactId&gt;jelly-jena&lt;/artifactId&gt;\n    &lt;version&gt;3.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle<pre><code>dependencies {\n    implementation \"eu.neverblink.jelly:jelly-jena:${jellyVersion}\"\n}\n</code></pre> build.sbt<pre><code>lazy val jellyVersion = \"3.5.2\"\nlibraryDependencies ++= Seq(\n  \"eu.neverblink.jelly\" % \"jelly-jena\" % jellyVersion,\n)\n</code></pre> <p>Now you can serialize/deserialize Jelly data with Apache Jena. Jelly is fully integrated with Jena, so it should all just magically work. Here is a simple example of reading a <code>.jelly</code> file (in this case, a metadata file from RiverBench) with RIOT:</p> JavaScala Deserialization example (Java)<pre><code>import eu.neverblink.jelly.convert.jena.riot.JellyLanguage;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.riot.RDFDataMgr;\n\n// Load an RDF graph from a Jelly file\nModel model = RDFDataMgr.loadModel(\n  \"https://w3id.org/riverbench/v/2.0.1.jelly\", \n  JellyLanguage.JELLY\n);\n\n// Print the size of the model\nSystem.out.println(\"Loaded an RDF graph with \" + model.size() + \" triples\");\n</code></pre> Deserialization example (Scala 3)<pre><code>import eu.neverblink.jelly.convert.jena.riot.*\nimport org.apache.jena.riot.RDFDataMgr\n\n// Load an RDF graph from a Jelly file\nval model = RDFDataMgr.loadModel(\n  \"https://w3id.org/riverbench/v/2.0.1.jelly\", \n  JellyLanguage.JELLY\n)\n// Print the size of the model\nprintln(s\"Loaded an RDF graph with ${model.size} triples\")\n</code></pre> <p>Serialization is just as easy:</p> JavaScala Serialization example (Java)<pre><code>import eu.neverblink.jelly.convert.jena.riot.JellyLanguage;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.riot.RDFDataMgr;\n\nimport java.io.FileOutputStream;\n\n// Omitted here: creating an RDF model.\n// You can use the one from the previous example.\n\ntry (FileOutputStream out = new FileOutputStream(\"metadata.jelly\")) {\n  // Write the model to a Jelly file\n  RDFDataMgr.write(out, model, JellyLanguage.JELLY);\n  System.out.println(\"Saved the model to metadata.jelly\");\n}\n</code></pre> Serialization example (Scala 3)<pre><code>import eu.neverblink.jelly.convert.jena.riot.*\nimport org.apache.jena.riot.RDFDataMgr\n\nimport java.io.FileOutputStream\nimport scala.util.Using\n\n// Omitted here: creating an RDF model.\n// You can use the one from the previous example.\n\nUsing.resource(new FileOutputStream(\"metadata.jelly\")) { out =&gt;\n  // Write the model to a Jelly file\n  RDFDataMgr.write(out, model, JellyLanguage.JELLY)\n  println(\"Saved the model to metadata.jelly\")\n}\n</code></pre> <p> Use Jelly-JVM with Apache Jena</p> <p> Use Jelly-JVM with RDF4J</p> <p> Use Jelly-JVM with Titanium RDF API</p>"},{"location":"getting-started-devs/#quick-start-titanium-rdf-api","title":"Quick start \u2013 Titanium RDF API","text":"<p>If you aren't using a big RDF library like Jena or RDF4J, the simplest way to get started is to use the Titanium RDF API:</p> MavenGradleSBT pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.neverblink.jelly&lt;/groupId&gt;\n    &lt;artifactId&gt;jelly-titanium-rdf-api&lt;/artifactId&gt;\n    &lt;version&gt;3.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle<pre><code>dependencies {\n    implementation \"eu.neverblink.jelly:jelly-titanium-rdf-api:${jellyVersion}\"\n}\n</code></pre> build.sbt<pre><code>lazy val jellyVersion = \"3.5.2\"\nlibraryDependencies ++= Seq(\n  \"eu.neverblink.jelly\" % \"jelly-titanium-rdf-api\" % jellyVersion,\n)\n</code></pre> <p>You can write a Jelly file like this, using the simple <code>RdfQuadConsumer</code> interface:</p> Titanium writer example (Java)<pre><code>var writer = TitaniumJellyWriter.factory(outputStream);\nwriter.quad(subject, predicate, object, ...);\n</code></pre> <p>Where <code>outputStream</code> is a Java <code>OutputStream</code> hooked up to, for example, a file on disk.</p> <p>And read it like this, pointing the reader to an <code>RdfQuadConsumer</code>:</p> Titanium reader example (Java)<pre><code>var reader = TitaniumJellyReader.factory();\nreader.parseAll(quadConsumer, inputStream);\n</code></pre> <p>In this way, you can simply convert between Jelly, JSON-LD, CBOR-LD, N-Quads and other libraries supporting the <code>RdfQuadConsumer</code> interface.</p> <p> More on using Jelly-JVM with Titanium RDF API</p>"},{"location":"getting-started-devs/#rdf-pekko-streams","title":"RDF Pekko Streams","text":"<p>Now, the real power of Jelly lies in its streaming capabilities. Not only can it stream individual RDF triples/quads (this is called flat streaming), but it can also very effectively handle streams of RDF graphs or datasets. To work with streams, you need to use the <code>jelly-pekko-stream</code> module, which is based on the Apache Pekko Streams library. So, let's update our dependencies:</p> MavenGradleSBT pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.neverblink.jelly&lt;/groupId&gt;\n    &lt;artifactId&gt;jelly-pekko-stream_3&lt;/artifactId&gt;\n    &lt;version&gt;3.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle<pre><code>dependencies {\n    implementation \"eu.neverblink.jelly:jelly-pekko-stream_3:${jellyVersion}\"\n}\n</code></pre> build.sbt<pre><code>lazy val jellyVersion = \"3.5.2\"\n\nlibraryDependencies ++= Seq(\n  \"eu.neverblink.jelly\" %% \"jelly-jena\" % jellyVersion,\n  \"eu.neverblink.jelly\" %% \"jelly-pekko-stream\" % jellyVersion,\n)\n</code></pre> <p>Now, let's say we have a stream of RDF graphs \u2013 for example each graph corresponds to one set of measurements from an IoT sensor. We want to have a stream that turns these graphs into their serialized representations (byte arrays), which we can then send over the network. Here is how to do it:</p> Apache Pekko Reactive streaming example (Scala 3)<pre><code>// We need to import \"jena.given\" for Jena-to-Jelly conversions\nimport eu.neverblink.jelly.convert.jena.{JenaAdapters, JenaConverterFactory}\nimport eu.neverblink.jelly.convert.jena.riot.*\nimport eu.neverblink.jelly.core.JellyOptions\nimport eu.neverblink.jelly.stream.*\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport scala.concurrent.ExecutionContext\n\n// We will need a Pekko actor system to run the streams\ngiven actorSystem: ActorSystem = ActorSystem()\n\n// And an execution context for the futures\ngiven ExecutionContext = actorSystem.getDispatcher\n\n// We will need a JenaConverterFactory to convert between Jelly and Jena\ngiven JenaConverterFactory = JenaConverterFactory.getInstance()\n\n// We need to import the Jena adapters to turn Model/Dataset into a stream of statements\ngiven JenaAdapters.DATASET_ADAPTER.type = JenaAdapters.DATASET_ADAPTER\ngiven JenaAdapters.MODEL_ADAPTER.type = JenaAdapters.MODEL_ADAPTER\n\n// Load an RDF graph for testing\nval model = RDFDataMgr.loadModel(\n  \"https://w3id.org/riverbench/v/2.0.1.jelly\", \n  JellyLanguage.JELLY\n)\n\nSource.repeat(model) // Create a stream of the same model over and over\n  .take(10) // Take only the first 10 elements in the stream\n  .flatMap(model =&gt; RdfSource.builder // Convert each model to a source of triples\n    .graphAsTriples(model) \n    .source\n  )\n  .via(EncoderFlow.graphStream( // Encode each iterable to a Jelly stream frame\n    maybeLimiter = None, // 1 RDF graph = 1 message\n    JellyOptions.smallStrict, // Jelly compression settings preset\n  ))\n  .via(JellyIo.toBytes) // Convert the stream frames to a byte arrays\n  .runForeach { bytes =&gt;\n    // Just print the length of each byte array in the stream.\n    // You can also hook this up to MQTT, Kafka, etc.\n    println(s\"Streamed ${bytes.length} bytes\")\n  }\n  .onComplete(_ =&gt; actorSystem.terminate())\n</code></pre> <p>Jelly will compress this stream on-the-fly, so if the data is repetitive, it will be very efficient. If you run this code, you will notice that the byte sizes for the later graphs are smaller, even though we are sending the same graph over and over again. But, even if each graph is completely different, Jelly still should be much faster than other serialization formats.</p> <p>These streams are very powerful, because they are reactive and asynchronous \u2013 in short, this means you can hook this up to any data source and any data sink \u2013 and you can scale it up as much as you want. If you are unfamiliar with the concept of reactive streams, we recommend you start with this Apache Pekko Streams guide.</p> <p>Jelly-JVM supports streaming serialization and deserialization of all types of streams in the RDF Stream Taxonomy. You can read more about the theory of this and all available stream types in the Jelly protocol documentation.</p> <p> Learn more about reactive streaming with Jelly-JVM</p> <p> Learn more about the types of streams in Jelly</p>"},{"location":"getting-started-devs/#grpc-streaming","title":"gRPC streaming","text":"<p>Jelly is a bit more than just a serialization format \u2013 it also defines a gRPC-based straming protocol. You can use it for streaming RDF data between microservices, to build a pub/sub system, or to publish RDF data to the web.</p> <p> Learn more about using Jelly gRPC protocol servers and clients</p>"},{"location":"getting-started-devs/#further-reading","title":"Further reading","text":"<ul> <li>Using Jelly-JVM with Apache Jena</li> <li>Using Jelly-JVM with RDF4J</li> <li>Using Jelly-JVM with Titanium RDF API</li> <li>Reactive streaming with Jelly-JVM and Apache Pekko \u2013 using the <code>jelly-pekko-stream</code> module and Apache Pekko Streams</li> <li>Using Jelly gRPC protocol servers and clients</li> <li>Other useful utilities in Jelly-JVM</li> <li>Low-level usage of Jelly-JVM</li> </ul>"},{"location":"getting-started-devs/#example-applications-using-jelly-jvm","title":"Example applications using Jelly-JVM","text":"<ul> <li>The <code>examples</code> directory in the Jelly-JVM repo contains code snippets that demonstrate how to use the library in various scenarios.</li> <li><code>jelly-cli</code> command-line utility can help you convert to/from Jelly, as well as validate and debug Jelly files.</li> <li>Nanopub Registry and Query are production applications of Jelly. They use Jelly-JVM for inter-service communication, using the RDF4J integration.</li> <li>RiverBench ci-worker \u2013 a real-world application that is used for processing large RDF datasets in a CI/CD pipeline. It uses Jelly-JVM for serialization and deserialization with Apache Jena. It also uses extensively Apache Pekko Streams.</li> <li>Jelly JVM benchmarks \u2013 research software for testing the performance of Jelly-JVM and other RDF serializations in Apache Jena. It uses most of Jelly-JVM's features.</li> </ul>"},{"location":"getting-started-devs/#questions","title":"Questions?","text":"<p>If you have any questions about using Jelly-JVM, feel free to open an issue on GitHub.</p> <ol> <li> <p>There is nothing stopping you from using more than one at the same time. You can also pretty easily add support for any other Java-based RDF library by implementing a few interfaces. More details here.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started-neo4j/","title":"Getting started with Neo4j","text":"<p>Info</p> <p>This integration with Neo4j requires the use of the neosemantics plugin that only works with Neo4j Desktop and self-hosted instances (Neo4j Community/Enterprise). It does not work with AuraDB. For AuraDB, you can alternatively use the Python integration that connects to Neo4j over Bolt via rdflib-neo4j.</p>"},{"location":"getting-started-neo4j/#installation","title":"Installation","text":"<p>The latest version (3.5.2) of the Jelly-Neo4j plugin is compatible with Neo4j versions 5.1.0\u20135.26.0<sup>1</sup>. Jelly-Neo4j depends on the neosemantics plugin, which must also be installed. Neosemantics must have the same version as the Neo4j database.</p> Neo4j DesktopSelf-hosted server (Community and Enterprise editions) <ol> <li>Install Neo4j Desktop if you haven't already.</li> <li>Create a new local instance. Select Neo4j version 5.26.0.</li> <li>In the list of instances, click on the  button next to \"Path:\" to open the instance folder.</li> <li>Open the <code>plugins</code> subfolder.</li> <li>Download the neosemantics plugin <code>.jar</code> file from the neosemantics releases page and place it in the <code>plugins</code> folder.</li> <li>Download the Jelly-Neo4j plugin <code>.jar</code> file and place it in the <code>plugins</code> folder.</li> <li>Go back to the Neo4j Desktop application and restart your instance.</li> </ol> <ol> <li>Install Neo4j Community or Enterprise Edition if you haven't already. The supported Neo4j versions are currently 5.1.0\u20135.26.0.</li> <li>Open the Neo4j installation folder (<code>$NEO4J_HOME</code>).</li> <li>Open the <code>plugins</code> subfolder.</li> <li>Download the neosemantics plugin <code>.jar</code> file from the neosemantics releases page and place it in the <code>plugins</code> folder. The plugin's version must be the same as Neo4j's.</li> <li>Download the Jelly-Neo4j plugin <code>.jar</code> file and place it in the <code>plugins</code> folder.</li> <li>Start the Neo4j server.</li> </ol> <p>At the end, your <code>plugins</code> folder should look like this:</p> $ ls<pre><code>jelly-neo4j-plugin.jar  neosemantics-5.26.0.jar  README.txt\n</code></pre> <p>See also the installation instructions for neosemantics.</p>"},{"location":"getting-started-neo4j/#usage","title":"Usage","text":"<p>The Jelly-Neo4j plugin adds support for Jelly to all functionalities of neosemantics. Two formats are supported:</p> <ul> <li><code>Jelly</code> \u2013 native binary format. Supported in all places except aggregations due to Neo4j limitations.</li> <li><code>Jelly-base64</code> \u2013 base64-encoded version of Jelly. Supported in all places.</li> </ul>"},{"location":"getting-started-neo4j/#setup","title":"Setup","text":"<p>To get started with using the neosemantics plugin, changes must be made to database's constraints and graph config. See the instructions in the neosemantics documentation.</p>"},{"location":"getting-started-neo4j/#importing-data","title":"Importing data","text":"<p>To import a Jelly file (either local or via HTTP), use the <code>n10s.rdf.import.fetch</code> procedure, with first argument set to the file URL or path, and the second set to <code>Jelly</code>. For example, to import RiverBench's metadata, call:</p> <pre><code>CALL n10s.rdf.import.fetch(\n    'https://w3id.org/riverbench/dumps-with-results/dev.jelly.gz', \n    'Jelly'\n)\n</code></pre>"},{"location":"getting-started-neo4j/#cypher-aggregations","title":"Cypher aggregations","text":"<p>Results from Cypher queries can be aggregated into RDF data using the <code>n10s.rdf.export.cypher</code> procedure and <code>n10s.rdf.collect.jelly_base64</code> aggregation:</p> <pre><code>CALL n10s.rdf.export.cypher(\"MATCH (p) RETURN p LIMIT 10\")\nyield subject, predicate, object, isLiteral, literalType, literalLang\nreturn n10s.rdf.collect.jelly_base64(\n    subject, predicate, object, isLiteral, literalType, literalLang\n) as rdf\n</code></pre> <p>Note that the output here will be base64-encoded, due to Neo4j's limitations when working with binary data. To parse this, you will either need to use the <code>Jelly-base64</code> format in Neo4j, or decode it first from base64.</p>"},{"location":"getting-started-neo4j/#exporting-data-via-http","title":"Exporting data via HTTP","text":"<p>HTTP endpoints for bulk RDF export can be enabled in neosemantics by adding the following configuration to the <code>neo4j.conf</code> file:</p> <pre><code>server.unmanaged_extension_classes=n10s.endpoint=/rdf\n</code></pre> <p>Then, you can for example call the following endpoint to export the results of Cypher queries or describe individual nodes \u2013 simply append the <code>?format=Jelly</code> query parameter. For example, to describe the <code>https://w3id.org/riverbench/datasets/osm2rdf-denmark/dev</code> node, call:</p> <pre><code>GET /rdf/neo4j/describe/https%3A%2F%2Fw3id.org%2Friverbench%2Fdatasets%2Fosm2rdf-denmark%2Fdev?format=Jelly\n</code></pre> <p>The identifier was urlencoded. The result will be a Jelly file containing a description of the node.</p> <p>See the neosemantics documentation for more details and examples.</p>"},{"location":"getting-started-neo4j/#deleting-data","title":"Deleting data","text":"<p>In much the same way as importing, you can delete data with the <code>n10s.rdf.delete.fetch</code> procedure. For example, to delete all triples and quads from a Jelly file, call:</p> <pre><code>CALL n10s.rdf.delete.fetch(\n    'https://w3id.org/riverbench/dumps-with-results/dev.jelly.gz', \n    'Jelly'\n)\n</code></pre>"},{"location":"getting-started-neo4j/#checking-the-version-of-the-plugin","title":"Checking the version of the plugin","text":"<p>To check the version of the Jelly-Neo4j plugin, call:</p> <pre><code>RETURN jelly.version()\n</code></pre>"},{"location":"getting-started-neo4j/#more","title":"More...","text":"<p>All features of neosemantics are supported. See the neosemantics documentation for more details.</p>"},{"location":"getting-started-neo4j/#see-also","title":"See also","text":"<ul> <li>Alternative integration with Python and RDFLib</li> <li>neosemantics documentation</li> <li>Getting started with Jena and RDF4J plugins</li> </ul> <ol> <li> <p>The limiting factor for compatibility is the neosemantics plugin, which must have the same version as the Neo4j database. Unfortunately, neosemantics is often much behind the latest Neo4j releases.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started-plugins/","title":"Getting started with Jena/RDF4J plugins","text":"<p>This guide explains how to use Jelly-JVM with Apache Jena or RDF4J as a plugin, without writing a single line of code. We provide plugin JARs that you can simply drop in the appropriate directory to get Jelly format support in your application.</p>"},{"location":"getting-started-plugins/#installation","title":"Installation","text":""},{"location":"getting-started-plugins/#apache-jena-apache-jena-fuseki","title":"Apache Jena, Apache Jena Fuseki","text":"<p>You can use Apache Jena or Apacha Jena Fuseki with Jelly's plugin JAR.</p> <ul> <li>Download the plugin JAR:  version 3.5.2,  or you can go to the releases page on GitHub to download a different version of the <code>jelly-jena-plugin.jar</code> file.<ul> <li>The plugin must be compatible with your Apache Jena version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath:<ul> <li>For Apache Jena Fuseki, place it in the <code>$FUSEKI_BASE/extra/</code> directory. <code>$FUSEKI_BASE</code> is the directory usually called <code>run</code> where you have files such as <code>config.ttl</code> and <code>shiro.ini</code>. You will most likely need to create the <code>extra</code> directory yourself.</li> <li>For Apache Jena, place the file in the <code>lib/</code> directory of your Jena installation.</li> <li>For other applications, consult the manual of the application.</li> </ul> </li> <li>You can now use the Jelly format for parsing, serialization, and streaming serialization in your application!</li> </ul> <p>Content negotiation in Fuseki</p> <p>Content negotiation using the <code>application/x-jelly-rdf</code> media type in the <code>Accept</code> header works in Fuseki since Apache Jena version 5.2.0. Previous versions of Fuseki did not support media type registration.</p> <p>How to use Jelly with Jena's CLI tools?</p> <p>Jelly-JVM fully supports Apache Jena's command-line interface (CLI) utilities. See the dedicated guide for more information.</p>"},{"location":"getting-started-plugins/#eclipse-rdf4j","title":"Eclipse RDF4J","text":"<ul> <li>Download the plugin JAR:  version 3.5.2,  or you can go the the releases page on GitHub to download a specific version of the <code>jelly-rdf4j-plugin.jar</code> file.<ul> <li>The plugin must be compatible with your RDF4J version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath:<ul> <li>For the RDF4J SDK distribution, place the file in the <code>lib/</code> directory of your RDF4J installation.</li> <li>For other applications, consult the manual of your application for the exact location.</li> </ul> </li> <li>You can now use the Jelly format for parsing and serialization in your application!</li> </ul>"},{"location":"getting-started-plugins/#supported-features","title":"Supported features","text":"<ul> <li>Full support for parsing and serialization of RDF data (triples and quads) in the Jelly format.<ul> <li>The parser will automatically detect if the input data is delimited or not. Both delimited and non-delimited Jelly data can be parsed.</li> <li>In Apache Jena also the stream serialization API is supported (<code>StreamRDF</code>).</li> </ul> </li> <li>Recognizing the <code>.jelly</code> file extension.</li> <li>Recognizing the <code>application/x-jelly-rdf</code> media type.</li> </ul> <p>The Jelly format is registered under the name <code>jelly</code> in the RDF libraries, so you can use it in the same way as other formats like Turtle, RDF/XML, or JSON-LD.</p>"},{"location":"getting-started-plugins/#see-also","title":"See also","text":"<ul> <li>Getting started with the Neo4j plugin</li> <li>Getting started for developers \u2013 if you want to get your hands dirty with code and get more features out of Jelly.</li> <li><code>jelly-cli</code> command-line tool \u2013 useful for converting things to or from Jelly.</li> </ul>"},{"location":"licensing/","title":"Licensing and citation","text":"<p>Jelly-JVM is licensed under the Apache License 2.0.</p> <p>Jelly-JVM contributors: https://github.com/Jelly-RDF/jelly-jvm/graphs/contributors</p>"},{"location":"licensing/#jelly-maintainer","title":"Jelly maintainer","text":"<p>The entire Jelly tool stack is currently maintained by NeverBlink.</p> <p>The Jelly protocol and Jelly-JVM were originally created by Piotr Sowi\u0144ski (GitHub).</p>"},{"location":"licensing/#attribution-citation","title":"Attribution / citation","text":"<p>If you use Jelly in your research, please cite the most recent paper about it:</p> <p>Sowi\u0144ski, P., Bogacka, K., Danilenka, A., Kozlov, N. (2025). Jelly: a fast and convenient RDF serialization format. In arXiv preprint arXiv:2506.11298. DOI: 10.48550/arXiv.2506.11298</p> <p>Or use this BibTeX entry:</p> <pre><code>@article{sowinski2025jelly,\n  title = {Jelly: a fast and convenient RDF serialization format},\n  author = {Sowi{\\'n}ski, Piotr and Bogacka, Karolina and Danilenka, Anastasiya and Kozlov, Nikita},\n  journal = {arXiv preprint arXiv:2506.11298},\n  year = {2025},\n  doi = {10.48550/arXiv.2506.11298},\n}\n</code></pre> <p>You can also check out an older paper that describes an earlier version of the Jelly protocol: Efficient RDF streaming for the edge-cloud continuum.</p>"},{"location":"licensing/#see-also","title":"See also","text":"<ul> <li>Contributing to Jelly-JVM</li> <li>Projects and funding</li> </ul>"},{"location":"contributing/","title":"Contributing to Jelly-JVM","text":"<p>Jelly-JVM is an open project \u2013 you are welcome to submit issues, pull requests, or just ask questions!</p>"},{"location":"contributing/#quick-start","title":"Quick start","text":"<p>Clone the project with submodules:</p> <pre><code>git clone --recursive git@github.com:Jelly-RDF/jelly-jvm.git\n</code></pre> <p>We use <code>sbt</code> as our build system. If you don't already have it installed, get it from scala-sbt.org, or via coursier.</p>"},{"location":"contributing/#user-developer-chat","title":"User &amp; developer chat","text":"<p>If you have any questions or want to discuss a feature, you can join the Jelly Discord chat.</p>"},{"location":"contributing/#code-of-conduct","title":"Code of conduct","text":"<p>By participating in this project, you are expected to follow our Code of conduct. Be kind, inclusive, and constructive.</p>"},{"location":"contributing/#submitting-issues","title":"Submitting issues","text":"<p>If you have a question, found a bug, or have an idea for a new feature, please open an issue in the GitHub issue tracker.</p>"},{"location":"contributing/#security-issues","title":"Security issues","text":"<p>If you find a security issue or vulnerability, please do not open a public issue. Instead, use the dedicated vulnerability reporting page.</p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Pull requests are welcome! Simply fork the GitHub repository and create a new branch for your changes. When you are ready, open a pull request to the <code>main</code> branch.</p> <p>If you are working on a larger feature or a significant change, it is recommended to open an issue first to discuss the idea.</p>"},{"location":"contributing/#formatting-your-code","title":"Formatting your code","text":""},{"location":"contributing/#java","title":"Java","text":"<p>We use prettier and JHipster's <code>prettier-plugin-java</code> to format our Java code. You can run the formatter with the following command:</p> <pre><code>npm install\nnpm run format:fix\n</code></pre> <p>The pull requests are expected to be formatted before being submitted. For IntellIJ users, you can set up the formatter to run automatically on save. To do this:</p> <ul> <li>Open Settings -&gt; Languages &amp; Frameworks -&gt; JavaScript -&gt; Prettier<ul> <li>Select <code>Manual Prettier configuration</code></li> <li>Select <code>node_modules/prettier</code> from project directory for <code>Prettier Package</code></li> <li>Check <code>Run on 'Reformat Code' action</code></li> <li>Check <code>Run on save</code></li> <li>Replace <code>Run for files</code> glob pattern with <code>**/*.{java}</code></li> </ul> </li> </ul>"},{"location":"contributing/#scala","title":"Scala","text":"<p>We use <code>scalafmt</code> and <code>scalafix</code> to format and lint Scala code. You can run both with <code>sbt fixAll</code>. Similarly to Java, pull requests are expected to pass the formatter and linter checks before being submitted. </p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Jelly-JVM uses the exact same documentation system as the main Jelly documentation. Further information on editing the documentation can be found in the Contributing to the Jelly documentation guide.</p>"},{"location":"contributing/#tests","title":"Tests","text":"<p>We expect all pull requests to include tests for new features or bug fixes \u2013 expected coverage is 90% or higher. Tests are written in Scala using ScalaTest. You can run the tests with the following command:</p> <pre><code>sbt test\n</code></pre> <p>Or, to test only one module (in this case, <code>core</code>):</p> <pre><code>sbt core/test\n</code></pre> <p>Some tests produce a lot of output on the console. You may want to silence it by setting the <code>JELLY_TEST_SILENCE_OUTPUT</code> environment variable to <code>true</code>. This is done for example in the CI pipeline.</p>"},{"location":"contributing/#releases","title":"Releases","text":"<p>See the dedicated page on making releases.</p>"},{"location":"contributing/#see-also","title":"See also","text":"<ul> <li>Licensing and citation</li> </ul>"},{"location":"contributing/code_of_conduct/","title":"Contributor Covenant Code of Conduct","text":"<p>This Code of Conduct is adapted from the Contributor Covenant, version 2.1, available at https://www.contributor-covenant.org/version/2/1/code_of_conduct.html.</p>"},{"location":"contributing/code_of_conduct/#our-pledge","title":"Our Pledge","text":"<p>We as members, contributors, and leaders pledge to make participation in our community a harassment-free experience for everyone, regardless of age, body size, visible or invisible disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, caste, color, religion, or sexual identity and orientation.</p> <p>We pledge to act and interact in ways that contribute to an open, welcoming, diverse, inclusive, and healthy community.</p>"},{"location":"contributing/code_of_conduct/#our-standards","title":"Our Standards","text":"<p>Examples of behavior that contributes to a positive environment for our community include:</p> <ul> <li>Demonstrating empathy and kindness toward other people</li> <li>Being respectful of differing opinions, viewpoints, and experiences</li> <li>Giving and gracefully accepting constructive feedback</li> <li>Accepting responsibility and apologizing to those affected by our mistakes,   and learning from the experience</li> <li>Focusing on what is best not just for us as individuals, but for the overall   community</li> </ul> <p>Examples of unacceptable behavior include:</p> <ul> <li>The use of sexualized language or imagery, and sexual attention or advances of   any kind</li> <li>Trolling, insulting or derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information, such as a physical or email address,   without their explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a   professional setting</li> </ul>"},{"location":"contributing/code_of_conduct/#enforcement-responsibilities","title":"Enforcement Responsibilities","text":"<p>Community leaders are responsible for clarifying and enforcing our standards of acceptable behavior and will take appropriate and fair corrective action in response to any behavior that they deem inappropriate, threatening, offensive, or harmful.</p> <p>Community leaders have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, and will communicate reasons for moderation decisions when appropriate.</p>"},{"location":"contributing/code_of_conduct/#scope","title":"Scope","text":"<p>This Code of Conduct applies within all community spaces, and also applies when an individual is officially representing the community in public spaces. Examples of representing our community include using an official email address, posting via an official social media account, or acting as an appointed representative at an online or offline event.</p>"},{"location":"contributing/code_of_conduct/#enforcement","title":"Enforcement","text":"<p>Instances of abusive, harassing, or otherwise unacceptable behavior may be reported to the community leaders responsible for enforcement at community@neverblink.eu. All complaints will be reviewed and investigated promptly and fairly.</p> <p>All community leaders are obligated to respect the privacy and security of the reporter of any incident.</p>"},{"location":"contributing/code_of_conduct/#enforcement-guidelines","title":"Enforcement Guidelines","text":"<p>Community leaders will follow these Community Impact Guidelines in determining the consequences for any action they deem in violation of this Code of Conduct:</p>"},{"location":"contributing/code_of_conduct/#1-correction","title":"1. Correction","text":"<p>Community Impact: Use of inappropriate language or other behavior deemed unprofessional or unwelcome in the community.</p> <p>Consequence: A private, written warning from community leaders, providing clarity around the nature of the violation and an explanation of why the behavior was inappropriate. A public apology may be requested.</p>"},{"location":"contributing/code_of_conduct/#2-warning","title":"2. Warning","text":"<p>Community Impact: A violation through a single incident or series of actions.</p> <p>Consequence: A warning with consequences for continued behavior. No interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, for a specified period of time. This includes avoiding interactions in community spaces as well as external channels like social media. Violating these terms may lead to a temporary or permanent ban.</p>"},{"location":"contributing/code_of_conduct/#3-temporary-ban","title":"3. Temporary Ban","text":"<p>Community Impact: A serious violation of community standards, including sustained inappropriate behavior.</p> <p>Consequence: A temporary ban from any sort of interaction or public communication with the community for a specified period of time. No public or private interaction with the people involved, including unsolicited interaction with those enforcing the Code of Conduct, is allowed during this period. Violating these terms may lead to a permanent ban.</p>"},{"location":"contributing/code_of_conduct/#4-permanent-ban","title":"4. Permanent Ban","text":"<p>Community Impact: Demonstrating a pattern of violation of community standards, including sustained inappropriate behavior, harassment of an individual, or aggression toward or disparagement of classes of individuals.</p> <p>Consequence: A permanent ban from any sort of public interaction within the community.</p>"},{"location":"contributing/code_of_conduct/#attribution","title":"Attribution","text":"<p>Community Impact Guidelines were inspired by Mozilla's code of conduct enforcement ladder.</p> <p>For answers to common questions about this code of conduct, see the FAQ at https://www.contributor-covenant.org/faq. Translations are available at https://www.contributor-covenant.org/translations.</p>"},{"location":"contributing/releases/","title":"Releasing Jelly-JVM","text":""},{"location":"contributing/releases/#full-versioned-releases","title":"Full (versioned) releases","text":"<p>Full (versioned) releases are created manually and follow the Semantic Versioning scheme for binary compatibility.</p> <p>To create a new tagged release (example for version 1.2.3): <pre><code>$ git checkout main\n$ git pull\n$ git tag v1.2.3\n$ git push origin v1.2.3\n</code></pre></p> <p>The rest (packaging and release creation) will be handled automatically by the CI. The release will be pushed to Maven Central.</p>"},{"location":"contributing/releases/#snapshot-releases","title":"Snapshot releases","text":"<p>Snapshot releases are triggered automatically by commits in the <code>main</code> branch. Snapshots are pushed to the Sonatype snapshot repository.</p>"},{"location":"user/compatibility/","title":"Compatibility policy","text":"<p>Jelly-JVM follows Semantic Versioning 2.0.0, with MAJOR.MINOR.PATCH releases. Please see the compatibility table on the main page for the current compatibility information. The documentation is versioned to match each Jelly-JVM MAJOR.MINOR version.</p>"},{"location":"user/compatibility/#jvm-and-scala","title":"JVM and Scala","text":"<p>The current version of Jelly-JVM is compatible with Java 17 and newer. Java 17, 21, and 24 are tested in CI and are guaranteed to work. We recommend using a recent release of GraalVM to get the best performance. If you need Java 11 support, you should use Jelly-JVM 1.0.x.</p> <p>The current version of Jelly-JVM has some modules (currently <code>jelly-pekko-stream</code>) built with Scala 3 LTS releases and support only Scala 3. </p> <p>Jelly-JVM 2.x.x was written entirely in Scala 3, using Scala LTS releases.</p>"},{"location":"user/compatibility/#rdf-libraries","title":"RDF libraries","text":"<p>Major-version upgrades of RDF4J and Apache Jena (e.g., updating from 4.0.x to 5.0.x) are done in Jelly-JVM MINOR releases. Jelly-JVM generally does not use any complex features of these libraries, so it should work with multiple versions without any problems.</p> <p>If you do encounter any compatibility issues, please report them on the issue tracker.</p>"},{"location":"user/compatibility/#neo4j","title":"Neo4j","text":"<p>Jelly-JVM provides a plugin for integrating with the Neo4j graph database via the neosemantics plugin. You must use the same version of neosemantics as your Neo4j installation \u2013 note that the releases of neosemantics are usually delayed in relation to Neo4j itself.</p>"},{"location":"user/compatibility/#internal-vs-external-apis","title":"Internal vs external APIs","text":"<p>Generally, all public classes and methods in Jelly-JVM are considered part of the public API. However, there are some exceptions.</p> <p>Auto-generated classes in the <code>jelly-core</code> module, <code>eu.neverblink.jelly.core.proto.v1</code> package are not considered part of the public API, although we will avoid any incompatibilities where possible. These classes may change between MINOR releases.</p>"},{"location":"user/compatibility/#backward-and-forward-protocol-compatibility","title":"Backward and forward protocol compatibility","text":"<p>Jelly-JVM follows the Jelly protocol's backward compatibility policy. This means that Jelly-JVM can read data serialized with older versions of Jelly. Backward compatibility is tested in CI \u2013 the code is in BackCompatSpec.scala.</p> <p>Forward compatibility is provided only in a very limited manner in Jelly-JVM. The parser is guaranteed to only parse the stream options header and reject the rest of the stream, if the used protocol version is not supported. You may choose to disable this check and try to parse the rest of the data anyway, but this is most certainly NOT recommended and may lead to unexpected results. In general, Jelly-JVM will ignore any unknown fields in the stream, but any other changes in the protocol may lead to really \"funny\" errors. Forward compatibility is tested in CI \u2013 the code is in ForwardCompatSpec.scala.</p>"},{"location":"user/compatibility/#see-also","title":"See also","text":"<ul> <li>Release notes on GitHub</li> <li>Making Jelly-JVM releases</li> <li>Contributing to Jelly-JVM</li> </ul>"},{"location":"user/grpc/","title":"User guide \u2013 gRPC","text":"<p>This guide explains the functionalities of the <code>jelly-pekko-grpc</code> module, which implements a gRPC client and server for the Jelly gRPC streaming protocol.</p> <p>Prerequisites</p> <p>If you are unfamiliar with gRPC, we recommend you first read some introductory material on the gRPC website or in the Apache Pekko gRPC documentation.</p> <p>The <code>jelly-pekko-grpc</code> module builds on the functionalities of <code>jelly-pekko-stream</code>, so we recommend you first read the Apache Pekko reactive streaming guide.</p> <p>You may also want to first skim the Jelly gRPC streaming protocol specification to understand the protocol's structure.</p> <p>As with the <code>jelly-pekko-stream</code> module, you can use <code>jelly-pekko-grpc</code> with any RDF library that has a Jelly integration, such as Apache Jena (using <code>jelly-jena</code>) or RDF4J (using <code>jelly-rdf4j</code>). The gRPC API is generic and identical across all libraries.</p>"},{"location":"user/grpc/#making-a-grpc-server-and-client","title":"Making a gRPC server and client","text":"<p><code>jelly-pekko-grpc</code> builds on the Apache Pekko gRPC library. Jelly-JVM provides boilerplate code for setting up a gRPC server and client that can send and receive Jelly streams, as shown in the example below:</p> Example: PekkoGrpc.scala (click to expand) <p> Source code on GitHub</p> PekkoGrpc.scala<pre><code>package eu.neverblink.jelly.examples\n\nimport com.typesafe.config.ConfigFactory\nimport eu.neverblink.jelly.convert.jena.{JenaAdapters, JenaConverterFactory}\nimport eu.neverblink.jelly.core.JellyOptions\nimport eu.neverblink.jelly.core.proto.v1.*\nimport eu.neverblink.jelly.grpc.{RdfStreamServer, RdfStreamService, RdfStreamServiceClient}\nimport eu.neverblink.jelly.pekko.stream.{\n  ByteSizeLimiter,\n  DecoderFlow,\n  EncoderFlow,\n  RdfSource,\n  StreamRowCountLimiter,\n}\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.NotUsed\nimport org.apache.pekko.actor.typed.ActorSystem\nimport org.apache.pekko.actor.typed.javadsl.Behaviors\nimport org.apache.pekko.grpc.{GrpcClientSettings, GrpcServiceException}\nimport org.apache.pekko.stream.scaladsl.*\n\nimport java.io.File\nimport scala.concurrent.duration.*\nimport scala.concurrent.{Await, ExecutionContext, Future}\nimport scala.util.{Failure, Success}\nimport com.typesafe.config.Config\nimport org.apache.jena.query.Dataset\n\n/** Example of using Jelly's gRPC client and server to send Jelly streams over the network. This\n  * uses the Apache Pekko gRPC library. Its documentation can be found at:\n  * https://pekko.apache.org/docs/pekko-grpc/current/index.html\n  *\n  * See also examples named `PekkoStreams*` for instructions on encoding and decoding RDF streams\n  * with Jelly.\n  *\n  * In this example we are using Apache Jena as the RDF library (note the import:\n  * `import eu.ostrzyciel.jelly.convert.jena.given`). The same can be achieved with RDF4J just by\n  * importing a different module.\n  */\nobject PekkoGrpc extends shared.ScalaExample:\n\n  // We will need a JenaConverterFactory to convert between Jelly and Jena\n  given JenaConverterFactory = JenaConverterFactory.getInstance()\n\n  // We need to import the Jena adapters to turn Model/Dataset into a stream of statements\n  given JenaAdapters.DATASET_ADAPTER.type = JenaAdapters.DATASET_ADAPTER\n  given JenaAdapters.MODEL_ADAPTER.type = JenaAdapters.MODEL_ADAPTER\n\n  // Create a config for Pekko gRPC.\n  // We can use the same config for the client and the server, as we are communicating on localhost.\n  // This would usually be loaded from a configuration file (e.g., application.conf).\n  // More details: https://github.com/lightbend/config\n  val config: Config = ConfigFactory.parseString(\n    \"\"\"\n        |pekko.http.server.preview.enable-http2 = on\n        |pekko.grpc.client.jelly.host = 127.0.0.1\n        |pekko.grpc.client.jelly.port = 8088\n        |pekko.grpc.client.jelly.enable-gzip = true\n        |pekko.grpc.client.jelly.use-tls = false\n        |pekko.grpc.client.jelly.backend = netty\n        |\"\"\".stripMargin,\n  )\n    .withFallback(ConfigFactory.defaultApplication())\n\n  // We will need two Pekko actor systems to run the streams \u2013 one for the server and one for the client\n  val serverActorSystem: ActorSystem[_] = ActorSystem(Behaviors.empty, \"ServerSystem\")\n  val clientActorSystem: ActorSystem[_] = ActorSystem(Behaviors.empty, \"ClientSystem\", config)\n\n  // Our mock dataset that we will send around in the streams\n  val dataset: Dataset =\n    RDFDataMgr.loadDataset(File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString)\n\n  /** Main method that starts the server and the client.\n    */\n  def main(args: Array[String]): Unit =\n    given system: ActorSystem[_] = serverActorSystem\n    given ExecutionContext = system.executionContext\n\n    // Start the server\n    val exampleService = ExampleJellyService()\n    RdfStreamServer(\n      RdfStreamServer.Options.fromConfig(config.getConfig(\"pekko.grpc.client.jelly\")),\n      exampleService,\n    ).run() onComplete {\n      case Success(binding) =&gt;\n        // If the server started successfully, start the client\n        println(s\"[SERVER] Bound to ${binding.localAddress}\")\n        runClient()\n      case Failure(exception) =&gt;\n        // Otherwise, print the error and terminate the actor system\n        println(s\"[SERVER] Failed to bind: $exception\")\n        system.terminate()\n    }\n\n  /** The client part of the example.\n    */\n  private def runClient(): Unit =\n    given system: ActorSystem[_] = clientActorSystem\n    given ExecutionContext = system.executionContext\n\n    // Create a gRPC client\n    val client = RdfStreamServiceClient(GrpcClientSettings.fromConfig(\"jelly\"))\n\n    // First, let's try to publish some data to the server\n    val frameSource = RdfSource.builder().datasetAsQuads(dataset).source\n      // Encode the dataset as a stream of QUADS\n      .via(\n        EncoderFlow.builder\n          .withLimiter(ByteSizeLimiter(500))\n          .flatQuads(JellyOptions.SMALL_STRICT.clone.setStreamName(\"weather\"))\n          .flow,\n      )\n\n    println(\"[CLIENT] Publishing data to the server...\")\n    val publishFuture = client.publishRdf(frameSource) map { response =&gt;\n      println(\"[CLIENT] Received acknowledgment\")\n    } recover { case e =&gt;\n      println(s\"[CLIENT] Failed to publish data: $e\")\n    }\n    // Wait for the publish to complete\n    Await.ready(publishFuture, 10.seconds)\n\n    // Now, let's try to subscribe to some data from the server in the QUADS format\n    println(\"\\n\\n[CLIENT] Subscribing to QUADS data from the server...\")\n    val quadsFuture = client\n      .subscribeRdf(\n        RdfStreamSubscribe.newInstance\n          .setTopic(\"weather\")\n          .setRequestedOptions(\n            JellyOptions.SMALL_STRICT.clone.setPhysicalType(PhysicalStreamType.QUADS),\n          ),\n      )\n      .via(DecoderFlow.decodeQuads.asFlatQuadStreamStrict)\n      .runFold(0L)((acc, _) =&gt; acc + 1)\n      // Process the result of the stream (Future[Long])\n      .map { counter =&gt;\n        println(s\"[CLIENT] Received $counter quads.\")\n      } recover { case e =&gt;\n      println(s\"[CLIENT] Failed to receive quads: $e\")\n    }\n    Await.ready(quadsFuture, 10.seconds)\n\n    // Let's try the same, with a GRAPHS stream\n    println(\"\\n\\n[CLIENT] Subscribing to GRAPHS data from the server...\")\n    val graphsFuture = client\n      .subscribeRdf(\n        RdfStreamSubscribe.newInstance\n          .setTopic(\"weather\")\n          .setRequestedOptions(\n            JellyOptions.SMALL_STRICT.clone.setPhysicalType(PhysicalStreamType.GRAPHS),\n          ),\n      )\n      // Decode the response and transform it into a stream of quads\n      .via(DecoderFlow.decodeGraphs.asDatasetStreamOfQuads)\n      .mapConcat(identity)\n      .runFold(0L)((acc, _) =&gt; acc + 1)\n      // Process the result of the stream (Future[Long])\n      .map { counter =&gt;\n        println(s\"[CLIENT] Received $counter quads.\")\n      } recover { case e =&gt;\n      println(s\"[CLIENT] Failed to receive data: $e\")\n    }\n    Await.ready(graphsFuture, 10.seconds)\n\n    // Finally, let's try to subscribe to a stream that the server does not support\n    // We will request TRIPLES, but the server only supports QUADS and GRAPHS.\n    println(\"\\n\\n[CLIENT] Subscribing to TRIPLES data from the server...\")\n    val triplesFuture = client\n      .subscribeRdf(\n        RdfStreamSubscribe.newInstance\n          .setTopic(\"weather\")\n          .setRequestedOptions(\n            JellyOptions.SMALL_STRICT.clone.setPhysicalType(PhysicalStreamType.TRIPLES),\n          ),\n      )\n      .via(DecoderFlow.decodeTriples.asFlatTripleStream)\n      .runFold(0L)((acc, _) =&gt; acc + 1)\n      .map { counter =&gt;\n        println(s\"[CLIENT] Received $counter triples.\")\n      } recover { case e =&gt;\n      println(s\"[CLIENT] Failed to receive triples: $e\")\n    }\n    Await.result(triplesFuture, 10.seconds)\n\n    println(\"\\n\\n[CLIENT] Terminating...\")\n    system.terminate()\n    println(\"[SERVER] Terminating...\")\n    serverActorSystem.terminate()\n\n  /** Example implementation of RdfStreamService to act as the server.\n    *\n    * You will also need to implement this trait in your own service. It defines the logic with\n    * which the server will handle incoming streams and subscriptions.\n    */\n  class ExampleJellyService(using system: ActorSystem[_]) extends RdfStreamService:\n    given ExecutionContext = system.executionContext\n\n    /** Handler for clients publishing RDF streams to the server.\n      *\n      * We receive a stream of RdfStreamFrames and must respond with an acknowledgment (or an\n      * error).\n      */\n    override def publishRdf(in: Source[RdfStreamFrame, NotUsed]): Future[RdfStreamReceived] =\n      // Decode the incoming stream and count the number of RDF statements in it\n      in.via(DecoderFlow.decodeAny.asFlatStream)\n        .runFold(0L)((acc, _) =&gt; acc + 1)\n        .map(counter =&gt; {\n          println(s\"[SERVER] Received ${counter} RDF statements. Sending acknowledgment.\")\n          // Send an acknowledgment back to the client\n          RdfStreamReceived.EMPTY\n        })\n\n    /** Handler for clients subscribing to RDF streams from the server.\n      *\n      * We receive a subscription request and must respond with a stream of RdfStreamFrames or an\n      * error.\n      */\n    override def subscribeRdf(in: RdfStreamSubscribe): Source[RdfStreamFrame, NotUsed] =\n      println(s\"[SERVER] Received subscription request for topic ${in.getTopic}.\")\n      // First, check the requested physical stream type\n      val streamType = Option(in.getRequestedOptions) match\n        case Some(options) =&gt;\n          println(s\"[SERVER] Requested physical stream type: ${options.getPhysicalType}.\")\n          options.getPhysicalType\n        case None =&gt;\n          println(\"[SERVER] No requested stream options.\")\n          PhysicalStreamType.UNSPECIFIED\n\n      // Get the stream options requested by the client or the default options if none were provided\n      val options = Option(in.getRequestedOptions).getOrElse(JellyOptions.SMALL_STRICT)\n        .clone\n        .setStreamName(in.getTopic)\n      // Check if the requested options are supported\n      // !!! THIS IS IMPORTANT !!!\n      // If you don't check if the requested options are supported, you may be vulnerable to\n      // denial-of-service attacks. For example, a client could request a very large lookup table\n      // that would consume a lot of memory on the server.\n      try JellyOptions.checkCompatibility(options, JellyOptions.DEFAULT_SUPPORTED_OPTIONS)\n      catch\n        case e: IllegalArgumentException =&gt;\n          // If the requested options are not supported, return an error\n          return Source.failed(\n            new GrpcServiceException(\n              io.grpc.Status.INVALID_ARGUMENT.withDescription(e.getMessage),\n            ),\n          )\n\n      streamType match\n        // This server implementation only supports QUADS and GRAPHS streams... and in both cases\n        // it will always the same dataset.\n        // You can of course implement more complex logic here, e.g., to stream different data based on the topic.\n        case PhysicalStreamType.QUADS =&gt;\n          RdfSource.builder().datasetAsQuads(dataset).source\n            .via(\n              EncoderFlow.builder\n                .withLimiter(ByteSizeLimiter(16_000))\n                .flatQuads(options)\n                .flow,\n            )\n        case PhysicalStreamType.GRAPHS =&gt;\n          RdfSource.builder().datasetAsGraphs(dataset).source\n            .via(\n              EncoderFlow.builder\n                .withLimiter(StreamRowCountLimiter(30))\n                .namedGraphs(options)\n                .flow,\n            )\n        // PhysicalStreamType.TRIPLES is not supported here \u2013 the server will throw a gRPC error\n        // if the client requests it.\n        // This is an example of how to properly handle unsupported stream options requested by the client.\n        // The library is able to automatically convert the error into a gRPC status and send it back to the client.\n        case _ =&gt;\n          Source.failed(\n            new GrpcServiceException(\n              io.grpc.Status.INVALID_ARGUMENT.withDescription(\"Unsupported physical stream type\"),\n            ),\n          )\n</code></pre> <p>The classes provided in <code>jelly-pekko-grpc</code> should cover most cases, but they only serve as the boilerplate. You must yourself define the logic for handling the incoming and outgoing streams, as shown in the example above.</p> <p>Of course, you can also implement the server or the client from scratch, if you want to.</p>"},{"location":"user/grpc/#see-also","title":"See also","text":"<ul> <li>Reactive streaming with Jelly-JVM and Apache Pekko</li> <li>Useful utilities<ul> <li>Using Typesafe config to configure Jelly</li> </ul> </li> </ul>"},{"location":"user/implementing/","title":"Developer guide \u2013 implementing conversions for other libraries","text":""},{"location":"user/implementing/#basics-of-implementing-conversions","title":"Basics of implementing conversions","text":"<p>Currently converters for the two most popular RDF JVM libraries are implemented \u2013 RDF4J and Jena. But it is possible to implement your own converters and adapt the Jelly serialization code to any RDF library with little effort.</p> <p>To do this, you will need to implement three interfaces from the <code>jelly-core</code> module: <code>ProtoEncoderConverter</code>, <code>ProtoDecoderConverter</code>, and <code>JellyConverterFactory</code>.</p> <ul> <li> <p>ProtoEncoderConverter (serialization)</p> <ul> <li><code>nodeToProto</code> and <code>graphToProto</code> should translate into Jelly's representation all possible variations of RDF terms in the SPO and G positions, respectively.</li> <li>Example implementation for Jena: JenaEncoderConverter</li> <li>You can skip implementing this interface if you don't need serialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads.</li> </ul> </li> <li> <p>ProtoDecoderConverter (deserialization)</p> <ul> <li>The <code>make*</code> methods should construct new RDF terms and statements.</li> <li>Example implementation for Jena: JenaDecoderConverter</li> <li>You can skip implementing this interface if you don't need deserialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-star.</li> </ul> </li> <li> <p>JellyConverterFactory \u2013 wrapper that allows other modules to use your converter.</p> <ul> <li>The methods should just return new instances (or singletons, if appropriate for your use case) of your <code>ProtoEncoderConverter</code> and <code>ProtoDecoderConverter</code> implementations.</li> <li>Example for Jena: JenaConverterFactory</li> </ul> </li> </ul>"},{"location":"user/implementing/#supporting-reactive-streams-with-apache-pekko-streams","title":"Supporting reactive streams with Apache Pekko Streams","text":"<p>If you want to enable reactive stream support for your library, it will be useful to implement the following utility interfaces from <code>jelly-core</code>: <code>QuadExtractor</code> and <code>QuadMaker</code> for Quads and <code>TripleExtractor</code> and <code>TripleMaker</code> for Triples. </p> <p>These interfaces are used to extract triples/quads from the input stream and create them from the output stream. In <code>jelly-pekko-stream</code> module we expect your <code>ProtoDecoderConverter</code> to implement <code>TripleMaker</code> and <code>QuadMaker</code> interfaces, and your <code>ProtoEncoderConverter</code> to implement <code>TripleExtractor</code> and <code>QuadExtractor</code> interfaces. </p> <p>The implementation of these interfaces is very simple and should be similar to the following examples:</p> <ul> <li>JenaEncoderConverter which implements <code>TripleExtractor&lt;Node, Triple&gt;</code> and <code>QuadExtractor&lt;Node, Quad&gt;</code> interfaces.</li> <li>JenaDecoderConverter which implements <code>TripleMaker&lt;Node, Triple&gt;</code> and <code>QuadMaker&lt;Node, Quad&gt;</code> interfaces.</li> </ul> <p>Additionally, to support <code>RdfSourceBuilder</code> Dataset/Graph to Triples, Quads and Graphs conversions, you may find it useful to create implementations of <code>DatasetAdapter</code> and <code>GraphAdapter</code> utilis interfaces located in <code>jelly-core</code>. A good example of implementing such interfaces can be found in the <code>jena</code> module: JenaAdapters.</p>"},{"location":"user/jena-cli/","title":"Apache Jena CLI tools","text":"<p>Jelly-JVM fully supports Apache Jena's command-line interface (CLI) utilities.</p>"},{"location":"user/jena-cli/#parsing","title":"Parsing","text":"<p>Jena will automatically detect Jelly files based on their extension (<code>.jelly</code>, <code>.jelly.gz</code>) and parse them. You can also manually set the <code>--syntax</code> option to <code>jelly</code>.</p>"},{"location":"user/jena-cli/#writing","title":"Writing","text":"<p>You can use Jelly as an output format for Jena's CLI utilities by specifying the <code>--output</code> or <code>--stream</code> options with the <code>jelly</code> format. We recommend using the <code>--stream</code> option for better performance. </p> <p>Example: converting a Turtle file to Jelly</p> <pre><code>./riot --stream=jelly data.ttl &gt; data.jelly\n</code></pre> <p>By default Jena will use the \"small, all features\" Jelly preset (name table: 128 entries, prefix table: 16, datatype table: 16, RDF-star enabled, generalized RDF enabled). There are a few reasons why you might want to change these serialization options:</p> <ul> <li>Performance \u2013 for larger files, the small preset does not offer the best performance or compression ratio. It's better to use larger lookup tables.</li> <li>Compatibility \u2013 if your data does not include RDF-star or generalized RDF, you can mark these features as disabled. Later, parsers will know accurately what to expect in your data.</li> </ul> <p>The following presets are available:</p> <ul> <li>Small: 128 name table entries, 16 prefix table entries, 16 datatype table entries<ul> <li><code>SMALL_STRICT</code> \u2013 RDF-star and generalized RDF disabled</li> <li><code>SMALL_GENERALIZED</code> \u2013 RDF-star disabled, generalized RDF enabled</li> <li><code>SMALL_RDF_STAR</code> \u2013 RDF-star enabled, generalized RDF disabled</li> <li><code>SMALL_ALL_FEATURES</code> \u2013 RDF-star and generalized RDF enabled (default)</li> </ul> </li> <li>Big: 4000 name table entries, 150 prefix table entries, 32 datatype table entries (recommended for larger files)<ul> <li><code>BIG_STRICT</code></li> <li><code>BIG_GENERALIZED</code></li> <li><code>BIG_RDF_STAR</code></li> <li><code>BIG_ALL_FEATURES</code></li> </ul> </li> </ul> <p>To use one of these presets, use the <code>--set</code> CLI option with the <code>https://neverblink.eu/jelly/riot/symbols#preset</code> symbol:</p> <p>Example: converting a Turtle file to Jelly with a big preset (strict)</p> <pre><code>./riot --stream=jelly \\\n    --set=\"https://neverblink.eu/jelly/riot/symbols#preset=BIG_STRICT\" \\\n    data.ttl &gt; data.jelly\n</code></pre> <p>Example: dumping a TDB2 database to Jelly with a big preset (all features)</p> <pre><code>./tdb2.tdbdump --tdb=path/to/assembler.ttl \\\n    --set=\"https://neverblink.eu/jelly/riot/symbols#preset=BIG_ALL_FEATURES\" \\\n    --stream=jelly &gt; mydb.jelly\n</code></pre>"},{"location":"user/jena-cli/#see-also","title":"See also","text":"<ul> <li>Installing Jelly with Jena</li> <li>Jena CLI documentation</li> </ul>"},{"location":"user/jena/","title":"Apache Jena integration","text":"<p>This guide explains the functionalities of the <code>jelly-jena</code> module, which provides Jelly support for Apache Jena.</p> <p>If you just want to add Jelly format support to Apache Jena / Apache Jena Fuseki, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/jena/#base-facilities","title":"Base facilities","text":"<p><code>jelly-jena</code> implements the <code>eu.neverblink.jelly.core.JellyConverterFactory</code>  interface in <code>eu.neverblink.jelly.convert.jena.JenaConverterFactory</code> . This factory allows you to build encoders and decoders that convert between Jelly's <code>RdfStreamFrame</code>s and Apache Jena's <code>Triple</code> and <code>Quad</code> objects. The <code>eu.neverblink.jelly.core.proto.v1.RdfStreamFrame</code>  class is an object representation of Jelly's binary format.</p> <p>The module also implements the <code>eu.neverblink.jelly.core.utils.DatasetAdapter</code>  and <code>eu.neverblink.jelly.core.utils.GraphAdapter</code>  interfaces in <code>eu.neverblink.jelly.convert.jena.JenaAdapters</code> . These adapters provide methods for Apache Jena's <code>Model</code>, <code>Dataset</code>, <code>Graph</code>, and <code>DatasetGraph</code> classes to convert them into an iterable of triples (<code>GRAPH_ADAPTER.triples</code>), quads (<code>DATASET_ADAPTER.quads</code>, <code>MODEL_ADAPTER.quads</code>), or named graphs (<code>DATASET_ADAPTER.graphs</code>, <code>MODEL_ADAPTER.graphs</code>). This is useful when working with Jelly on a lower level or when using the <code>jelly-pekko-stream</code> module.</p>"},{"location":"user/jena/#serialization-and-deserialization-with-riot","title":"Serialization and deserialization with RIOT","text":"<p><code>jelly-jena</code> implements an RDF writer and reader for Apache Jena's RIOT library. This means you can use Jelly just like, for example, Turtle or RDF/XML. See the example below:</p> Example: JenaRiot.java (click to expand) <p> Source code on GitHub</p> JenaRiot.java<pre><code>package eu.neverblink.jelly.examples;\n\nimport eu.neverblink.jelly.convert.jena.riot.*;\nimport eu.neverblink.jelly.core.*;\nimport eu.neverblink.jelly.core.proto.v1.RdfStreamOptions;\nimport eu.neverblink.jelly.examples.shared.Example;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.net.URI;\nimport org.apache.jena.query.Dataset;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.rdf.model.ModelFactory;\nimport org.apache.jena.riot.*;\nimport org.apache.jena.sparql.util.Context;\n\n/**\n * Example of using Jelly's integration with Apache Jena's RIOT library for\n * writing and reading RDF graphs and datasets to/from disk.\n * &lt;p&gt;\n * See also: &lt;a href=\"https://jena.apache.org/documentation/io/\"&gt;Jena Documentation&lt;/a&gt;\n */\npublic class JenaRiot implements Example {\n\n    public static void main(String[] args) throws Exception {\n        new JenaRiot().run(args);\n    }\n\n    @Override\n    public void run(String[] args) throws Exception {\n        // Load the RDF graph from an N-Triples file\n        URI fileUri = new File(getClass().getResource(\"/weather.nt\").toURI()).toURI();\n        Model model = RDFDataMgr.loadModel(fileUri.toString());\n\n        // Print the size of the model\n        System.out.println(\"Loaded an RDF graph from N-Triples with size: \" + model.size());\n\n        // Write the model to a Jelly file using try-with-resources\n        try (FileOutputStream out = new FileOutputStream(\"weather.jelly\")) {\n            // Note: by default this will use the JellyFormat.JELLY_SMALL_STRICT format variant\n            RDFDataMgr.write(out, model, JellyLanguage.JELLY);\n            System.out.println(\"Saved the model to a Jelly file\");\n        }\n\n        // Load the RDF graph from a Jelly file\n        Model model2 = RDFDataMgr.loadModel(\"weather.jelly\", JellyLanguage.JELLY);\n\n        // Print the size of the model\n        System.out.println(\"Loaded an RDF graph from Jelly with size: \" + model2.size());\n\n        // ---------------------------------\n        System.out.println(\"\\n\");\n\n        // Try the same with an RDF dataset and some different settings\n        URI trigFileUri = new File(getClass().getResource(\"/weather-graphs.trig\").toURI()).toURI();\n        Dataset dataset = RDFDataMgr.loadDataset(trigFileUri.toString());\n        System.out.println(\n            \"Loaded an RDF dataset from a Trig file with \" +\n            dataset.asDatasetGraph().size() +\n            \" named graphs and \" +\n            dataset.asDatasetGraph().stream().count() +\n            \" quads\"\n        );\n\n        try (FileOutputStream out = new FileOutputStream(\"weather-quads.jelly\")) {\n            // Write the dataset to a Jelly file, using the \"BIG\" settings\n            // (better compression for big files, more memory usage)\n            RDFDataMgr.write(out, dataset, JellyFormat.JELLY_BIG_STRICT);\n            System.out.println(\"Saved the dataset to a Jelly file\");\n        }\n\n        // Load the RDF dataset from a Jelly file\n        Dataset dataset2 = RDFDataMgr.loadDataset(\"weather-quads.jelly\", JellyLanguage.JELLY);\n        System.out.println(\n            \"Loaded an RDF dataset from Jelly with \" +\n            dataset2.asDatasetGraph().size() +\n            \" named graphs and \" +\n            dataset2.asDatasetGraph().stream().count() +\n            \" quads\"\n        );\n\n        // ---------------------------------\n        System.out.println(\"\\n\");\n\n        // Custom Jelly format \u2013 change any settings you like\n        RDFFormat customFormat = new RDFFormat(\n            JellyLanguage.JELLY,\n            JellyFormatVariant.builder()\n                .options(\n                    JellyOptions.SMALL_STRICT.clone()\n                        .setMaxPrefixTableSize(0) // disable the prefix table\n                        .setStreamName(\"My weather stream\") // add metadata to the stream\n                )\n                .frameSize(16) // make RdfStreamFrames with 16 rows each\n                .build()\n        );\n\n        // Jena requires us to register the custom format \u2013 once for graphs and once for datasets,\n        // as Jelly supports both.\n        RDFWriterRegistry.register(customFormat, new JellyGraphWriterFactory());\n        RDFWriterRegistry.register(customFormat, new JellyDatasetWriterFactory());\n\n        try (FileOutputStream out = new FileOutputStream(\"weather-quads-custom.jelly\")) {\n            // Write the dataset to a Jelly file using the custom format\n            RDFDataMgr.write(out, dataset, customFormat);\n            System.out.println(\"Saved the dataset to a Jelly file with custom settings\");\n        }\n\n        // Load the RDF dataset from a Jelly file with the custom format\n        Dataset dataset3 = RDFDataMgr.loadDataset(\"weather-quads-custom.jelly\", JellyLanguage.JELLY);\n        System.out.println(\n            \"Loaded an RDF dataset from Jelly with custom settings with \" +\n            dataset3.asDatasetGraph().size() +\n            \" named graphs and \" +\n            dataset3.asDatasetGraph().stream().count() +\n            \" quads\"\n        );\n\n        // ---------------------------------\n        System.out.println(\"\\n\");\n\n        // By default, the parser has limits on for example the maximum size of the lookup tables.\n        // The default supported options are JellyOptions.defaultSupportedOptions.\n        // You can change these limits by creating your own options object.\n        RdfStreamOptions customOptions = JellyOptions.DEFAULT_SUPPORTED_OPTIONS.clone().setMaxNameTableSize(50); // set the maximum size of the name table to 50\n\n        // Create a Context object with the custom options\n        Context parserContext = RIOT.getContext().copy().set(JellyLanguage.SYMBOL_SUPPORTED_OPTIONS, customOptions);\n\n        System.out.println(\"Trying to load the model with custom supported options...\");\n        Model model3 = ModelFactory.createDefaultModel();\n        try {\n            // The loading operation should fail because our allowed max name table size is too low\n            RDFParser.create()\n                .source(\"weather.jelly\")\n                .lang(JellyLanguage.JELLY)\n                // Set the context object with the custom options\n                .context(parserContext)\n                .parse(model3);\n        } catch (RdfProtoDeserializationError e) {\n            // The stream uses a name table size of 128, which is larger than the maximum supported size of 50.\n            // To read this stream, set maxNameTableSize to at least 128 in the supportedOptions for this decoder.\n            System.out.println(\"Failed to load the model with custom options: \" + e.getMessage());\n        }\n    }\n}\n</code></pre> <p>Usage notes:</p> <ul> <li><code>eu.neverblink.jelly.core.JellyOptions</code>  provides a few common presets for Jelly serialization options construct a <code>JellyFormatVariant</code>, as shown in the example above. You can also further customize the serialization options (e.g., dictionary size).</li> <li>The RIOT writer (serializer) integration implements only the delimited variant of Jelly. It is used for writing Jelly to files on disk or sockets. Because of this, you cannot use RIOT to write non-delimited Jelly data (e.g., a single message to a Kafka stream). For this, you should use the <code>jelly-pekko-stream</code> module or the more low-level API: Low-level usage.</li> <li>However, the RIOT parser (deserializer) integration will automatically detect if the parsed Jelly data is delimited or not. If it's non-delimited, the parser will assume that there is only one <code>RdfStreamFrame</code> in the file.</li> <li>Jelly's parsers and writers are registered in the <code>eu.neverblink.jelly.convert.jena.riot.JellyLanguage</code>  object (source code). This registration should happen automatically when you include the <code>jelly-jena</code> module in your project, using Jena's component initialization mechanism.</li> </ul>"},{"location":"user/jena/#streaming-serialization-with-riot","title":"Streaming serialization with RIOT","text":"<p><code>jelly-jena</code> also implements a streaming writer (<code>StreamRDF</code> API in Jena). Using it is similar to the regular RIOT writer, with a slightly different setup:</p> Example: JenaRiotStreaming.java (click to expand) <p> Source code on GitHub</p> JenaRiotStreaming.java<pre><code>package eu.neverblink.jelly.examples;\n\nimport eu.neverblink.jelly.convert.jena.riot.*;\nimport eu.neverblink.jelly.core.JellyOptions;\nimport eu.neverblink.jelly.core.proto.v1.PhysicalStreamType;\nimport eu.neverblink.jelly.core.proto.v1.RdfStreamOptions;\nimport eu.neverblink.jelly.examples.shared.Example;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.util.Objects;\nimport org.apache.jena.graph.NodeFactory;\nimport org.apache.jena.graph.Triple;\nimport org.apache.jena.rdf.model.Model;\nimport org.apache.jena.riot.RDFDataMgr;\nimport org.apache.jena.riot.RDFParser;\nimport org.apache.jena.riot.RIOT;\nimport org.apache.jena.riot.lang.StreamRDFCounting;\nimport org.apache.jena.riot.system.StreamRDF;\nimport org.apache.jena.riot.system.StreamRDFLib;\nimport org.apache.jena.riot.system.StreamRDFWriter;\nimport org.apache.jena.sparql.util.Context;\n\n/**\n * Example of using Apache Jena's streaming IO API with Jelly.\n * &lt;p&gt;\n * See also: &lt;a href=\"https://jena.apache.org/documentation/io/streaming-io.html\"&gt;Jena Documentation&lt;/a&gt;\n */\npublic class JenaRiotStreaming implements Example {\n\n    public static void main(String[] args) throws Exception {\n        new JenaRiotStreaming().run(args);\n    }\n\n    @Override\n    public void run(String[] args) throws Exception {\n        // Initialize a Jena StreamRDF to consume the statements\n        StreamRDFCounting readerStream = StreamRDFLib.count();\n\n        System.out.println(\"Reading a stream of triples from a Jelly file...\");\n\n        // Parse a Jelly file as a stream of triples\n        File inputFileTriples = new File(\n            Objects.requireNonNull(getClass().getResource(\"/jelly/weather.jelly\")).toURI()\n        );\n        RDFParser.source(inputFileTriples.toURI().toString()).lang(JellyLanguage.JELLY).parse(readerStream);\n\n        System.out.printf(\"Read %d triples%n\", readerStream.countTriples());\n        System.out.println();\n        System.out.println(\"Reading a stream of quads from a Jelly file...\");\n\n        // Parse a different Jelly file as a stream of quads and send it to the same sink\n        File inputFileQuads = new File(\n            Objects.requireNonNull(getClass().getResource(\"/jelly/weather-quads.jelly\")).toURI()\n        );\n        RDFParser.source(inputFileQuads.toURI().toString()).lang(JellyLanguage.JELLY).parse(readerStream);\n\n        // Print the number of triples and quads\n        //\n        // The number of triples here is the sum of the triples from the first file and the triples\n        // in the default graph of the second file. This is just how Jena handles it.\n        System.out.printf(\n            \"Read %d triples (in total) and %d quads%n\",\n            readerStream.countTriples(),\n            readerStream.countQuads()\n        );\n\n        // -------------------------------------\n        System.out.println(\"\\n\");\n\n        System.out.println(\"Writing a stream of 10 triples to a file...\");\n\n        // Try writing some triples to a file\n        // We need to create an instance of RdfStreamOptions to pass to the writer:\n        RdfStreamOptions options = JellyOptions.SMALL_STRICT.clone()\n            // The stream writer does not know if we will be writing triples or quads \u2013 we\n            // have to specify the physical stream type explicitly.\n            .setPhysicalType(PhysicalStreamType.TRIPLES)\n            .setStreamName(\"A stream of 10 triples\");\n\n        // To pass the options, we use Jena's Context mechanism\n        Context context = RIOT.getContext()\n            .copy()\n            .set(JellyLanguage.SYMBOL_STREAM_OPTIONS, options)\n            .set(JellyLanguage.SYMBOL_FRAME_SIZE, 128); // optional, default is 256\n\n        // Create the writer using try-with-resources\n        try (FileOutputStream out = new FileOutputStream(\"stream-riot.jelly\")) {\n            // Create the writer \u2013 remember to pass the context!\n            StreamRDF writerStream = StreamRDFWriter.getWriterStream(out, JellyLanguage.JELLY, context);\n            writerStream.start();\n\n            for (int i = 1; i &lt;= 10; i++) {\n                writerStream.triple(\n                    Triple.create(\n                        NodeFactory.createBlankNode(),\n                        NodeFactory.createURI(\"https://example.org/p\"),\n                        NodeFactory.createLiteralString(\"object \" + i)\n                    )\n                );\n            }\n\n            writerStream.finish();\n        }\n\n        System.out.println(\"Done writing triples\");\n\n        // Load the RDF graph that we just saved using normal RIOT API\n        Model model = RDFDataMgr.loadModel(\"stream-riot.jelly\", JellyLanguage.JELLY);\n\n        System.out.println(\"Loaded the stream from disk, contents:\\n\");\n        model.write(System.out, \"NT\");\n    }\n}\n</code></pre>"},{"location":"user/jena/#see-also","title":"See also","text":"<ul> <li>Useful utilities</li> <li>Reactive streaming with Jelly-JVM and Apache Pekko</li> <li>Using Jelly with Jena's CLI tools</li> </ul>"},{"location":"user/low-level/","title":"Low-level usage","text":"<p>Warning</p> <p>This page describes a low-level API that is a bit of a hassle to use directly. It's recommended to use the higher-level abstractions provided by the <code>jelly-pekko-stream</code> module, or the integrations with Apache Jena's RIOT or RDF4J's Rio libraries. If you really want to use this, it is highly recommended that you first get a basic understanding of how Jelly works under the hood and take a look at the code in the <code>jelly-pekko-stream</code> module to see how it's done there.</p> <p>Note</p> <p>The following guide uses the Apache Jena library as an example. The exact same thing can be done with RDF4J or any other RDF library that has a Jelly integration.</p>"},{"location":"user/low-level/#deserialization","title":"Deserialization","text":"<p>To parse a serialized stream frame into triples/quads:</p> <ol> <li>Call <code>eu.neverblink.jelly.core.proto.v1.RdfStreamFrame.parseFrom</code>  if it's a non-delimited frame (like you would see, e.g., in a Kafka or gRPC stream), or <code>parseDelimitedFrom</code> if it's a delimited stream (like you would see in a file or a socket).<ul> <li>There is also a utility method to detect if the stream is delimited or not: <code>eu.neverblink.jelly.core.utils.IoUtils.autodetectDelimiting</code> . In most cases you will not need to use it. It is used internally by the Jena and RDF4J integrations for user convenience.</li> </ul> </li> <li>Obtain a decoder that turns <code>RdfStreamFrame</code>s into triples/quads: <code>eu.neverblink.jelly.convert.jena.JenaConverterFactory</code>  has different methods for different physical stream types:<ul> <li><code>anyStatementDecoder</code> for any physical stream type, outputs <code>Triple</code> or <code>Quad</code></li> <li><code>triplesDecoder</code> for TRIPLES streams, outputs <code>Triple</code></li> <li><code>quadsDecoder</code> for QUADS streams, outputs <code>Quad</code></li> <li><code>graphsDecoder</code> for GRAPHS streams, outputs <code>Node</code> (named graph) and <code>Triple</code>s</li> <li><code>graphsAsQuadsDecoder</code> for GRAPHS streams, outputs <code>Quad</code></li> </ul> </li> <li>For each row in the frame, call the decoder's <code>ingestRow</code> method. This method does not return anything, because handling is done differently from previous versions.</li> <li>For any decoder you must pass an implementation of respective <code>RdfHandler</code> (i.e. for <code>triplesDecoder</code> it is <code>TripleHandler</code>, for <code>graphsDecoder</code> it is <code>GraphHandler</code>, etc.). These handlers have methods that start from <code>handle</code> and are called for each triple/quad/graph that is parsed. You can implement them to do necessary actions with the data.</li> </ol>"},{"location":"user/low-level/#serialization","title":"Serialization","text":"<p>To serialize triples/quads into a stream frame:</p> <ol> <li>If you want to serialize an RDF graph/dataset, transform them first into triples/quads in an iterable form. Use the <code>triples</code>/<code>quads</code>/<code>graphs</code> methods provided by the <code>eu.neverblink.jelly.convert.jena.JenaAdapters</code>  objects (<code>MODEL_ADAPTER</code>, <code>DATASET_ADAPTER</code> and <code>GRAPH_ADAPTER</code>).</li> <li>Obtain an encoder that turns triples/quads into <code>RdfStreamRow</code>s (the rows of a stream frame): use the <code>eu.neverblink.jelly.convert.jena.JenaConverterFactory.encoder</code>  method to get an instance of <code>eu.neverblink.jelly.core.ProtoEncoder</code> .</li> <li>Call the encoder's methods to add quads, triples, or named graphs to the stream frame.<ul> <li>Note that YOU are responsible for sticking to a specific physical stream type. For example, you should not mix triples with quads. It is highly recommended that you first read on the available stream types in Jelly.</li> <li>You are also responsible for setting the appropriate stream options with proper stream types. See the guide on Jelly options presets for more information.</li> </ul> </li> <li>The encoder will be returning batches or rows. You are responsible for grouping those rows logically into <code>RdfStreamFrame</code>s. What you do here depends highly on the logical stream type you are working with.</li> </ol>"},{"location":"user/low-level/#see-also","title":"See also","text":"<ul> <li>Useful utilities</li> <li>Reactive streaming with Jelly-JVM</li> <li>Implementing Jelly-JVM for a new RDF library</li> </ul>"},{"location":"user/rdf4j/","title":"RDF4J integration","text":"<p>This guide explains the functionalities of the <code>jelly-rdf4j</code> module, which provides Jelly support for Eclipse RDF4J.</p> <p>If you just want to add Jelly format support to your RDF4J application, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/rdf4j/#base-facilities","title":"Base facilities","text":"<p><code>jelly-rdf4j</code> implements the <code>eu.neverblink.jelly.core.JellyConverterFactory</code>  interface in <code>eu.neverblink.jelly.convert.rdf4j.Rdf4jConverterFactory</code> . This factory allows you to build encoders and decoders that convert between Jelly's <code>RdfStreamFrame</code>s and RDF4J's <code>Statement</code> objects. The <code>eu.neverblink.jelly.core.proto.v1.RdfStreamFrame</code>  class is an object representation of Jelly's binary format.</p> <p>The module also implements the <code>eu.neverblink.jelly.core.utils.DatasetAdapter</code>  and <code>eu.neverblink.jelly.core.utils.GraphAdapter</code>  interfaces in <code>eu.neverblink.jelly.convert.rdf4j.Rdf4jAdapters</code> . These adapters provide methods for RDF4J's <code>Model</code> class to convert it into an iterable of triples (<code>GRAPH_ADAPTER.triples</code>), quads (<code>DATASET_ADAPTER.quads</code>), or named graphs (<code>DATASET_ADAPTER.graphs</code>). This is useful when working with Jelly on a lower level or when using the <code>jelly-pekko-stream</code> module.</p>"},{"location":"user/rdf4j/#serialization-and-deserialization-with-rdf4j-rio","title":"Serialization and deserialization with RDF4J Rio","text":"<p><code>jelly-rdf4j</code> implements an RDF writer and parser for Eclipse RDF4J's Rio library. This means you can use Jelly just like any other RDF serialization format (e.g., RDF/XML, Turtle). See the example below:</p> Example: Rdf4jRio.java (click to expand) <p> Source code on GitHub</p> Rdf4jRio.java<pre><code>package eu.neverblink.jelly.examples;\n\nimport eu.neverblink.jelly.convert.rdf4j.rio.*;\nimport eu.neverblink.jelly.core.*;\nimport eu.neverblink.jelly.core.proto.v1.PhysicalStreamType;\nimport eu.neverblink.jelly.core.proto.v1.RdfStreamOptions;\nimport eu.neverblink.jelly.examples.shared.Example;\nimport java.io.File;\nimport java.io.FileOutputStream;\nimport java.io.InputStream;\nimport java.util.Collection;\nimport java.util.Objects;\nimport java.util.Optional;\nimport org.eclipse.rdf4j.model.Statement;\nimport org.eclipse.rdf4j.rio.RDFFormat;\nimport org.eclipse.rdf4j.rio.RDFParser;\nimport org.eclipse.rdf4j.rio.RDFWriter;\nimport org.eclipse.rdf4j.rio.Rio;\nimport org.eclipse.rdf4j.rio.helpers.StatementCollector;\n\n/**\n * Example of using RDF4J's Rio library to read and write RDF data.\n * &lt;p&gt;\n * See also: &lt;a href=\"https://rdf4j.org/documentation/programming/rio/\"&gt;RDF4J Documentation&lt;/a&gt;\n */\npublic class Rdf4jRio implements Example {\n\n    public static void main(String[] args) throws Exception {\n        new Rdf4jRio().run(args);\n    }\n\n    @Override\n    public void run(String[] args) throws Exception {\n        // Load the RDF graph from an N-Triples file\n        File inputFile = new File(Objects.requireNonNull(getClass().getResource(\"/weather.nt\")).toURI());\n        Collection&lt;Statement&gt; triples = readRdf4j(inputFile, RDFFormat.TURTLE, Optional.empty());\n\n        // Print the size of the graph\n        System.out.printf(\"Loaded %d triples from an N-Triples file%n\", triples.size());\n\n        // Write the RDF graph to a Jelly file\n        // First, create the stream's options:\n        RdfStreamOptions options = JellyOptions.SMALL_STRICT.clone()\n            // Setting the physical stream type is mandatory! It will always be either TRIPLES or QUADS.\n            .setPhysicalType(PhysicalStreamType.TRIPLES)\n            // Set other optional options\n            .setStreamName(\"My weather data\");\n        // Create the config object to pass to the writer\n        JellyWriterSettings config = JellyWriterSettings.empty().setJellyOptions(options).setFrameSize(128);\n\n        // Do the actual writing\n        try (FileOutputStream out = new FileOutputStream(\"weather.jelly\")) {\n            RDFWriter writer = Rio.createWriter(JellyFormat.JELLY, out);\n            writer.setWriterConfig(config);\n            writer.startRDF();\n            triples.forEach(writer::handleStatement);\n            writer.endRDF();\n        }\n\n        System.out.println(\"Saved the model to a Jelly file\");\n\n        // Load the RDF graph from the Jelly file\n        File jellyFile = new File(\"weather.jelly\");\n        Collection&lt;Statement&gt; jellyTriples = readRdf4j(jellyFile, JellyFormat.JELLY, Optional.empty());\n\n        // Print the size of the graph\n        System.out.printf(\"Loaded %d triples from a Jelly file%n\", jellyTriples.size());\n\n        // ---------------------------------\n        System.out.println(\"\\n\");\n        // By default, the parser has limits on for example the maximum size of the lookup tables.\n        // The default supported options are JellyOptions.defaultSupportedOptions.\n        // You can change these limits by creating your own options object.\n        RdfStreamOptions customOptions = JellyOptions.DEFAULT_SUPPORTED_OPTIONS.clone().setMaxPrefixTableSize(10); // set the maximum size of the prefix table to 10\n        System.out.println(\"Trying to read the Jelly file with custom options...\");\n        try {\n            // This operation should fail because the Jelly file uses a prefix table larger than 10\n            Collection&lt;Statement&gt; customTriples = readRdf4j(jellyFile, JellyFormat.JELLY, Optional.of(customOptions));\n        } catch (RdfProtoDeserializationError e) {\n            // The stream uses a prefix table size of 16, which is larger than the maximum supported size of 10.\n            // To read this stream, set maxPrefixTableSize to at least 16 in the supportedOptions for this decoder.\n            System.out.printf(\"Failed to read the Jelly file with custom options: %s%n\", e.getMessage());\n        }\n    }\n\n    /**\n     * Helper function to read RDF data using RDF4J's Rio library.\n     *\n     * @param file             file to read from\n     * @param format           RDF format\n     * @param supportedOptions supported options for reading Jelly streams (optional)\n     * @return list of RDF statements\n     */\n    private Collection&lt;Statement&gt; readRdf4j(File file, RDFFormat format, Optional&lt;RdfStreamOptions&gt; supportedOptions)\n        throws Exception {\n        RDFParser parser = Rio.createParser(format);\n        StatementCollector collector = new StatementCollector();\n        parser.setRDFHandler(collector);\n        supportedOptions.ifPresent(opt -&gt;\n            // If the user provided supported options, set them on the parser\n            parser.setParserConfig(JellyParserSettings.from(opt))\n        );\n\n        try (InputStream is = file.toURI().toURL().openStream()) {\n            parser.parse(is);\n        }\n        return collector.getStatements();\n    }\n}\n</code></pre> <p>Usage notes:</p> <ul> <li><code>eu.neverblink.jelly.core.JellyOptions</code>  provides a few common presets for Jelly serialization options. These options are passed through <code>eu.neverblink.jelly.convert.rdf4j.rio.JellyWriterSettings.configFromOptions</code>  and used to configure the writer, as shown in the example above. You can also further customize the serialization options (e.g., dictionary size).</li> <li>The RDF4J Rio writer (serializer) integration implements only the delimited variant of Jelly. It is used for writing Jelly to files on disk or sockets. Because of this, you cannot use Rio to write non-delimited Jelly data (e.g., a single message to a Kafka stream). For this, you should use the <code>jelly-pekko-stream</code> module or the more low-level API: Low-level usage.</li> <li>However, the Rio parser (deserializer) integration will automatically detect if the parsed Jelly data is delimited or not. If it's non-delimited, the parser will assume that there is only one <code>RdfStreamFrame</code> in the file.</li> <li>Jelly's parsers and writers are in the <code>eu.neverblink.jelly.convert.rdf4j.rio</code>  package (source code). They are automatically registered on startup using the <code>RDFParserFactory</code> and <code>RDFWriterFactory</code> SPIs provided by RDF4J.</li> </ul>"},{"location":"user/rdf4j/#see-also","title":"See also","text":"<ul> <li>Useful utilities</li> <li>Reactive streaming with Jelly-JVM and Apache Pekko</li> </ul>"},{"location":"user/reactive/","title":"User guide \u2013 reactive streaming","text":"<p>This guide explains the reactive streaming functionalities of the <code>jelly-pekko-stream</code> module with Apache Pekko Streams.</p> <p>Prerequisites</p> <p>If you are unfamiliar with the concept of reactive streams or Apache Pekko Streams, we highly recommend you start from reading about the basic concepts of Pekko Streams.</p> <p>We also recommend you first read about the RDF stream types in Jelly. Otherwise, this guide may not make much sense.</p> <p>You can use <code>jelly-pekko-stream</code> with any RDF library that has a full Jelly integration, such as Apache Jena (using <code>jelly-jena</code>) or RDF4J (using <code>jelly-rdf4j</code>)<sup>1</sup>. The streaming API is generic and identical across all libraries.</p>"},{"location":"user/reactive/#basic-concepts","title":"Basic concepts","text":"<p>A key notion of this API are the encoders and decoders.</p> <ul> <li>An encoder turns objects from your RDF library of choice (e.g., <code>Triple</code> in Apache Jena) into an object representation of Jelly's binary format (<code>RdfStreamFrame</code>).</li> <li>A decoder does the opposite: it turns <code>RdfStreamFrame</code>s into objects from your RDF library of choice.</li> </ul> <p>So, for example, an encoder flow for flat triple streams would have a type of <code>Flow[Triple, RdfStreamFrame, NotUsed]</code> in Apache Jena. The opposite (a flat triple stream decoder) would have a type of <code>Flow[RdfStreamFrame, Triple, NotUsed]</code>.</p> <p><code>RdfStreamFrame</code>s can be converted to and from raw bytes using a range of methods, depending on your use case. See the sections below for examples.</p>"},{"location":"user/reactive/#encoding-any-rdf-data-as-a-flat-or-grouped-stream-encoderflow","title":"Encoding any RDF data as a flat or grouped stream (<code>EncoderFlow</code>)","text":"<p>The <code>eu.neverblink.jelly.pekko.stream.EncoderFlow</code>  provides many options for turning RDF data into Jelly streams, including both grouped and flat streams. Every type of RDF stream in Jelly can be created using this API.</p> Example: PekkoStreamsEncoderFlow.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsEncoderFlow.scala<pre><code>package eu.neverblink.jelly.examples\n\nimport eu.neverblink.jelly.convert.jena.{JenaAdapters, JenaConverterFactory}\nimport eu.neverblink.jelly.core.JellyOptions\nimport eu.neverblink.jelly.examples.shared.ScalaExample\nimport eu.neverblink.jelly.pekko.stream.{\n  ByteSizeLimiter,\n  EncoderFlow,\n  RdfSource,\n  StreamRowCountLimiter,\n}\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport java.io.File\nimport scala.concurrent.duration.*\nimport scala.concurrent.{Await, ExecutionContext}\nimport scala.jdk.CollectionConverters.*\n\n/** Example of using the [[EncoderFlow]] utility to encode RDF data as Jelly streams.\n  *\n  * Here, the RDF data is turned into a series of byte buffers, with each buffer corresponding to\n  * exactly one frame. This is suitable if your streaming protocol (e.g., Kafka, MQTT, AMQP) already\n  * frames the messages. If you are writing to a raw socket or file, then you must use the DELIMITED\n  * variant of Jelly instead. See [[eu.neverblink.jelly.examples.PekkoStreamsWithIo]] for examples\n  * of that.\n  *\n  * In this example we are using Apache Jena as the RDF library (note the import:\n  * `import eu.neverblink.jelly.convert.jena.given`). The same can be achieved with RDF4J just by\n  * importing a different module.\n  */\nobject PekkoStreamsEncoderFlow extends ScalaExample:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // We will need a JenaConverterFactory to convert between Jelly and Jena\n    given JenaConverterFactory = JenaConverterFactory.getInstance()\n\n    // We need to import the Jena adapters for Jelly\n    given JenaAdapters.DATASET_ADAPTER.type = JenaAdapters.DATASET_ADAPTER\n    given JenaAdapters.MODEL_ADAPTER.type = JenaAdapters.MODEL_ADAPTER\n\n    // Load the example dataset\n    val dataset = RDFDataMgr.loadDataset(\n      File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString,\n    )\n\n    // Note: here we are not turning the frames into bytes, but just printing their size in bytes.\n    // You can find an example of how to turn a frame into a byte array in the `PekkoStreamsEncoderSource` example.\n    // This is done with: .via(JellyIo.toBytes)\n\n    // Let's try encoding this as flat RDF streams (streams of triples or quads)\n    // https://w3id.org/stax/ontology#flatQuadStream\n\n    // We will use RdfSource to transform the dataset into a stream of quads\n    val quads = RdfSource.builder()\n      .datasetAsQuads(dataset)\n      .source\n\n    println(f\"Encoding ${dataset.asDatasetGraph.size} quads as a flat RDF quad stream\")\n    val flatQuadsFuture = quads\n      .via(\n        EncoderFlow.builder\n          // This encoder requires a size limiter \u2013 otherwise a stream frame could have infinite length!\n          .withLimiter(StreamRowCountLimiter(20))\n          .flatQuads(JellyOptions.SMALL_STRICT)\n          .flow,\n      )\n      .runWith(\n        Sink.foreach(frame =&gt;\n          println(s\"Frame with ${frame.getRows.size} rows, ${frame.getSerializedSize} bytes\"),\n        ),\n      )\n\n    Await.ready(flatQuadsFuture, 10.seconds)\n\n    // https://w3id.org/stax/ontology#flatTripleStream\n\n    // We will use RdfSource to transform the default graph of the dataset into a stream of triples\n    val triples = RdfSource.builder()\n      .graphAsTriples(dataset.getDefaultModel)\n      .source\n\n    println(f\"\\n\\nEncoding ${dataset.getDefaultModel.size} triples as a flat RDF triple stream\")\n    val flatTriplesFuture = triples\n      .via(\n        EncoderFlow.builder\n          // This encoder requires a size limiter \u2013 otherwise a stream frame could have infinite length!\n          .withLimiter(ByteSizeLimiter(500))\n          .flatTriples(JellyOptions.SMALL_STRICT)\n          .flow,\n      )\n      .runWith(\n        Sink.foreach(frame =&gt;\n          println(s\"Frame with ${frame.getRows.size} rows, ${frame.getSerializedSize} bytes\"),\n        ),\n      )\n\n    Await.ready(flatTriplesFuture, 10.seconds)\n\n    // We can also stream already grouped triples or quads \u2013 for example, if your system generates batches of\n    // N triples, you can just send those batches straight to be encoded, with one batch = one stream frame.\n    // https://w3id.org/stax/ontology#flatQuadStream\n    println(\n      f\"\\n\\nEncoding ${dataset.asDatasetGraph.stream.count} quads as a flat RDF quad stream, grouped in batches of 10\",\n    )\n    // First, group the quads into batches of 10\n    val groupedQuadsFuture = quads\n      .grouped(10)\n      .via(\n        EncoderFlow.builder\n          // Do not use a size limiter here \u2013 we want exactly one batch in each frame\n          .flatQuadsGrouped(JellyOptions.SMALL_STRICT)\n          .flow,\n      )\n      .runWith(\n        Sink.foreach(frame =&gt;\n          println(s\"Frame with ${frame.getRows.size} rows, ${frame.getSerializedSize} bytes\"),\n        ),\n      )\n\n    Await.ready(groupedQuadsFuture, 10.seconds)\n\n    // Now, let's try grouped streams. Let's say we want to stream all graphs in a dataset, but put exactly one\n    // graph in each frame (message). This is very common in (for example) IoT systems.\n    // https://w3id.org/stax/ontology#namedGraphStream\n\n    // We will use RdfSource to transform the dataset into a stream of named graphs\n    val graphs = RdfSource.builder()\n      .datasetAsGraphs(dataset)\n      .source\n\n    println(f\"\\n\\nEncoding ${dataset.asDatasetGraph.size} graphs as a named graph stream\")\n    val namedGraphsFuture = graphs\n      .via(\n        EncoderFlow.builder\n          // Do not use a size limiter here \u2013 we want exactly one graph in each frame\n          .namedGraphs(JellyOptions.SMALL_STRICT)\n          .flow,\n      )\n      // Note that we will see exactly as many frames as there are graphs in the dataset\n      .runWith(\n        Sink.foreach(frame =&gt;\n          println(s\"Frame with ${frame.getRows.size} rows, ${frame.getSerializedSize} bytes\"),\n        ),\n      )\n\n    Await.ready(namedGraphsFuture, 10.seconds)\n\n    // As a last example, we will stream a series of RDF graphs. In our case this will be just the default graph\n    // repeated a few times. This type of stream is also pretty common in practical applications.\n    // https://w3id.org/stax/ontology#graphStream\n    println(\"\\n\\nEncoding 5 RDF graphs as a graph stream\")\n    val graphsFuture = Source\n      .repeat(\n        // We will collect the triples of the default graph and repeat this iterable continually\n        // This is just an example \u2013 in a real application you would probably be streaming\n        // a stream of graphs from a source like Kafka or MQTT\n        dataset.getDefaultModel.getGraph.find.asScala.toList,\n      )\n      .take(5)\n      .via(\n        EncoderFlow.builder\n          // Do not use a size limiter here \u2013 we want exactly one graph in each frame\n          .graphs(JellyOptions.SMALL_STRICT)\n          .flow,\n      )\n      // Note that we will see exactly 5 frames \u2013 the number of graphs we streamed\n      .runWith(\n        Sink.foreach(frame =&gt;\n          println(s\"Frame with ${frame.getRows.size} rows, ${frame.getSerializedSize} bytes\"),\n        ),\n      )\n\n    Await.ready(graphsFuture, 10.seconds)\n    actorSystem.terminate()\n</code></pre>"},{"location":"user/reactive/#encoding-a-single-rdf-graph-or-dataset-as-a-flat-stream-encodersource","title":"Encoding a single RDF graph or dataset as a flat stream (<code>EncoderSource</code>)","text":"<p>There are also convenience methods for creating flat RDF streams (i.e., flat streams of triples or quads) from  a single graph or dataset. You can do this by chaining <code>eu.neverblink.jelly.pekko.stream.RdfSource</code>  with <code>eu.neverblink.jelly.pekko.stream.EncoderFlow</code> , as shown in the example.</p> Example: PekkoStreamsEncoderSource.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsEncoderSource.scala<pre><code>package eu.neverblink.jelly.examples\n\nimport eu.neverblink.jelly.convert.jena.{JenaAdapters, JenaConverterFactory}\nimport eu.neverblink.jelly.core.JellyOptions\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\nimport eu.neverblink.jelly.examples.shared.ScalaExample\nimport eu.neverblink.jelly.pekko.stream.{\n  ByteSizeLimiter,\n  EncoderFlow,\n  JellyIo,\n  RdfSource,\n  StreamRowCountLimiter,\n}\nimport org.apache.jena.graph.{Node, Triple}\nimport org.apache.jena.query.Dataset\nimport org.apache.jena.rdf.model.Model\nimport org.apache.jena.sparql.core.Quad\n\nimport java.io.File\nimport scala.concurrent.duration.*\nimport scala.concurrent.{Await, ExecutionContext}\n\n/** Example of using the [[RdfSource]] and [[EncoderFlow]] utilities to encode single RDF graphs and\n  * datasets as Jelly streams.\n  *\n  * In this example we are using Apache Jena as the RDF library (note the import:\n  * `import eu.neverblink.jelly.convert.jena.given`). The same can be achieved with RDF4J just by\n  * importing a different module.\n  */\nobject PekkoStreamsEncoderSource extends ScalaExample:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // We will need a JenaConverterFactory to convert between Jelly and Jena\n    given JenaConverterFactory = JenaConverterFactory.getInstance()\n\n    // We need to import the Jena adapters for Jelly\n    given JenaAdapters.DATASET_ADAPTER.type = JenaAdapters.DATASET_ADAPTER\n    given JenaAdapters.MODEL_ADAPTER.type = JenaAdapters.MODEL_ADAPTER\n\n    // Load an example RDF graph from an N-Triples file\n    val model = RDFDataMgr.loadModel(File(getClass.getResource(\"/weather.nt\").toURI).toURI.toString)\n\n    println(s\"Loaded model with ${model.size()} triples\")\n    println(\"Streaming the model to memory...\")\n\n    // Create a Pekko Streams Source[Triple] from the Jena model\n    val encodedModelFuture = RdfSource.builder().graphAsTriples(model).source\n      // Encode the stream as a flat RDF triple stream\n      .via(\n        EncoderFlow.builder\n          .withLimiter(ByteSizeLimiter(2000))\n          .flatTriples(JellyOptions.SMALL_STRICT)\n          .flow,\n      )\n      // wireTap: print the size of the frames\n      // Notice in the output that the frames are slightly bigger than 2000 bytes.\n      .wireTap(frame =&gt;\n        println(s\"Frame with ${frame.getRows.size} rows, ${frame.getSerializedSize} bytes on wire\"),\n      )\n      // Convert each stream frame to bytes\n      .via(JellyIo.toBytes)\n      // Collect the stream into a sequence\n      .runWith(Sink.seq)\n\n    // Wait for the stream to complete and collect the result\n    val encodedModel = Await.result(encodedModelFuture, 10.seconds)\n\n    println(\n      s\"Streamed model to memory with ${encodedModel.size} frames and\" +\n        s\" ${encodedModel.map(_.length).sum} bytes on wire\",\n    )\n\n    println(\"\\n\")\n\n    // -------------------------------------------------------------------\n    // Second example: try encoding an RDF dataset as a GRAPHS stream\n    // This time we will also preserve the namespace/prefix declarations (@prefix in Turtle) as a cosmetic feature\n    val dataset = RDFDataMgr.loadDataset(\n      File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString,\n    )\n    println(s\"Loaded dataset with ${dataset.asDatasetGraph.size} named graphs\")\n    println(\"Streaming the dataset to memory...\")\n\n    // Here we stream this is as a GRAPHS stream (physical type)\n    // You can also use .datasetAsQuads to stream as QUADS\n    val encodedDatasetFuture = RdfSource.builder[Model, Dataset, Node, Triple, Quad]()\n      .datasetAsGraphs(dataset)\n      .withNamespaceDeclarations // Include namespace declarations in the stream\n      .source\n      .via(\n        EncoderFlow.builder\n          // This time we limit the number of rows in each frame to 30\n          // Note that for this particular encoder, we can skip the limiter entirely \u2013 but this can lead to huge frames!\n          // So, be careful with that, or may get an out-of-memory error.\n          .withLimiter(StreamRowCountLimiter(30))\n          .namedGraphs(JellyOptions.SMALL_STRICT)\n          // We must also allow for namespace declarations, because our source contains them\n          .withNamespaceDeclarations\n          .flow,\n      )\n      // wireTap: print the size of the frames\n      // Note that some frames smaller than the limit \u2013 this is because this encoder will always split frames\n      // on graph boundaries.\n      .wireTap(frame =&gt;\n        println(s\"Frame with ${frame.getRows.size} rows, ${frame.getSerializedSize} bytes on wire\"),\n      )\n      // Convert each stream frame to bytes\n      .via(JellyIo.toBytes)\n      // Collect the stream into a sequence\n      .runWith(Sink.seq)\n\n    // Wait for the stream to complete and collect the result\n    val encodedDataset = Await.result(encodedDatasetFuture, 10.seconds)\n\n    println(\n      s\"Streamed dataset to memory with ${encodedDataset.size} frames and\" +\n        s\" ${encodedDataset.map(_.length).sum} bytes on wire\",\n    )\n\n    actorSystem.terminate()\n</code></pre>"},{"location":"user/reactive/#decoding-rdf-streams-decoderflow","title":"Decoding RDF streams (<code>DecoderFlow</code>)","text":"<p>The <code>eu.neverblink.jelly.pekko.stream.DecoderFlow</code>  provides methods for decoding flat and grouped streams. There is no opposite equivalent to <code>EncoderSource</code> for decoding, though. This would require constructing an RDF graph or dataset from statements, which is a process that can vary a lot depending on your application. You will have to do this part yourself.</p> Example: PekkoStreamsDecoderFlow.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsDecoderFlow.scala<pre><code>package eu.neverblink.jelly.examples\n\nimport eu.neverblink.jelly.convert.jena.{JenaAdapters, JenaConverterFactory}\nimport eu.neverblink.jelly.core.JellyOptions\nimport eu.neverblink.jelly.examples.shared.ScalaExample\nimport eu.neverblink.jelly.pekko.stream.*\nimport org.apache.jena.graph.{Node, Triple}\nimport org.apache.jena.query.Dataset\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.jena.sparql.core.Quad\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport java.io.File\nimport scala.collection.immutable\nimport scala.concurrent.duration.*\nimport scala.concurrent.{Await, ExecutionContext}\n\n/** Example of using the [[DecoderFlow]] utility to turn incoming Jelly streams into usable RDF\n  * data.\n  *\n  * In this example we are using Apache Jena as the RDF library (note the import:\n  * `import eu.neverblink.jelly.convert.jena.given`). The same can be achieved with RDF4J just by\n  * importing a different module.\n  */\nobject PekkoStreamsDecoderFlow extends ScalaExample:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // We will need a JenaConverterFactory to convert between Jelly and Jena\n    given JenaConverterFactory = JenaConverterFactory.getInstance()\n\n    // We need to import the Jena adapters to turn Model/Dataset into a stream of statements\n    given JenaAdapters.DATASET_ADAPTER.type = JenaAdapters.DATASET_ADAPTER\n    given JenaAdapters.MODEL_ADAPTER.type = JenaAdapters.MODEL_ADAPTER\n\n    // Load the example dataset\n    val dataset = RDFDataMgr.loadDataset(\n      File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString,\n    )\n\n    // To decode something, we first need to encode it...\n    // See [[PekkoStreamsEncoderFlow]] and [[PekkoStreamsEncoderSource]] for an explanation of what is happening here.\n    // We have four seqences of byte arrays, with each byte array corresponding to one encoded stream frame:\n    // - encodedQuads: a flat RDF quad stream, physical type: QUADS\n    // - encodedTriples: a flat RDF triple stream, physical type: TRIPLES\n    // - encodedGraphs: a flat RDF quad stream, physical type: GRAPHS\n    val (encodedQuads, encodedTriples, encodedGraphs) = getEncodedData(dataset)\n\n    // Now we can decode the encoded data back into something useful.\n    // Let's start by simply decoding the quads as a flat RDF quad stream:\n    println(\"Decoding quads as a flat RDF quad stream...\")\n    val decodedQuadsFuture = Source(encodedQuads)\n      // We need to parse the bytes into a Jelly stream frame\n      .via(JellyIo.fromBytes)\n      // And then decode the frame into Jena quads.\n      // We use \"decodeQuads\" because the physical stream type is QUADS.\n      // And then we want to treat it as a flat RDF quad stream, so we call \"asFlatQuadStreamStrict\".\n      // We use the \"Strict\" method to tell the decoder to check if the incoming logical stream type is the same\n      // as we are expecting: flat RDF quad stream.\n      .via(DecoderFlow.decodeQuads.asFlatQuadStreamStrict)\n      .runWith(Sink.seq)\n\n    val decodedQuads: Seq[Quad] = Await.result(decodedQuadsFuture, 10.seconds)\n    println(s\"Decoded ${decodedQuads.size} quads.\")\n\n    // We can also treat each stream frame as a separate dataset. This way we would get an\n    // RDF dataset stream.\n    println(f\"\\n\\nDecoding quads as an RDF dataset stream from ${encodedQuads.size} frames...\")\n    val decodedDatasetFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // Note that we cannot use the strict variant (asDatasetStreamOfQuadsStrict) here, because the stream says its\n      // logical type is flat RDF quad stream.\n      .via(DecoderFlow.decodeQuads.asDatasetStreamOfQuads)\n      .runWith(Sink.seq)\n\n    val decodedDatasets: Seq[Seq[Quad]] = Await.result(decodedDatasetFuture, 10.seconds)\n    println(\n      s\"Decoded ${decodedDatasets.size} datasets with\" +\n        s\" ${decodedDatasets.map(_.iterator.size).sum} quads in total.\",\n    )\n\n    // If we tried that with the strict variant, we would get an exception:\n    println(\"\\n\\nDecoding quads as an RDF dataset stream with strict logical type handling...\")\n    val future = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      .via(DecoderFlow.decodeQuads.asDatasetStreamOfQuadsStrict)\n      .runWith(Sink.seq)\n    Await.result(\n      future.recover {\n        // eu.neverblink.jelly.core.JellyExceptions$RdfProtoDeserializationError:\n        // Expected logical stream type LOGICAL_STREAM_TYPE_DATASETS, got LOGICAL_STREAM_TYPE_FLAT_QUADS.\n        // LOGICAL_STREAM_TYPE_FLAT_QUADS is not a subtype of LOGICAL_STREAM_TYPE_DATASETS.\n        case e: Exception =&gt; println(e.getCause)\n      },\n      10.seconds,\n    )\n\n    // We can also pass entirely custom supported options to the decoder, instead of the defaults\n    // (see [[JellyOptions.DEFAULT_SUPPORTED_OPTIONS]]). This is useful if we want to decode a stream with\n    // for example very large lookup tables or we want to put stricter limits on the streams that we accept.\n    println(\"\\n\\nDecoding quads as an RDF dataset stream with custom supported options...\")\n    val customSupportedOptions = JellyOptions.DEFAULT_SUPPORTED_OPTIONS.clone()\n      .setMaxNameTableSize(50) // This is too small for the stream we are decoding\n    val customSupportedOptionsFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      .via(DecoderFlow.decodeQuads.asDatasetStreamOfQuads(customSupportedOptions))\n      .runWith(Sink.seq)\n    Await.result(\n      customSupportedOptionsFuture.recover {\n        // eu.neverblink.jelly.core.RdfProtoDeserializationError:\n        // The stream uses a name table size of 128, which is larger than the maximum supported size of 50.\n        // To read this stream, set maxNameTableSize to at least 128 in the supportedOptions for this decoder.\n        case e: Exception =&gt; println(e.getCause)\n      },\n      10.seconds,\n    )\n\n    // Flat RDF triple stream\n    println(\"\\n\\nDecoding triples as a flat RDF triple stream...\")\n    val decodedTriplesFuture = Source(encodedTriples)\n      .via(JellyIo.fromBytes)\n      .via(DecoderFlow.decodeTriples.asFlatTripleStreamStrict)\n      .runWith(Sink.seq)\n\n    val decodedTriples: Seq[Triple] = Await.result(decodedTriplesFuture, 10.seconds)\n    println(s\"Decoded ${decodedTriples.size} triples.\")\n\n    // We can interpret the GRAPHS stream in a few ways, see\n    // [[eu.neverblink.jelly.stream.DecoderFlow.GraphsIngestFlowOps]] for more details.\n    // Here we will treat it as an RDF named graph stream.\n    println(\"\\n\\nDecoding graphs as an RDF named graph stream...\")\n    val decodedGraphsFuture = Source(encodedGraphs)\n      .via(JellyIo.fromBytes)\n      // Non-strict because the original logical stream type is flat RDF quad stream.\n      .via(DecoderFlow.decodeGraphs.asNamedGraphStream)\n      .runWith(Sink.seq)\n\n    val decodedGraphs: Seq[(Node, Iterable[Triple])] = Await.result(decodedGraphsFuture, 10.seconds)\n    println(s\"Decoded ${decodedGraphs.size} graphs.\")\n\n    // If we tried using a decoder for a physical stream type that does not match the type of the stream,\n    // we would get an exception. Here let's try to decode a QUADS stream with a TRIPLES decoder.\n    println(\"\\n\\nDecoding quads as a flat RDF triple stream...\")\n    val future2 = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // Note the \"decodeTriples\" here\n      .via(DecoderFlow.decodeTriples.asFlatTripleStream)\n      .runWith(Sink.seq)\n    Await.result(\n      future2.recover {\n        // eu.neverblink.jelly.core.JellyExceptions$RdfProtoDeserializationError:\n        // Incoming stream type is not TRIPLES.\n        case e: Exception =&gt; println(e)\n      },\n      10.seconds,\n    )\n\n    // We can get around this by using the \"decodeAny\" method, which will pick the appropriate decoder\n    // based on the stream options in the stream.\n    // In this case we can only ask the decoder to output a flat or grouped RDF stream.\n    println(\"\\n\\nDecoding quads as a flat RDF stream using decodeAny...\")\n    val decodedAnyFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // The is no strict variant at all for decodeAny, as we don't care about the stream type anyway.\n      .via(DecoderFlow.decodeAny.asFlatStream)\n      .runWith(Sink.seq)\n\n    val decodedAny: Seq[Triple | Quad] = Await.result(decodedAnyFuture, 10.seconds)\n    println(s\"Decoded ${decodedAny.size} statements.\")\n\n    // One last trick up our sleeves is the snoopStreamOptions method, which allows us to inspect the stream options\n    // and carry on with the decoding as normal.\n    // In this case, we will reuse the first example (flat RDF quad stream) and snoop the stream options.\n    println(\n      \"\\n\\nSnooping the stream options of the first frame while decoding a flat RDF quad stream...\",\n    )\n    val snoopFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // We add a .viaMat here to capture the materialized value of this stage.\n      .viaMat(DecoderFlow.snoopStreamOptions)(Keep.right)\n      .via(DecoderFlow.decodeQuads.asFlatQuadStreamStrict)\n      .toMat(Sink.seq)(Keep.both)\n      .run()\n\n    val streamOptions = Await.result(snoopFuture._1, 10.seconds)\n    val decodedQuads2 = Await.result(snoopFuture._2, 10.seconds)\n\n    val streamOptionsIndented =\n      s\"\"\"\n        |   streamName: ${streamOptions.get.getStreamName}\n        |   physicalType: ${streamOptions.get.getPhysicalType}\n        |   logicalType: ${streamOptions.get.getLogicalType}\n        |   generalizedStatements: ${streamOptions.get.getGeneralizedStatements}\n        |   rdfStar: ${streamOptions.get.getRdfStar}\n        |   maxNameTableSize: ${streamOptions.get.getMaxNameTableSize}\n        |   maxPrefixTableSize: ${streamOptions.get.getMaxPrefixTableSize}\n        |   maxDatatypeTableSize: ${streamOptions.get.getMaxDatatypeTableSize}\n        |\"\"\".stripMargin\n    println(s\"Stream options: $streamOptionsIndented\")\n    println(s\"Decoded ${decodedQuads2.size} quads.\")\n\n    actorSystem.terminate()\n\n  /** Helper method to produce encoded data from a dataset.\n    */\n  private def getEncodedData(dataset: Dataset)(using\n      ActorSystem,\n      ExecutionContext,\n      JenaConverterFactory,\n      JenaAdapters.DATASET_ADAPTER.type,\n      JenaAdapters.MODEL_ADAPTER.type,\n  ): (Seq[Array[Byte]], Seq[Array[Byte]], Seq[Array[Byte]]) =\n    val quadStream = RdfSource.builder().datasetAsQuads(dataset).source\n      .via(\n        EncoderFlow.builder.withLimiter(ByteSizeLimiter(500)).flatQuads(\n          JellyOptions.SMALL_STRICT,\n        ).flow,\n      )\n\n    val tripleStream = RdfSource.builder()\n      .graphAsTriples(dataset.getDefaultModel)\n      .source\n      .via(\n        EncoderFlow.builder.withLimiter(ByteSizeLimiter(250)).flatTriples(\n          JellyOptions.SMALL_STRICT,\n        ).flow,\n      )\n\n    val graphStream = RdfSource.builder()\n      .datasetAsGraphs(dataset)\n      .source\n      .via(\n        EncoderFlow.builder.withLimiter(ByteSizeLimiter(500)).namedGraphs(\n          JellyOptions.SMALL_STRICT,\n        ).flow,\n      )\n\n    val results = Seq(quadStream, tripleStream, graphStream).map { stream =&gt;\n      val streamFuture = stream\n        .via(JellyIo.toBytes)\n        .runWith(Sink.seq)\n      Await.result(streamFuture, 10.seconds)\n    }\n    (results.head, results(1), results(2))\n</code></pre>"},{"location":"user/reactive/#byte-streams-delimited-variant","title":"Byte streams (delimited variant)","text":"<p>In all of the examples above, we used the non-delimited variant of Jelly, which is appropriate for, e.g., sending Jelly data over gRPC or Kafka. If you want to write Jelly data to a file or a socket, you will need to use the delimited variant. <code>jelly-pekko-stream</code> provides a few methods for this in <code>eu.neverblink.jelly.pekko.stream.JellyIo</code> .</p> Example: PekkoStreamsWithIo.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsWithIo.scala<pre><code>package eu.neverblink.jelly.examples\n\nimport eu.neverblink.jelly.convert.jena.JenaConverterFactory\nimport eu.neverblink.jelly.core.JellyOptions\nimport eu.neverblink.jelly.examples.shared.ScalaExample\nimport eu.neverblink.jelly.pekko.stream.*\nimport org.apache.jena.graph.Triple\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\nimport org.apache.pekko.util.ByteString\n\nimport java.io.{File, FileInputStream, FileOutputStream}\nimport java.util.zip.GZIPInputStream\nimport scala.collection.immutable\nimport scala.concurrent.duration.*\nimport scala.concurrent.{Await, ExecutionContext}\nimport scala.util.Using\n\n/** Example of using Pekko Streams to read/write Jelly to a file or any other byte stream (e.g.,\n  * socket).\n  *\n  * The examples here use the DELIMITED variant of Jelly, which is suitable only for situations\n  * where there is no framing in the underlying stream. You should always use the delimited variant\n  * with raw files and sockets, as otherwise it would be impossible to tell where one stream frame\n  * ends and another one begins.\n  *\n  * If you are working with something like MQTT, Kafka, JMS, AMQP... then check the examples in\n  * [[eu.neverblink.jelly.examples.PekkoStreamsEncoderFlow]].\n  *\n  * In this example we are using Apache Jena as the RDF library (note the import:\n  * `import eu.neverblink.jelly.convert.jena.given`). The same can be achieved with RDF4J just by\n  * importing a different module.\n  */\nobject PekkoStreamsWithIo extends ScalaExample:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // We will need a JenaConverterFactory to convert between Jelly and Jena\n    given JenaConverterFactory = JenaConverterFactory.getInstance()\n\n    // We will read a gzipped Jelly file from disk and decode it on the fly, as we are decompressing it.\n    println(\"Decoding a gzipped Jelly file with Pekko Streams...\")\n    // The input file is a GZipped Jelly file\n    val inputFile = File(getClass.getResource(\"/jelly/weather.jelly.gz\").toURI)\n\n    // Use Java's GZIPInputStream to decompress the input file on the fly\n    val decodedTriples: Seq[Triple] =\n      Using.resource(new GZIPInputStream(FileInputStream(inputFile))) { inputStream =&gt;\n        val decodedTriplesFuture = JellyIo.fromIoStream(inputStream)\n          // Decode the Jelly frames to triples.\n          // Under the hood it uses the RdfStreamFrame.parseDelimitedFrom method.\n          .via(DecoderFlow.decodeTriples.asFlatTripleStream)\n          .runWith(Sink.seq)\n\n        Await.result(decodedTriplesFuture, 10.seconds)\n      }\n\n    println(s\"Decoded ${decodedTriples.size} triples\")\n\n    // -----------------------------------------------------------\n    // Now we will write the decoded triples to a new Jelly file\n    println(\"\\n\\nWriting the decoded triples to a new Jelly file with Pekko Streams...\")\n    Using.resource(new FileOutputStream(\"weather.jelly\")) { outputStream =&gt;\n      val writeFuture = Source(decodedTriples)\n        // Encode the triples to Jelly\n        .via(\n          EncoderFlow.builder\n            .withLimiter(ByteSizeLimiter(500))\n            .flatTriples(JellyOptions.SMALL_STRICT)\n            .flow,\n        )\n        // Write the Jelly frames to a Java byte stream.\n        // Under the hood it uses the RdfStreamFrame.writeDelimitedTo method.\n        .runWith(JellyIo.toIoStream(outputStream))\n\n      Await.ready(writeFuture, 10.seconds)\n      println(\"Done writing the Jelly file.\")\n    }\n\n    // -----------------------------------------------------------\n    // Pekko Streams offers its own utilities for reading and writing bytes that do not involve using Java's\n    // blocking implementation of streams.\n    // We will again write the decoded triples to a Jelly file, but this time use Pekko's facilities.\n    println(\"\\n\\nWriting the decoded triples to a new Jelly file with Pekko Streams' utilities...\")\n    val writeFuture = Source(decodedTriples)\n      .via(\n        EncoderFlow.builder\n          .withLimiter(ByteSizeLimiter(500))\n          .flatTriples(JellyOptions.SMALL_STRICT)\n          .flow,\n      )\n      // Convert the frames into Pekko's byte strings.\n      // Note: we are using the DELIMITED variant because we will write this to disk!\n      .via(JellyIo.toBytesDelimited)\n      .map(bytes =&gt; ByteString(bytes))\n      .runWith(FileIO.toPath(File(\"weather2.jelly\").toPath))\n\n    Await.ready(writeFuture, 10.seconds)\n    println(\"Done writing the Jelly file.\")\n\n    // -----------------------------------------------------------\n    // In the same way, we can read the Jelly file back using Pekko Streams.\n    // The advantage of this approach is that it is non-blocking and fully reactive, so you won't have\n    // blocked threads while waiting for the file to be read. You also don't need to worry about\n    // freeing resources, as Pekko Streams will handle that for you.\n    println(\"\\n\\nReading the Jelly file back with Pekko Streams (reactive parser)...\")\n    val readFuture = FileIO.fromPath(File(\"weather2.jelly\").toPath)\n      // Convert the byte strings to Jelly frames -- this will automatically detect the delimiters\n      // and re-chunk the stream if necessary.\n      .via(JellyIo.fromByteStringsDelimited())\n      // Decode the Jelly frames to triples.\n      .via(DecoderFlow.decodeTriples.asFlatTripleStream)\n      .runWith(Sink.seq)\n\n    val readTriples = Await.result(readFuture, 10.seconds)\n    println(s\"Read ${readTriples.size} triples from the Jelly file.\")\n\n    actorSystem.terminate()\n</code></pre>"},{"location":"user/reactive/#see-also","title":"See also","text":"<ul> <li>Using Jelly gRPC servers and clients</li> <li>Useful utilities<ul> <li>Using Typesafe config to configure Jelly</li> </ul> </li> <li>Low-level usage</li> </ul> <ol> <li> <p>There is no support for the Pekko Streams API in the <code>jelly-titanium-rdf-api</code> module. You will need to use a full RDF library like Jena or RDF4J to access it.\u00a0\u21a9</p> </li> </ol>"},{"location":"user/titanium/","title":"Titanium RDF API integration","text":"<p>The <code>jelly-titanium-rdf-api</code> module integrates Jelly with the minimalistic Titanium RDF API. This API is by itself not a fully-fledged RDF library, but is rather intended as an interoperability bridge. </p> <p>If you are already using Jena or RDF4J, you should use the <code>jelly-jena</code> or <code>jelly-rdf4j</code> module instead. This way you'll get better performance and more features.</p>"},{"location":"user/titanium/#installation","title":"Installation","text":"<p><code>jelly-titanium-rdf-api</code> is available on Maven Central. To include it in your project, add the following dependency to your <code>pom.xml</code>:</p> MavenGradleSBT pom.xml<pre><code>&lt;dependency&gt;\n    &lt;groupId&gt;eu.neverblink.jelly&lt;/groupId&gt;\n    &lt;artifactId&gt;jelly-titanium-rdf-api&lt;/artifactId&gt;\n    &lt;version&gt;3.5.2&lt;/version&gt;\n&lt;/dependency&gt;\n</code></pre> build.gradle<pre><code>dependencies {\n    implementation 'eu.neverblink.jelly:jelly-titanium-rdf-api:3.5.2'\n}\n</code></pre> build.sbt<pre><code>libraryDependencies += \"eu.neverblink.jelly\" % \"jelly-titanium-rdf-api\" % \"3.5.2\"\n</code></pre>"},{"location":"user/titanium/#basic-io-operations","title":"Basic I/O operations","text":"<p>The module implements a simple Jelly file reader and writer for Titanium. See the classes <code>eu.neverblink.jelly.convert.titanium.TitaniumJellyReader</code>  and <code>eu.neverblink.jelly.convert.titanium.TitaniumJellyWriter</code> . You should simply instantiate them using the <code>.factory</code> static method and then either push quads into the writer, or instruct the reader to push quads into another quad consumer.</p> <p>Full example of integration with the <code>titanium-rdf-n-quads</code> library:</p> Example: TitaniumRdfApi.java (click to expand) <p> Source code on GitHub</p> TitaniumRdfApi.java<pre><code>package eu.neverblink.jelly.examples;\n\nimport com.apicatalog.rdf.nquads.NQuadsReader;\nimport com.apicatalog.rdf.nquads.NQuadsWriter;\nimport eu.neverblink.jelly.convert.titanium.TitaniumJellyReader;\nimport eu.neverblink.jelly.convert.titanium.TitaniumJellyWriter;\nimport eu.neverblink.jelly.examples.shared.Example;\nimport java.io.*;\n\npublic class TitaniumRdfApi implements Example {\n\n    public static void main(String[] args) throws Exception {\n        new TitaniumRdfApi().run(args);\n    }\n\n    public void run(String[] args) throws Exception {\n        // Obtain the input file name (Jelly) and output file (N-Quads)\n        var inputFile = new File(getClass().getResource(\"/jelly/weather.jelly\").toURI());\n        var nquadsOutput = new File(\"weather-titanium.nq\");\n\n        System.out.println(\"Converting \" + inputFile + \" to \" + nquadsOutput + \" ...\");\n\n        // Open the I/O streams\n        try (var fis = new FileInputStream(inputFile); var fos = new FileWriter(nquadsOutput)) {\n            var jellyReader = TitaniumJellyReader.factory();\n            // Parse the entire Jelly file and immediately write the N-Quads to the output file\n            jellyReader.parseAll(new NQuadsWriter(fos), fis);\n        }\n\n        System.out.println(\"Conversion complete, N-Quads file saved.\");\n\n        // Now let's try the reverse \u2013 parse an N-Quads file and write it as Jelly\n        var nquadsInput = new File(\"weather-titanium.nq\");\n        var jellyOutput = new File(\"weather-titanium.jelly\");\n\n        System.out.println(\"Converting \" + nquadsInput + \" to \" + jellyOutput + \" ...\");\n\n        // Open the I/O streams\n        try (\n            var fis = new FileReader(nquadsInput);\n            var fos = new FileOutputStream(jellyOutput);\n            // IMPORTANT: the Jelly writer must be closed before the output stream is closed,\n            // otherwise the Jelly file will be incomplete. You can also do this manually with\n            // the jellyWriter.close() method.\n            var jellyWriter = TitaniumJellyWriter.factory(fos)\n        ) {\n            // Parse the entire N-Quads file and immediately write the Jelly to the output file\n            new NQuadsReader(fis).provide(jellyWriter);\n        }\n\n        System.out.println(\"Conversion complete, Jelly file saved.\");\n    }\n}\n</code></pre>"},{"location":"user/titanium/#low-level-usage","title":"Low-level usage","text":"<p>Titanium RDF API does not implement types for RDF primitives, so the Jelly integration with it is a bit different from the ones for Jena and RDF4J. Currently, the Pekko Streams API is not supported, and the <code>JellyConverterFactory</code> for Titanium is not part of the public API.</p> <p>But, you can still access a part of the low-level API directly. This would be useful if you wanted to integrate Titanium with Kafka or some other custom serialization pipeline.</p> <p>To do this, use the <code>eu.neverblink.jelly.convert.titanium.TitaniumJellyDecoder</code>  and <code>eu.neverblink.jelly.convert.titanium.TitaniumJellyEncoder</code>  classes directly.</p>"},{"location":"user/titanium/#integrations","title":"Integrations","text":"<p>Jelly-JVM implements the <code>RdfQuadConsumer</code> interface, so you can hook it up to any library that does the same. This includes formats like: JSON-LD, CBOR-LD, N-Quads.</p>"},{"location":"user/titanium/#see-also","title":"See also","text":"<ul> <li>Useful utilities</li> </ul>"},{"location":"user/utilities/","title":"Useful utilities","text":"<p>This guide presents some useful utilities in the <code>jelly-core</code> and <code>jelly-pekko-stream</code> modules.</p>"},{"location":"user/utilities/#jelly-options-presets","title":"Jelly options presets","text":"<p>Every Jelly stream begins with a header that specifies the serialization options used to encode the stream \u2013 see the details in the specification. So, whenever you serialize some RDF with Jelly (e.g., using Apache Jena RIOT, RDF4J Rio, or the <code>jelly-pekko-stream</code> module), you need to specify these options.</p> <p>The <code>eu.neverblink.jelly.core.JellyOptions</code>  object provides a few common presets for Jelly serialization options. They return an instance of <code>eu.neverblink.jelly.core.proto.v1.RdfStreamOptions</code>  that you can further customize. For example:</p> JavaScala Java example<pre><code>import eu.neverblink.jelly.core.JellyOptions;\n\nRdfStreamOptions options = JellyOptions.SMALL_STRICT;\n\nRdfStreamOptions optionsWithRdfStarSupport = JellyOptions.SMALL_RDF_STAR;\n\nRdfStreamOptions bigWithCustomDictionarySize = JellyOptions.BIG_STRICT\n  .clone()\n  .setMaxNameTableSize(2000);\n</code></pre> Scala example<pre><code>import eu.neverblink.jelly.core.JellyOptions\n\nval options = JellyOptions.SMALL_STRICT\n\nval optionsWithRdfStarSupport = JellyOptions.SMALL_RDF_STAR\n\nval bigWithCustomDictionarySize = JellyOptions.BIG_STRICT\n  .clone()\n  .setMaxNameTableSize(2000)  \n</code></pre> <p>Warning</p> <p>These presets do not specify the physical or logical stream type. In most cases, the Jelly library will take care of this for you and set these types automatically later. However, if you use the low-level API, you need to set the stream types manually. For example:</p> JavaScala Java example<pre><code>import eu.neverblink.jelly.core.JellyOptions;\nimport eu.neverblink.jelly.core.proto.v1.*;\n\nJellyOptions.SMALL_STRICT\n  .clone()\n  .setPhysicalType(PhysicalStreamType.QUADS)\n  .setLogicalType(LogicalStreamType.DATASETS);\n</code></pre> Scala example<pre><code>import eu.neverblink.jelly.core.JellyOptions\nimport eu.neverblink.jelly.core.proto.v1.*\n\nJellyOptions.SMALL_STRICT\n  .clone()\n  .setPhysicalType(PhysicalStreamType.QUADS)\n  .setLogicalType(LogicalStreamType.DATASETS)\n</code></pre>"},{"location":"user/utilities/#checking-supported-options","title":"Checking supported options","text":"<p>There is also the <code>eu.neverblink.jelly.core.JellyOptions.DEFAULT_SUPPORTED_OPTIONS</code>  field which specifies the maximum set of options supported by default in Jelly-JVM, when parsing a stream. By default, Jelly-JVM will refuse to parse any stream that uses options that are beyond what is specified in this method. This is important for security reasons, as it prevents the library from, for example, allocating a 10 GB dictionary (potential Denial of Service attack).</p> <p>The supported options check is carried out automatically by the decoder when parsing a stream. You cannot disable the check, but you can customize the supported options by constructing a new <code>RdfStreamOptions</code> object from <code>eu.neverblink.jelly.core.JellyOptions.DEFAULT_SUPPORTED_OPTIONS</code> , customizing it, and passing it to the decoder.</p> <p>If you want to do this kind of check in some other context (e.g., in a gRPC service to check if you can support the options requested by the client), you can use the <code>eu.neverblink.jelly.core.JellyOptions.checkCompatibility</code>  method. It will throw an exception if the options are not supported.</p>"},{"location":"user/utilities/#useful-constants","title":"Useful constants","text":"<p>The <code>eu.neverblink.jelly.core.JellyConstants</code>  object defines some useful constants, such as the file extension for Jelly, its content type, and the version of the Jelly protocol.</p>"},{"location":"user/utilities/#rdf-stream-taxonomy-rdf-stax-stream-type-utilities","title":"RDF Stream Taxonomy (RDF-STaX) stream type utilities","text":"<p>Jelly uses RDF-STaX to define the logical stream types (more details here). Jelly-JVM defines each of these types as a enum in <code>eu.neverblink.jelly.core.proto.v1.LogicalStreamType</code> .</p> <p>There are have a few useful methods for working with the RDF-STaX ontology:</p> JavaScala Java example<pre><code>import eu.neverblink.jelly.core.*;\nimport eu.neverblink.jelly.core.utils.LogicalStreamTypeUtils;\nimport eu.neverblink.jelly.core.proto.v1.LogicalStreamType;\n\n// Get the RDF-STaX IRI of a stream type\n// returns \"https://w3id.org/stax/ontology#flatTripleStream\"\nLogicalStreamTypeUtils.getRdfStaxType(LogicalStreamType.TRIPLES);\n</code></pre> Scala example<pre><code>import eu.neverblink.jelly.core.*\nimport eu.neverblink.jelly.core.utils.LogicalStreamTypeUtils\nimport eu.neverblink.jelly.core.proto.v1.LogicalStreamType\n\n// Get the RDF-STaX IRI of a stream type\n// returns \"https://w3id.org/stax/ontology#flatTripleStream\"\nLogicalStreamTypeUtils.getRdfStaxType(TRIPLES)\n</code></pre> <p>You can also obtain a full RDF-STaX annotation for your stream if you also import an RDF library interop module (e.g., <code>jelly-jena</code> or <code>jelly-rdf4j</code>):</p> JavaScala Java example<pre><code>import eu.neverblink.jelly.convert.jena.*;\nimport eu.neverblink.jelly.core.*;\nimport eu.neverblink.jelly.core.proto.v1.LogicalStreamType;\nimport org.apache.jena.graph.NodeFactory;\nimport org.apache.jena.datatypes.RDFDatatype;\nimport org.apache.jena.graph.Node;\nimport org.apache.jena.graph.Triple;\n\nJenaConverterFactory factory = JenaConverterFactory.getInstance(); // Jena converter factory\nNode subjectNode = NodeFactory.createURI(\"http://example.org/subject\");\nSeq&lt;Triple&gt; triples = LogicalStreamTypeUtils.getRdfStaxAnnotation&lt;&gt;(factory, LogicalStreamType.QUADS, subjectNode);\n// Returns a Seq of three triples that would look like this in Turtle:\n// &lt;http://example.org/subject&gt; stax:hasStreamTypeUsage [\n//   a stax:RdfStreamTypeUsage ;\n//   stax:hasStreamType stax:flatQuadStream\n// ] .\n</code></pre> Scala example<pre><code>import eu.neverblink.jelly.convert.jena.*\nimport eu.neverblink.jelly.core.*\nimport eu.neverblink.jelly.core.proto.v1.LogicalStreamType\nimport org.apache.jena.graph.NodeFactory\n\nval factory = JenaConverterFactory.getInstance() // Jena converter factory\n\nval subjectNode: Node = NodeFactory.createURI(\"http://example.org/subject\")\nval triples: Seq[Triple] = LogicalStreamTypeUtils.getRdfStaxAnnotation(factory, QUADS, subjectNode)\n// Returns a Seq of three triples that would look like this in Turtle:\n// &lt;http://example.org/subject&gt; stax:hasStreamTypeUsage [\n//   a stax:RdfStreamTypeUsage ;\n//   stax:hasStreamType stax:flatQuadStream\n// ] .\n</code></pre> <p>You can then take this annotation and expose as semantic metadata of your stream.</p> <p>You can also do the opposite and construct an instance of <code>LogicalStreamType</code> from an RDF-STaX IRI:</p> JavaScala Java example<pre><code>import eu.neverblink.jelly.core.LogicalStreamTypeUtils;\nimport eu.neverblink.jelly.core.proto.v1.LogicalStreamType;\n\nString iri = \"https://w3id.org/stax/ontology#flatQuadStream\";\n// returns LogicalStreamType.QUADS\nLogicalStreamType streamType = LogicalStreamTypeUtils.fromOntologyIri(iri);\n</code></pre> Scala example<pre><code>import eu.neverblink.jelly.core.LogicalStreamTypeUtils\n\nval iri = \"https://w3id.org/stax/ontology#flatQuadStream\"\n// returns LogicalStreamType.QUADS\nval streamType = LogicalStreamTypeUtils.fromOntologyIri(iri)\n</code></pre> <p>Finally, there are also stream type checking and manipulation utilities:</p> JavaScala Java example<pre><code>import eu.neverblink.jelly.core.utils.LogicalStreamTypeUtils;\nimport eu.neverblink.jelly.core.proto.v1.LogicalStreamType;\n\n// Check if this type is equal or a subtype of another type.\n// This is useful for performing compatibility checks.\n// Returns false\nLogicalStreamTypeUtils.isEqualOrSubtypeOf(LogicalStreamType.TRIPLES, LogicalStreamType.DATASETS);\n// Returns true\nLogicalStreamTypeUtils.isEqualOrSubtypeOf(LogicalStreamType.NAMED_GRAPHS, LogicalStreamType.DATASETS);\n\n// Get the \"base\" type of a stream type. Base types are concrete stream types\n// that have no parent types.\n// There are only 4 base types: GRAPHS, DATASETS, TRIPLES, QUADS.\n// Returns LogicalStreamType.TRIPLES\nLogicalStreamTypeUtils.toBaseType(LogicalStreamType.TRIPLES);\n// Returns LogicalStreamType.DATASETS\nLogicalStreamTypeUtils.toBaseType(LogicalStreamType.NAMED_GRAPHS);\n// Returns LogicalStreamType.DATASETS\nLogicalStreamTypeUtils.toBaseType(LogicalStreamType.TIMESTAMPED_NAMED_GRAPHS);\n</code></pre> Scala example<pre><code>import eu.neverblink.jelly.core.utils.LogicalStreamTypeUtils\nimport eu.neverblink.jelly.core.proto.v1.LogicalStreamType\n\n// Check if this type is equal or a subtype of another type.\n// This is useful for performing compatibility checks.\n// Returns false\nLogicalStreamTypeUtils.isEqualOrSubtypeOf(LogicalStreamType.TRIPLES, LogicalStreamType.DATASETS)\n// Returns true\nLogicalStreamTypeUtils.isEqualOrSubtypeOf(LogicalStreamType.NAMED_GRAPHS, LogicalStreamType.DATASETS)\n\n// Get the \"base\" type of a stream type. Base types are concrete stream types \n// that have no parent types. \n// There are only 4 base types: GRAPHS, DATASETS, TRIPLES, QUADS.\n// Returns LogicalStreamType.TRIPLES\nLogicalStreamTypeUtils.toBaseType(LogicalStreamType.TRIPLES)\n// Returns LogicalStreamType.DATASETS\nLogicalStreamTypeUtils.toBaseType(LogicalStreamType.NAMED_GRAPHS)\n// Returns LogicalStreamType.DATASETS\nLogicalStreamTypeUtils.toBaseType(LogicalStreamType.TIMESTAMPED_NAMED_GRAPHS)\n</code></pre>"},{"location":"user/utilities/#jelly-configuration-from-typesafe-config","title":"Jelly configuration from Typesafe config","text":"<p>The <code>jelly-pekko-stream</code> module also implements a utility for configuring Jelly serialization options using the Typesafe config library, which is commonly used in Apache Pekko applications.</p> <p>The utility is provided by the <code>eu.neverblink.jelly.pekko.stream.JellyOptionsFromTypesafe</code>  object. For example:</p> Scala example<pre><code>import com.typesafe.config.ConfigFactory\nimport eu.neverblink.jelly.stream.JellyOptionsFromTypesafe\n\nval config = ConfigFactory.parseString(\"\"\"\n  |jelly.physical-type = QUADS\n  |jelly.name-table-size = 1024\n  |jelly.prefix-table-size = 64\n  |\"\"\".stripMargin)\n\nval options = JellyOptionsFromTypesafe.fromConfig(config.getConfig(\"jelly\"))\noptions.physicalType // returns PhysicalStreamType.QUADS\noptions.maxNameTableSize // returns 1024\noptions.maxPrefixTableSize // returns 64\noptions.maxDatatypeTableSize // returns 16 (the default)\n</code></pre> <p>See the source code of this class for more details.</p>"},{"location":"user/utilities/#see-also","title":"See also","text":"<ul> <li>Reactive streaming with Jelly-JVM and Apache Pekko</li> <li>Low-level usage of Jelly-JVM</li> </ul>"}]}