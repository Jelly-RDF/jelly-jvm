
// Generated by Pekko gRPC. DO NOT EDIT.
package eu.neverblink.jelly.core.proto.v1

import scala.concurrent.ExecutionContext

import org.apache.pekko
import pekko.actor.ClassicActorSystemProvider

import pekko.grpc.GrpcChannel
import pekko.grpc.GrpcClientCloseException
import pekko.grpc.GrpcClientSettings

import pekko.grpc.scaladsl.PekkoGrpcClient

import pekko.grpc.internal.NettyClientUtils

import pekko.grpc.PekkoGrpcGenerated

import pekko.grpc.scaladsl.StreamResponseRequestBuilder
import pekko.grpc.internal.ScalaServerStreamingRequestBuilder
import pekko.grpc.scaladsl.SingleResponseRequestBuilder
import pekko.grpc.internal.ScalaClientStreamingRequestBuilder

// Not sealed so users can extend to write their stubs
@PekkoGrpcGenerated
trait RdfStreamServiceClient extends RdfStreamService with RdfStreamServiceClientPowerApi with PekkoGrpcClient

@PekkoGrpcGenerated
object RdfStreamServiceClient {
  def apply(settings: GrpcClientSettings)(implicit sys: ClassicActorSystemProvider): RdfStreamServiceClient =
    new DefaultRdfStreamServiceClient(GrpcChannel(settings), isChannelOwned = true)
  def apply(channel: GrpcChannel)(implicit sys: ClassicActorSystemProvider): RdfStreamServiceClient =
    new DefaultRdfStreamServiceClient(channel, isChannelOwned = false)

  private class DefaultRdfStreamServiceClient(channel: GrpcChannel, isChannelOwned: Boolean)(implicit sys: ClassicActorSystemProvider) extends RdfStreamServiceClient {
    import RdfStreamService.MethodDescriptors.*

    private implicit val ex: ExecutionContext = sys.classicSystem.dispatcher
    private val settings = channel.settings
    private val options = NettyClientUtils.callOptions(settings)


    private def subscribeRdfRequestBuilder(channel: pekko.grpc.internal.InternalChannel) =


      new ScalaServerStreamingRequestBuilder(subscribeRdfDescriptor, channel, options, settings)



    private def publishRdfRequestBuilder(channel: pekko.grpc.internal.InternalChannel) =


      new ScalaClientStreamingRequestBuilder(publishRdfDescriptor, channel, options, settings)





    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer subscribeRdf(eu.neverblink.jelly.core.proto.v1.RdfStreamSubscribe) if possible.
     */

    override def subscribeRdf(): StreamResponseRequestBuilder[eu.neverblink.jelly.core.proto.v1.RdfStreamSubscribe, eu.neverblink.jelly.core.proto.v1.RdfStreamFrame] =
      subscribeRdfRequestBuilder(channel.internalChannel)


    /**
     * For access to method metadata use the parameterless version of subscribeRdf
     */
    def subscribeRdf(in: eu.neverblink.jelly.core.proto.v1.RdfStreamSubscribe): org.apache.pekko.stream.scaladsl.Source[eu.neverblink.jelly.core.proto.v1.RdfStreamFrame, org.apache.pekko.NotUsed] =
      subscribeRdf().invoke(in)

    /**
     * Lower level "lifted" version of the method, giving access to request metadata etc.
     * prefer publishRdf(org.apache.pekko.stream.scaladsl.Source[eu.neverblink.jelly.core.proto.v1.RdfStreamFrame, org.apache.pekko.NotUsed]) if possible.
     */

    override def publishRdf(): SingleResponseRequestBuilder[org.apache.pekko.stream.scaladsl.Source[eu.neverblink.jelly.core.proto.v1.RdfStreamFrame, org.apache.pekko.NotUsed], eu.neverblink.jelly.core.proto.v1.RdfStreamReceived] =
      publishRdfRequestBuilder(channel.internalChannel)


    /**
     * For access to method metadata use the parameterless version of publishRdf
     */
    def publishRdf(in: org.apache.pekko.stream.scaladsl.Source[eu.neverblink.jelly.core.proto.v1.RdfStreamFrame, org.apache.pekko.NotUsed]): scala.concurrent.Future[eu.neverblink.jelly.core.proto.v1.RdfStreamReceived] =
      publishRdf().invoke(in)


    override def close(): scala.concurrent.Future[pekko.Done] =
      if (isChannelOwned) channel.close()
      else throw new GrpcClientCloseException()

    override def closed: scala.concurrent.Future[pekko.Done] = channel.closed()
  }
}

@PekkoGrpcGenerated
trait RdfStreamServiceClientPowerApi {

  /**
   * Lower level "lifted" version of the method, giving access to request metadata etc.
   * prefer subscribeRdf(eu.neverblink.jelly.core.proto.v1.RdfStreamSubscribe) if possible.
   */

  def subscribeRdf(): StreamResponseRequestBuilder[eu.neverblink.jelly.core.proto.v1.RdfStreamSubscribe, eu.neverblink.jelly.core.proto.v1.RdfStreamFrame] = ???


  /**
   * Lower level "lifted" version of the method, giving access to request metadata etc.
   * prefer publishRdf(org.apache.pekko.stream.scaladsl.Source[eu.neverblink.jelly.core.proto.v1.RdfStreamFrame, org.apache.pekko.NotUsed]) if possible.
   */

  def publishRdf(): SingleResponseRequestBuilder[org.apache.pekko.stream.scaladsl.Source[eu.neverblink.jelly.core.proto.v1.RdfStreamFrame, org.apache.pekko.NotUsed], eu.neverblink.jelly.core.proto.v1.RdfStreamReceived] = ???



}
