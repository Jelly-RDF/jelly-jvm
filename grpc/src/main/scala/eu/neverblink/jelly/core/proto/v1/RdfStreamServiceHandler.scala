
// Generated by Pekko gRPC. DO NOT EDIT.
package eu.neverblink.jelly.core.proto.v1

import scala.concurrent.ExecutionContext

import org.apache.pekko
import pekko.grpc.scaladsl.{ GrpcExceptionHandler, GrpcMarshalling }
import pekko.grpc.Trailers

import pekko.actor.ActorSystem
import pekko.actor.ClassicActorSystemProvider
import pekko.annotation.ApiMayChange
import pekko.http.scaladsl.model
import pekko.stream.{Materializer, SystemMaterializer}

import pekko.grpc.internal.TelemetryExtension

import pekko.grpc.PekkoGrpcGenerated




/*
 * Generated by Pekko gRPC. DO NOT EDIT.
 *
 * The API of this class may still change in future Pekko gRPC versions, see for instance
 * https://github.com/akka/akka-grpc/issues/994
 */
@ApiMayChange
@PekkoGrpcGenerated
object RdfStreamServiceHandler {
  private val notFound = scala.concurrent.Future.successful(model.HttpResponse(model.StatusCodes.NotFound))
  private val unsupportedMediaType = scala.concurrent.Future.successful(model.HttpResponse(model.StatusCodes.UnsupportedMediaType))

  /**
   * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
   * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
   *
   * Use `org.apache.pekko.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `RdfStreamServiceHandler.partial` when combining
   * several services.
   */
  def apply(implementation: RdfStreamService)(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
    partial(implementation).orElse { case _ => notFound }

  /**
   * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
   * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
   *
   * Use `org.apache.pekko.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `RdfStreamServiceHandler.partial` when combining
   * several services.
   */
  def apply(implementation: RdfStreamService, eHandler: ActorSystem => PartialFunction[Throwable, Trailers])(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
    partial(implementation, RdfStreamService.name, eHandler).orElse { case _ => notFound }

  /**
   * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
   * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
   *
   * Use `org.apache.pekko.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `RdfStreamServiceHandler.partial` when combining
   * several services.
   *
   * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
   */
  def apply(implementation: RdfStreamService, prefix: String)(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
    partial(implementation, prefix).orElse { case _ => notFound }

  /**
   * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
   * for the generated partial function handler and ends with `StatusCodes.NotFound` if the request is not matching.
   *
   * Use `org.apache.pekko.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `RdfStreamServiceHandler.partial` when combining
   * several services.
   *
   * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
   */
  def apply(implementation: RdfStreamService, prefix: String, eHandler: ActorSystem => PartialFunction[Throwable, Trailers])(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
    partial(implementation, prefix, eHandler).orElse { case _ => notFound }



  /**
   * Creates a `HttpRequest` to `HttpResponse` handler that can be used in for example `Http().bindAndHandleAsync`
   * for the generated partial function handler. The generated handler falls back to a reflection handler for
   * `RdfStreamService` and ends with `StatusCodes.NotFound` if the request is not matching.
   *
   * Use `org.apache.pekko.grpc.scaladsl.ServiceHandler.concatOrNotFound` with `RdfStreamServiceHandler.partial` when combining
   * several services.
   */
  def withServerReflection(implementation: RdfStreamService)(implicit system: ClassicActorSystemProvider): model.HttpRequest => scala.concurrent.Future[model.HttpResponse] =
    pekko.grpc.scaladsl.ServiceHandler.concatOrNotFound(
      RdfStreamServiceHandler.partial(implementation),
      pekko.grpc.scaladsl.ServerReflection.partial(List(RdfStreamService)))


  /**
   * Creates a partial `HttpRequest` to `HttpResponse` handler that can be combined with handlers of other
   * services with `org.apache.pekko.grpc.scaladsl.ServiceHandler.concatOrNotFound` and then used in for example
   * `Http().bindAndHandleAsync`.
   *
   * Use `RdfStreamServiceHandler.apply` if the server is only handling one service.
   *
   * Registering a gRPC service under a custom prefix is not widely supported and strongly discouraged by the specification.
   */
  def partial(implementation: RdfStreamService, prefix: String = RdfStreamService.name, eHandler: ActorSystem => PartialFunction[Throwable, Trailers] = GrpcExceptionHandler.defaultMapper)(implicit system: ClassicActorSystemProvider): PartialFunction[model.HttpRequest, scala.concurrent.Future[model.HttpResponse]] = {
    implicit val mat: Materializer = SystemMaterializer(system).materializer
    implicit val ec: ExecutionContext = mat.executionContext
    val spi = TelemetryExtension(system).spi

    import RdfStreamService.Serializers.*

    def handle(request: model.HttpRequest, method: String): scala.concurrent.Future[model.HttpResponse] =
      GrpcMarshalling.negotiated(request, (reader, writer) =>
        (method match {

          case "SubscribeRdf" =>

            GrpcMarshalling.unmarshal(request.entity)(RdfStreamSubscribeSerializer, mat, reader)
              .map(implementation.subscribeRdf(_))
              .map(e => GrpcMarshalling.marshalStream(e, eHandler)(RdfStreamFrameSerializer, writer, system))

          case "PublishRdf" =>

            GrpcMarshalling.unmarshalStream(request.entity)(RdfStreamFrameSerializer, mat, reader)
              .flatMap(implementation.publishRdf(_))
              .map(e => GrpcMarshalling.marshal(e, eHandler)(RdfStreamReceivedSerializer, writer, system))

          case m => scala.concurrent.Future.failed(new NotImplementedError(s"Not implemented: $m"))
        })
          .recoverWith(GrpcExceptionHandler.from(eHandler(system.classicSystem))(system, writer))
      ).getOrElse(unsupportedMediaType)

    Function.unlift((req: model.HttpRequest) => req.uri.path match {
      case model.Uri.Path.Slash(model.Uri.Path.Segment(`prefix`, model.Uri.Path.Slash(model.Uri.Path.Segment(method, model.Uri.Path.Empty)))) =>
        Some(handle(spi.onRequest(prefix, method, req), method))
      case _ =>
        None
    })
  }
}

