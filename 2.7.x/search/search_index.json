{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jelly-JVM","text":"<p>Jelly-JVM is an implementation of the Jelly serialization format and gRPC streaming protocol for the Java Virtual Machine (JVM), written in Scala 3<sup>1</sup>. The supported RDF libraries are Apache Jena and Eclipse RDF4J.</p> <p>Jelly-JVM provides a full stack of utilities for fast and scalable RDF streaming with the Jelly protocol. Oh, and it's blazing-fast, too!</p> <p>Getting started with plugins \u2013 no code required</p> <p>See the getting started guide with plugins for a quick way to use Jelly with your Apache Jena or RDF4J application without writing any code.</p> <p>Getting started for application developers</p> <p>If you want to use the full feature set of Jelly-JVM in your code, see the getting started guide for application developers.</p> <p>This documentation is for Jelly-JVM version 2.7.0, which uses the Jelly protocol version dev. If you are looking for the documentation of a different version, use the version selector on the left of the top navigation bar. See: latest stable version, latest development version.</p>"},{"location":"#library-modules","title":"Library modules","text":"<p>The implementation is split into a few modules that can be used separately:</p> <ul> <li> <p><code>jelly-core</code> \u2013 implementation of the Jelly serialization format (using the scalapb library), along with generic utilities for converting the deserialized RDF data to/from the representations of RDF libraries (like Apache Jena or RDF4J). </p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-jena</code> \u2013 conversions and interop code for the Apache Jena library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-rdf4j</code> \u2013 conversions and interop code for the RDF4J library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-stream</code> \u2013 utilities for building Reactive Streams of RDF data (based on Pekko Streams). Useful for integrating with gRPC or other streaming protocols (e.g., Kafka, MQTT).</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-grpc</code> \u2013 implementation of a gRPC client and server for the Jelly gRPC streaming protocol.</p> <ul> <li> </li> </ul> </li> </ul>"},{"location":"#plugin-jars","title":"Plugin JARs","text":"<p>We also publish plugin JARs which allow you to use Jelly-JVM with Apache Jena and RDF4J just by dropping the JARs into the classpath. Find out more about using the plugins.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>Jelly-JVM is compatible with Java 17 and newer. Java 17, 21, and 23 are tested in CI and are guaranteed to work. Jelly is built with Scala 3 LTS releases.</p> <p>The following table shows the compatibility of the Jelly-JVM implementation with other libraries:</p> Jelly-JVM Scala Java RDF4J Apache Jena Apache Pekko 2.0.x \u2013 2.7.x 3.3.x (LTS) 17+ 5.x.x 5.x.x 1.1.x 1.0.x 3.3.x (LTS)2.13.x<sup>1</sup> 11+ 4.x.x 4.x.x 1.0.x <p>See the compatibility policy for more details and the release notes on GitHub.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Below is a list of all documentation pages about Jelly-JVM. You can also browse the Javadoc using the badges in the module list above. The documentation uses examples written in Scala, but the libraries can be used from Java as well.</p> <ul> <li>Getting started with Jena/RDF4J plugins \u2013 how to use Jelly-JVM as a plugin for Apache Jena or RDF4J, without writing any code.</li> <li>Getting started for application developers \u2013 how to use Jelly-JVM in code.</li> <li>User guide<ul> <li>Apache Jena integration</li> <li>RDF4J integration</li> <li>Reactive streaming</li> <li>gRPC</li> <li>Useful utilities</li> <li>Compatibility policy</li> </ul> </li> <li>Developer guide<ul> <li>Releases</li> <li>Implementing Jelly for other libraries</li> </ul> </li> <li>Contributing to Jelly-JVM</li> <li>License and citation</li> <li>Release notes on GitHub</li> <li>Main Jelly website \u2013 including the Jelly protocol specification and explanation of the various stream types.</li> </ul>"},{"location":"#commercial-and-community-support","title":"Commercial and community support","text":"<p>NeverBlink provides commercial support services for Jelly, including implementing custom features, system integrations, implementations for new frameworks, benchmarking, and more.</p> <p>Community support is available on the Jelly Discord chat.</p> <ol> <li> <p>Scala 2.13-compatible builds of Jelly-JVM are available for Jelly-JVM 1.0.x. Scala 2 support was removed in subsequent versions. See more details.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"contributing/","title":"Contributing to Jelly-JVM","text":"<p>Jelly-JVM is an open project \u2013 you are welcome to submit issues, pull requests, or just ask questions!</p>"},{"location":"contributing/#user-developer-chat","title":"User &amp; developer chat","text":"<p>If you have any questions or want to discuss a feature, you can join the Jelly Discord chat.</p>"},{"location":"contributing/#submitting-issues","title":"Submitting issues","text":"<p>If you have a question, found a bug, or have an idea for a new feature, please open an issue in the GitHub issue tracker.</p>"},{"location":"contributing/#security-issues","title":"Security issues","text":"<p>If you find a security issue or vulnerability, please do not open a public issue. Instead, use the dedicated vulnerability reporting page.</p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Pull requests are welcome! Simply fork the GitHub repository and create a new branch for your changes. When you are ready, open a pull request to the <code>main</code> branch.</p> <p>If you are working on a larger feature or a significant change, it is recommended to open an issue first to discuss the idea.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Jelly-JVM uses the exact same documentation system as the main Jelly documentation. Further information on editing the documentation can be found in the Contributing to the Jelly documentation guide.</p>"},{"location":"contributing/#releases","title":"Releases","text":"<p>See the dedicated page on making releases.</p>"},{"location":"contributing/#see-also","title":"See also","text":"<ul> <li>Licensing and citation</li> </ul>"},{"location":"getting-started-devs/","title":"Jelly-JVM \u2013 getting started for developers","text":"<p>If you don't want to code anything and only use Jelly with your Apache Jena/RDF4J application, see the dedicated guide about using Jelly-JVM as a plugin.</p> <p>This guide explains a few of the basic functionalities of Jelly-JVM and how to use them in your code. Jelly-JVM is written in Scala, but it can be used from Java as well. However, in this guide, we will focus on Scala 3.</p>"},{"location":"getting-started-devs/#quick-start-plain-old-files","title":"Quick start \u2013 plain old files","text":"<p>Depending on your RDF library of choice (Apache Jena or RDF4J), you should import one of two dependencies: <code>jelly-jena</code> or <code>jelly-rdf4j</code><sup>1</sup>. In our examples we will use Jena, so let's add this to your <code>build.sbt</code> file (this would be the same for other build tools like Maven or Gradle):</p> build.sbt<pre><code>lazy val jellyVersion = \"2.7.0\"\n\nlibraryDependencies ++= Seq(\n  \"eu.ostrzyciel.jelly\" %% \"jelly-jena\" % jellyVersion,\n)\n</code></pre> <p>Now you can serialize/deserialize Jelly data with Apache Jena. Jelly is fully integrated with Jena, so it should all just magically work. Here is a simple example of reading a <code>.jelly</code> file (in this case, a metadata file from RiverBench) with RIOT:</p> Deserialization example (Scala 3)<pre><code>import eu.ostrzyciel.jelly.convert.jena.riot.*\nimport org.apache.jena.riot.RDFDataMgr\n\n// Load an RDF graph from a Jelly file\nval model = RDFDataMgr.loadModel(\n  \"https://w3id.org/riverbench/v/2.0.1.jelly\", \n  JellyLanguage.JELLY\n)\n// Print the size of the model\nprintln(s\"Loaded an RDF graph with ${model.size} triples\")\n</code></pre> <p>Serialization is just as easy:</p> Serialization example (Scala 3)<pre><code>import eu.ostrzyciel.jelly.convert.jena.riot.*\nimport org.apache.jena.riot.RDFDataMgr\n\nimport java.io.FileOutputStream\nimport scala.util.Using\n\n// Omitted here: creating an RDF model.\n// You can use the one from the previous example.\n\nUsing.resource(new FileOutputStream(\"metadata.jelly\")) { out =&gt;\n  // Write the model to a Jelly file\n  RDFDataMgr.write(out, model, JellyLanguage.JELLY)\n  println(\"Saved the model to metadata.jelly\")\n}\n</code></pre> <p> Read more about using Jelly-JVM with Apache Jena</p> <p> Read more about using Jelly-JVM with RDF4J</p>"},{"location":"getting-started-devs/#rdf-streams","title":"RDF streams","text":"<p>Now, the real power of Jelly lies in its streaming capabilities. Not only can it stream individual RDF triples/quads (this is called flat streaming), but it can also very effectively handle streams of RDF graphs or datasets. To work with streams, you need to use the <code>jelly-stream</code> module, which is based on the Apache Pekko Streams library. So, let's update our dependencies:</p> build.sbt<pre><code>lazy val jellyVersion = \"2.7.0\"\n\nlibraryDependencies ++= Seq(\n  \"eu.ostrzyciel.jelly\" %% \"jelly-jena\" % jellyVersion,\n  \"eu.ostrzyciel.jelly\" %% \"jelly-stream\" % jellyVersion,\n)\n</code></pre> <p>Now, let's say we have a stream of RDF graphs \u2013 for example each graph corresponds to one set of measurements from an IoT sensor. We want to have a stream that turns these graphs into their serialized representations (byte arrays), which we can then send over the network. Here is how to do it:</p> Reactive streaming example (Scala 3)<pre><code>// We need to import \"jena.given\" for Jena-to-Jelly conversions\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.convert.jena.riot.*\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.stream.*\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport scala.concurrent.ExecutionContext\n\n// We will need a Pekko actor system to run the streams\ngiven actorSystem: ActorSystem = ActorSystem()\n// And an execution context for the futures\ngiven ExecutionContext = actorSystem.getDispatcher\n\n// Load an RDF graph for testing\nval model = RDFDataMgr.loadModel(\n  \"https://w3id.org/riverbench/v/2.0.1.jelly\", \n  JellyLanguage.JELLY\n)\n\nSource.repeat(model) // Create a stream of the same model over and over\n  .take(10) // Take only the first 10 elements in the stream\n  .map(_.asTriples) // Convert each model to an iterable of triples\n  .via(EncoderFlow.graphStream( // Encode each iterable to a Jelly stream frame\n    maybeLimiter = None, // 1 RDF graph = 1 message\n    JellyOptions.smallStrict, // Jelly compression settings preset\n  ))\n  .via(JellyIo.toBytes) // Convert the stream frames to a byte arrays\n  .runForeach { bytes =&gt;\n    // Just print the length of each byte array in the stream.\n    // You can also hook this up to MQTT, Kafka, etc.\n    println(s\"Streamed ${bytes.length} bytes\")\n  }\n  .onComplete(_ =&gt; actorSystem.terminate())\n</code></pre> <p>Jelly will compress this stream on-the-fly, so if the data is repetitive, it will be very efficient. If you run this code, you will notice that the byte sizes for the later graphs are smaller, even though we are sending the same graph over and over again. But, even if each graph is completely different, Jelly still should be much faster than other serialization formats.</p> <p>These streams are very powerful, because they are reactive and asynchronous \u2013 in short, this means you can hook this up to any data source and any data sink \u2013 and you can scale it up as much as you want. If you are unfamiliar with the concept of reactive streams, we recommend you start with this Apache Pekko Streams guide.</p> <p>Jelly-JVM supports streaming serialization and deserialization of all types of streams in the RDF Stream Taxonomy. You can read more about the theory of this and all available stream types in the Jelly protocol documentation.</p> <p> Learn more about reactive streaming with Jelly-JVM</p> <p> Learn more about the types of streams in Jelly</p>"},{"location":"getting-started-devs/#grpc-streaming","title":"gRPC streaming","text":"<p>Jelly is a bit more than just a serialization format \u2013 it also defines a gRPC-based straming protocol. You can use it for streaming RDF data between microservices, to build a pub/sub system, or to publish RDF data to the web.</p> <p> Learn more about using Jelly gRPC protocol servers and clients</p>"},{"location":"getting-started-devs/#further-reading","title":"Further reading","text":"<ul> <li>Using Jelly-JVM with Apache Jena</li> <li>Using Jelly-JVM with RDF4J</li> <li>Reactive streaming with Jelly-JVM \u2013 using the <code>jelly-stream</code> module and Apache Pekko Streams</li> <li>Using Jelly gRPC protocol servers and clients</li> <li>Other useful utilities in Jelly-JVM</li> <li>Low-level usage of Jelly-JVM</li> </ul>"},{"location":"getting-started-devs/#example-applications-using-jelly-jvm","title":"Example applications using Jelly-JVM","text":"<ul> <li>The <code>examples</code> directory in the Jelly-JVM repo contains code snippets that demonstrate how to use the library in various scenarios.</li> <li>Jelly JVM benchmarks \u2013 research software for testing the performance of Jelly-JVM and other RDF serializations in Apache Jena. It uses most Jelly-JVM features.</li> <li>RiverBench ci-worker \u2013 a real-world application that is used for processing large RDF datasets in a CI/CD pipeline. It uses Jelly-JVM for serialization and deserialization with Apache Jena. It also uses extensively Apache Pekko Streams.</li> </ul>"},{"location":"getting-started-devs/#questions","title":"Questions?","text":"<p>If you have any questions about using Jelly-JVM, feel free to open an issue on GitHub.</p> <ol> <li> <p>There is nothing stopping you from using both at the same time. You can also pretty easily add support for any other Java-based RDF library by implementing a few interfaces. More details here.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started-plugins/","title":"Jelly-JVM \u2013 getting started with Jena/RDF4J plugins","text":"<p>This guide explains how to use Jelly-JVM with Apache Jena or RDF4J as a plugin, without writing a single line of code. Jelly-JVM provides plugin JARs that you can simply drop in the appropriate directory to get Jelly format support in your application.</p>"},{"location":"getting-started-plugins/#installation","title":"Installation","text":""},{"location":"getting-started-plugins/#apache-jena-apache-jena-fuseki","title":"Apache Jena, Apache Jena Fuseki","text":"<p>You can simply add Jelly format support to Apache Jena or Apacha Jena Fuseki with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  version 2.7.0 from here,  or you can go the the releases page on GitHub to download a different version of the <code>jelly-jena-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your Apache Jena version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath:<ul> <li>For Apache Jena Fuseki, simply place the file in <code>$FUSEKI_BASE/extra/</code> directory. <code>$FUSEKI_BASE</code> is the directory usually called <code>run</code> where you have files such as <code>config.ttl</code> and <code>shiro.ini</code>. You will most likely need to create the <code>extra</code> directory yourself.</li> <li>For Apache Jena, place the file in the <code>lib/</code> directory of your Jena installation.</li> <li>For other applications, consult the manual of the application.</li> </ul> </li> <li>You can now use the Jelly format for parsing, serialization, and streaming serialization in your Jena application.</li> </ul> <p>Content negotiation in Fuseki</p> <p>Content negotiation using the <code>application/x-jelly-rdf</code> media type in the <code>Accept</code> header works in Fuseki since Apache Jena version 5.2.0. Previous versions of Fuseki did not support media type registration.</p> <p>How to use Jelly with Jena's CLI tools?</p> <p>Jelly-JVM fully supports Apache Jena's command-line interface (CLI) utilities. See the dedicated guide for more information.</p>"},{"location":"getting-started-plugins/#eclipse-rdf4j","title":"Eclipse RDF4J","text":"<p>You can simply add Jelly format support to an application based on RDF4J with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  version 2.7.0 from here,  or you can go the the releases page on GitHub to download a specific version of the <code>jelly-rdf4j-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your RDF4J version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath:<ul> <li>For the RDF4J SDK distribution, place the file in the <code>lib/</code> directory of your RDF4J installation.</li> <li>For other applications, consult the manual of your application for the exact location.</li> </ul> </li> <li>You can now use the Jelly format for parsing and serialization in your RDF4J application.</li> </ul>"},{"location":"getting-started-plugins/#supported-features","title":"Supported features","text":"<p>The Jelly-JVM plugin JARs provide the following features:</p> <ul> <li>Full support for parsing and serialization of RDF data (triples and quads) in the Jelly format.<ul> <li>The parser will automatically detect if the input data is delimited or not. Both delimited and non-delimited Jelly data can be parsed.</li> <li>In Apache Jena also the stream serialization is supported.</li> </ul> </li> <li>Recognizing the <code>.jelly</code> file extension.</li> <li>Recognizing the <code>application/x-jelly-rdf</code> media type.</li> </ul> <p>The Jelly format is registered under the name <code>jelly</code> in the RDF libraries, so you can use it in the same way as other formats like Turtle, RDF/XML, or JSON-LD.</p>"},{"location":"getting-started-plugins/#see-also","title":"See also","text":"<ul> <li>Getting started for developers \u2013 if you want to get your hands dirty with code and get more features out of Jelly.</li> </ul>"},{"location":"licensing/","title":"Licensing and citation","text":"<p>Jelly-JVM is licensed under the Apache License 2.0.</p>"},{"location":"licensing/#attribution-citation","title":"Attribution / citation","text":"<p>If you use Jelly-JVM in your research, please the most recent paper about Jelly:</p> <p>Sowi\u0144ski, P., Wasielewska-Michniewska, K., Ganzha, M., &amp; Paprzycki, M. (2022, October). Efficient RDF streaming for the edge-cloud continuum. In 2022 IEEE 8th World Forum on Internet of Things (WF-IoT) (pp. 1-8). IEEE.</p> <p>Or use this BibTeX entry:</p> <pre><code>@inproceedings{sowinski2022efficient,\n  title={Efficient RDF streaming for the edge-cloud continuum},\n  author={Sowi{\\'n}ski, Piotr and Wasielewska-Michniewska, Katarzyna and Ganzha, Maria and Paprzycki, Marcin and others},\n  booktitle={2022 IEEE 8th World Forum on Internet of Things (WF-IoT)},\n  pages={1--8},\n  year={2022},\n  organization={IEEE},\n  doi={10.1109/WF-IoT54382.2022.10152225}\n}\n</code></pre> <p>This paper describes an earlier version of Jelly from 2022. A new paper is in preparation.</p>"},{"location":"licensing/#jelly-maintainer","title":"Jelly maintainer","text":"<p>Jelly-JVM was created and is maintained by Piotr Sowi\u0144ski (Ostrzyciel) \u2013 GitHub.</p>"},{"location":"licensing/#see-also","title":"See also","text":"<ul> <li>Contributing to Jelly-JVM</li> </ul>"},{"location":"dev/implementing/","title":"Developer guide \u2013 implementing conversions for other libraries","text":"<p>Currently converters for the two most popular RDF JVM libraries are implemented \u2013 RDF4J and Jena. But it is possible to implement your own converters and adapt the Jelly serialization code to any RDF library with little effort.</p> <p>To do this, you will need to implement three traits (interfaces in Java) from the <code>jelly-core</code> module: <code>ProtoEncoderConverter</code>, <code>ProtoDecoderConverter</code>, and <code>ConverterFactory</code>.</p> <ul> <li> <p>ProtoEncoderConverter (serialization)</p> <ul> <li><code>get*</code> methods deconstruct triple and quad statements.</li> <li><code>nodeToProto</code> and <code>graphToProto</code> should translate into Jelly's representation all possible variations of RDF terms in the SPO and G positions, respectively.</li> <li>Example implementation for Jena: JenaEncoderConverter</li> <li>You can skip implementing this trait if you don't need serialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads.</li> </ul> </li> <li> <p>ProtoDecoderConverter (deserialization)</p> <ul> <li>The <code>make*</code> methods should construct new RDF terms and statements. You can make them <code>inline</code>.</li> <li>Example implementation for Jena: JenaDecoderConverter</li> <li>You can skip implementing this trait if you don't need deserialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-star.</li> </ul> </li> <li> <p>ConverterFactory \u2013 wrapper that allows other modules to use your converter.</p> <ul> <li>The methods should just return new instances (or singletons, if appropriate for your use case) of your <code>ProtoEncoderConverter</code> and <code>ProtoDecoderConverter</code> implementations.</li> <li>Example for Jena: JenaConverterFactory</li> </ul> </li> </ul>"},{"location":"dev/releases/","title":"Developer guide \u2013 releases","text":""},{"location":"dev/releases/#full-versioned-releases","title":"Full (versioned) releases","text":"<p>Full (versioned) releases are created manually and follow the Semantic Versioning scheme for binary compatibility.</p> <p>To create a new tagged release (example for version 1.2.3): <pre><code>$ git checkout main\n$ git pull\n$ git tag v1.2.3\n$ git push origin v1.2.3\n</code></pre></p> <p>The rest (packaging and release creation) will be handled automatically by the CI. The release will be pushed to Maven Central.</p>"},{"location":"dev/releases/#snapshot-releases","title":"Snapshot releases","text":"<p>Snapshot releases are triggered automatically by commits in the <code>main</code> branch. Snapshots are pushed to the Sonatype snapshot repository.</p>"},{"location":"user/compatibility/","title":"Compatibility policy","text":"<p>Jelly-JVM follows Semantic Versioning 2.0.0, with MAJOR.MINOR.PATCH releases. Please see the compatibility table on the main page for the current compatibility information. The documentation is versioned to match each Jelly-JVM MAJOR.MINOR version.</p>"},{"location":"user/compatibility/#jvm-and-scala","title":"JVM and Scala","text":"<p>The current version of Jelly-JVM is compatible with Java 17 and newer. Java 17, 21, and 23 are tested in CI and are guaranteed to work. We recommend using a recent release of GraalVM to get the best performance. If you need Java 11 support, you should use Jelly-JVM 1.0.x.</p> <p>Jelly is built with Scala 3 LTS releases and supports only Scala 3. If you need Scala 2 support, you should use Jelly-JVM 1.0.x.</p>"},{"location":"user/compatibility/#rdf-libraries","title":"RDF libraries","text":"<p>Major-version upgrades of RDF4J and Apache Jena (e.g., updating from 4.0.x to 5.0.x) are done in Jelly-JVM MINOR releases. Jelly-JVM generally does not use any complex features of these libraries, so it should work with multiple versions without any problems.</p> <p>If you do encounter any compatibility issues, please report them on the issue tracker.</p>"},{"location":"user/compatibility/#internal-vs-external-apis","title":"Internal vs external APIs","text":"<p>Generally, all public classes and methods in Jelly-JVM are considered part of the public API. However, there are some exceptions.</p> <p>Auto-generated classes in the <code>jelly-core</code> module, <code>eu.ostrzyciel.jelly.core.proto.v1</code> package are not considered part of the public API, although we will avoid any incompatibilities where possible. These classes may change between MINOR releases.</p>"},{"location":"user/compatibility/#backward-and-forward-protocol-compatibility","title":"Backward and forward protocol compatibility","text":"<p>Jelly-JVM follows the Jelly protocol's backward compatibility policy. This means that Jelly-JVM can read data serialized with older versions of Jelly. Backward compatibility is tested in CI \u2013 the code is in BackCompatSpec.scala.</p> <p>Forward compatibility is provided only in a very limited manner in Jelly-JVM. The parser is guaranteed to only parse the stream options header and reject the rest of the stream, if the used protocol version is not supported. You may choose to disable this check and try to parse the rest of the data anyway, but this is most certainly NOT recommended and may lead to unexpected results. In general, Jelly-JVM will ignore any unknown fields in the stream, but any other changes in the protocol may lead to really \"funny\" errors. Forward compatibility is tested in CI \u2013 the code is in ForwardCompatSpec.scala.</p>"},{"location":"user/compatibility/#see-also","title":"See also","text":"<ul> <li>Release notes on GitHub</li> <li>Making Jelly-JVM releases</li> <li>Contributing to Jelly-JVM</li> </ul>"},{"location":"user/grpc/","title":"User guide \u2013 gRPC","text":"<p>This guide explains the functionalities of the <code>jelly-grpc</code> module, which implements a gRPC client and server for the Jelly gRPC streaming protocol.</p> <p>Prerequisites</p> <p>If you are unfamiliar with gRPC, we recommend you first read some introductory material on the gRPC website or in the Apache Pekko gRPC documentation.</p> <p>The <code>jelly-grpc</code> module builds on the functionalities of <code>jelly-stream</code>, so we recommend you first read the reactive streaming guide.</p> <p>You may also want to first skim the Jelly gRPC streaming protocol specification to understand the protocol's structure.</p> <p>As with the <code>jelly-stream</code> module, you can use <code>jelly-grpc</code> with any RDF library that has a Jelly integration, such as Apache Jena (using <code>jelly-jena</code>) or RDF4J (using <code>jelly-rdf4j</code>). The gRPC API is generic and identical across all libraries.</p>"},{"location":"user/grpc/#making-a-grpc-server-and-client","title":"Making a gRPC server and client","text":"<p><code>jelly-grpc</code> builds on the Apache Pekko gRPC library. Jelly-JVM provides boilerplate code for setting up a gRPC server and client that can send and receive Jelly streams, as shown in the example below:</p> Example: PekkoGrpc.scala (click to expand) <p> Source code on GitHub</p> PekkoGrpc.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport com.typesafe.config.ConfigFactory\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.core.proto.v1.*\nimport eu.ostrzyciel.jelly.grpc.RdfStreamServer\nimport eu.ostrzyciel.jelly.stream.*\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.NotUsed\nimport org.apache.pekko.actor.typed.ActorSystem\nimport org.apache.pekko.actor.typed.javadsl.Behaviors\nimport org.apache.pekko.grpc.{GrpcClientSettings, GrpcServiceException}\nimport org.apache.pekko.stream.scaladsl.*\n\nimport java.io.File\nimport scala.concurrent.{Await, ExecutionContext, Future}\nimport scala.concurrent.duration.*\nimport scala.util.{Failure, Success}\n\n/**\n * Example of using Jelly's gRPC client and server to send Jelly streams over the network.\n * This uses the Apache Pekko gRPC library. Its documentation can be found at:\n * https://pekko.apache.org/docs/pekko-grpc/current/index.html\n * \n * See also examples named `PekkoStreams*` for instructions on encoding and decoding RDF streams with Jelly.\n *\n * In this example we are using Apache Jena as the RDF library (note the import:\n * `import eu.ostrzyciel.jelly.convert.jena.given`).\n * The same can be achieved with RDF4J just by importing a different module.\n */\nobject PekkoGrpc extends shared.Example:\n  // Create a config for Pekko gRPC.\n  // We can use the same config for the client and the server, as we are communicating on localhost.\n  // This would usually be loaded from a configuration file (e.g., application.conf).\n  // More details: https://github.com/lightbend/config\n  val config = ConfigFactory.parseString(\n      \"\"\"\n        |pekko.http.server.preview.enable-http2 = on\n        |pekko.grpc.client.jelly.host = 127.0.0.1\n        |pekko.grpc.client.jelly.port = 8088\n        |pekko.grpc.client.jelly.enable-gzip = true\n        |pekko.grpc.client.jelly.use-tls = false\n        |pekko.grpc.client.jelly.backend = netty\n        |\"\"\".stripMargin\n    )\n    .withFallback(ConfigFactory.defaultApplication())\n\n  // We will need two Pekko actor systems to run the streams \u2013 one for the server and one for the client\n  val serverActorSystem: ActorSystem[_] = ActorSystem(Behaviors.empty, \"ServerSystem\")\n  val clientActorSystem: ActorSystem[_] = ActorSystem(Behaviors.empty, \"ClientSystem\", config)\n\n  // Our mock dataset that we will send around in the streams\n  val dataset = RDFDataMgr.loadDataset(File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString)\n\n\n  /**\n   * Main method that starts the server and the client.\n   */\n  def main(args: Array[String]): Unit =\n    given system: ActorSystem[_] = serverActorSystem\n    given ExecutionContext = system.executionContext\n\n    // Start the server\n    val exampleService = ExampleJellyService()\n    RdfStreamServer(\n      RdfStreamServer.Options.fromConfig(config.getConfig(\"pekko.grpc.client.jelly\")),\n      exampleService\n    ).run() onComplete {\n      case Success(binding) =&gt;\n        // If the server started successfully, start the client\n        println(s\"[SERVER] Bound to ${binding.localAddress}\")\n        runClient()\n      case Failure(exception) =&gt;\n        // Otherwise, print the error and terminate the actor system\n        println(s\"[SERVER] Failed to bind: $exception\")\n        system.terminate()\n    }\n\n\n  /**\n   * The client part of the example.\n   */\n  private def runClient(): Unit =\n    given system: ActorSystem[_] = clientActorSystem\n    given ExecutionContext = system.executionContext\n\n    // Create a gRPC client\n    val client = RdfStreamServiceClient(GrpcClientSettings.fromConfig(\"jelly\"))\n\n    // First, let's try to publish some data to the server\n    val frameSource = RdfSource.builder.datasetAsQuads(dataset).source\n      // Encode the dataset as a stream of QUADS\n      .via(EncoderFlow.builder\n        .withLimiter(ByteSizeLimiter(500))\n        .flatQuads(JellyOptions.smallStrict.withStreamName(\"weather\"))\n        .flow\n      )\n\n    println(\"[CLIENT] Publishing data to the server...\")\n    val publishFuture = client.publishRdf(frameSource) map { response =&gt;\n      println(s\"[CLIENT] Received acknowledgment: $response\")\n    } recover {\n      case e =&gt;\n        println(s\"[CLIENT] Failed to publish data: $e\")\n    }\n    // Wait for the publish to complete\n    Await.ready(publishFuture, 10.seconds)\n\n    // Now, let's try to subscribe to some data from the server in the QUADS format\n    println(\"\\n\\n[CLIENT] Subscribing to QUADS data from the server...\")\n    val quadsFuture = client\n      .subscribeRdf(RdfStreamSubscribe(\n        \"weather\",\n        Some(JellyOptions.smallStrict.withPhysicalType(PhysicalStreamType.QUADS))\n      ))\n      .via(DecoderFlow.decodeQuads.asFlatQuadStreamStrict)\n      .runFold(0L)((acc, _) =&gt; acc + 1)\n      // Process the result of the stream (Future[Long])\n      .map { counter =&gt;\n        println(s\"[CLIENT] Received $counter quads.\")\n      } recover {\n        case e =&gt;\n          println(s\"[CLIENT] Failed to receive quads: $e\")\n      }\n    Await.ready(quadsFuture, 10.seconds)\n\n    // Let's try the same, with a GRAPHS stream\n    println(\"\\n\\n[CLIENT] Subscribing to GRAPHS data from the server...\")\n    val graphsFuture = client\n      .subscribeRdf(RdfStreamSubscribe(\n        \"weather\",\n        Some(JellyOptions.smallStrict.withPhysicalType(PhysicalStreamType.GRAPHS))\n      ))\n      // Decode the response and transform it into a stream of quads\n      .via(DecoderFlow.decodeGraphs.asDatasetStreamOfQuads)\n      .mapConcat(identity)\n      .runFold(0L)((acc, _) =&gt; acc + 1)\n      // Process the result of the stream (Future[Long])\n      .map { counter =&gt;\n        println(s\"[CLIENT] Received $counter quads.\")\n      } recover {\n        case e =&gt;\n          println(s\"[CLIENT] Failed to receive data: $e\")\n      }\n    Await.ready(graphsFuture, 10.seconds)\n\n    // Finally, let's try to subscribe to a stream that the server does not support\n    // We will request TRIPLES, but the server only supports QUADS and GRAPHS.\n    println(\"\\n\\n[CLIENT] Subscribing to TRIPLES data from the server...\")\n    val triplesFuture = client\n      .subscribeRdf(RdfStreamSubscribe(\n        \"weather\",\n        Some(JellyOptions.smallStrict.withPhysicalType(PhysicalStreamType.TRIPLES))\n      ))\n      .via(DecoderFlow.decodeTriples.asFlatTripleStream)\n      .runFold(0L)((acc, _) =&gt; acc + 1)\n      .map { counter =&gt;\n        println(s\"[CLIENT] Received $counter triples.\")\n      } recover {\n        case e =&gt;\n          println(s\"[CLIENT] Failed to receive triples: $e\")\n      }\n    Await.result(triplesFuture, 10.seconds)\n\n    println(\"\\n\\n[CLIENT] Terminating...\")\n    system.terminate()\n    println(\"[SERVER] Terminating...\")\n    serverActorSystem.terminate()\n\n\n  /**\n   * Example implementation of RdfStreamService to act as the server.\n   * \n   * You will also need to implement this trait in your own service. It defines the logic with which the server\n   * will handle incoming streams and subscriptions.\n   */\n  class ExampleJellyService(using system: ActorSystem[_]) extends RdfStreamService:\n    given ExecutionContext = system.executionContext\n\n    /**\n     * Handler for clients publishing RDF streams to the server.\n     * \n     * We receive a stream of RdfStreamFrames and must respond with an acknowledgment (or an error).\n     */\n    override def publishRdf(in: Source[RdfStreamFrame, NotUsed]): Future[RdfStreamReceived] =\n      // Decode the incoming stream and count the number of RDF statements in it\n      in.via(DecoderFlow.decodeAny.asFlatStream)\n        .runFold(0L)((acc, _) =&gt; acc + 1)\n        .map(counter =&gt; {\n          println(s\"[SERVER] Received ${counter} RDF statements. Sending acknowledgment.\")\n          // Send an acknowledgment back to the client\n          RdfStreamReceived()\n        })\n\n    /**\n     * Handler for clients subscribing to RDF streams from the server.\n     * \n     * We receive a subscription request and must respond with a stream of RdfStreamFrames or an error.\n     */\n    override def subscribeRdf(in: RdfStreamSubscribe): Source[RdfStreamFrame, NotUsed] =\n      println(s\"[SERVER] Received subscription request for topic ${in.topic}.\")\n      // First, check the requested physical stream type\n      val streamType = in.requestedOptions match\n        case Some(options) =&gt;\n          println(s\"[SERVER] Requested physical stream type: ${options.physicalType}.\")\n          options.physicalType\n        case None =&gt;\n          println(s\"[SERVER] No requested stream options.\")\n          PhysicalStreamType.UNSPECIFIED\n\n      // Get the stream options requested by the client or the default options if none were provided\n      val options = in.requestedOptions.getOrElse(JellyOptions.smallStrict)\n        .withStreamName(in.topic)\n      // Check if the requested options are supported\n      // !!! THIS IS IMPORTANT !!!\n      // If you don't check if the requested options are supported, you may be vulnerable to\n      // denial-of-service attacks. For example, a client could request a very large lookup table\n      // that would consume a lot of memory on the server.\n      try\n        JellyOptions.checkCompatibility(options, JellyOptions.defaultSupportedOptions)\n      catch\n        case e: IllegalArgumentException =&gt;\n          // If the requested options are not supported, return an error\n          return Source.failed(new GrpcServiceException(\n            io.grpc.Status.INVALID_ARGUMENT.withDescription(e.getMessage)\n          ))\n\n      streamType match\n        // This server implementation only supports QUADS and GRAPHS streams... and in both cases\n        // it will always the same dataset.\n        // You can of course implement more complex logic here, e.g., to stream different data based on the topic.\n        case PhysicalStreamType.QUADS =&gt; RdfSource.builder.datasetAsQuads(dataset).source\n          .via(EncoderFlow.builder\n            .withLimiter(ByteSizeLimiter(16_000))\n            .flatQuads(options)\n            .flow\n          )\n        case PhysicalStreamType.GRAPHS =&gt; RdfSource.builder.datasetAsGraphs(dataset).source\n          .via(EncoderFlow.builder\n            .withLimiter(StreamRowCountLimiter(30))\n            .namedGraphs(options)\n            .flow\n          )\n        // PhysicalStreamType.TRIPLES is not supported here \u2013 the server will throw a gRPC error\n        // if the client requests it.\n        // This is an example of how to properly handle unsupported stream options requested by the client.\n        // The library is able to automatically convert the error into a gRPC status and send it back to the client.\n        case _ =&gt; Source.failed(new GrpcServiceException(\n          io.grpc.Status.INVALID_ARGUMENT.withDescription(\"Unsupported physical stream type\")\n        ))\n</code></pre> <p>The classes provided in <code>jelly-grpc</code> should cover most cases, but they only serve as the boilerplate. You must yourself define the logic for handling the incoming and outgoing streams, as shown in the example above.</p> <p>Of course, you can also implement the server or the client from scratch, if you want to.</p>"},{"location":"user/grpc/#see-also","title":"See also","text":"<ul> <li>Reactive streaming with Jelly-JVM</li> <li>Useful utilities<ul> <li>Using Typesafe config to configure Jelly</li> </ul> </li> </ul>"},{"location":"user/jena-cli/","title":"Apache Jena CLI tools","text":"<p>Jelly-JVM fully supports Apache Jena's command-line interface (CLI) utilities.</p>"},{"location":"user/jena-cli/#parsing","title":"Parsing","text":"<p>Jena will automatically detect Jelly files based on their extension (<code>.jelly</code>, <code>.jelly.gz</code>) and parse them. You can also manually set the <code>--syntax</code> option to <code>jelly</code>.</p>"},{"location":"user/jena-cli/#writing","title":"Writing","text":"<p>You can use Jelly as an output format for Jena's CLI utilities by specifying the <code>--output</code> or <code>--stream</code> options with the <code>jelly</code> format. We recommend using the <code>--stream</code> option for better performance. </p> <p>Example: converting a Turtle file to Jelly</p> <pre><code>./riot --stream=jelly data.ttl &gt; data.jelly\n</code></pre> <p>By default Jena will use the \"small, all features\" Jelly preset (name table: 128 entries, prefix table: 16, datatype table: 16, RDF-star enabled, generalized RDF enabled). There are a few reasons why you might want to change these serialization options:</p> <ul> <li>Performance \u2013 for larger files, the small preset does not offer the best performance or compression ratio. It's better to use larger lookup tables.</li> <li>Compatibility \u2013 if your data does not include RDF-star or generalized RDF, you can mark these features as disabled. Later, parsers will know accurately what to expect in your data.</li> </ul> <p>The following presets are available:</p> <ul> <li>Small: 128 name table entries, 16 prefix table entries, 16 datatype table entries<ul> <li><code>SMALL_STRICT</code> \u2013 RDF-star and generalized RDF disabled</li> <li><code>SMALL_GENERALIZED</code> \u2013 RDF-star disabled, generalized RDF enabled</li> <li><code>SMALL_RDF_STAR</code> \u2013 RDF-star enabled, generalized RDF disabled</li> <li><code>SMALL_ALL_FEATURES</code> \u2013 RDF-star and generalized RDF enabled (default)</li> </ul> </li> <li>Big: 4000 name table entries, 150 prefix table entries, 32 datatype table entries (recommended for larger files)<ul> <li><code>BIG_STRICT</code></li> <li><code>BIG_GENERALIZED</code></li> <li><code>BIG_RDF_STAR</code></li> <li><code>BIG_ALL_FEATURES</code></li> </ul> </li> </ul> <p>To use one of these presets, use the <code>--set</code> CLI option with the <code>https://ostrzyciel.eu/jelly/riot/symbols#preset</code> symbol:</p> <p>Example: converting a Turtle file to Jelly with a big preset (strict)</p> <pre><code>./riot --stream=jelly \\\n    --set=\"https://ostrzyciel.eu/jelly/riot/symbols#preset=BIG_STRICT\" \\\n    data.ttl &gt; data.jelly\n</code></pre> <p>Example: dumping a TDB2 database to Jelly with a big preset (all features)</p> <pre><code>./tdb2.tdbdump --tdb=path/to/assembler.ttl \\\n    --set=\"https://ostrzyciel.eu/jelly/riot/symbols#preset=BIG_ALL_FEATURES\" \\\n    --stream=jelly &gt; mydb.jelly\n</code></pre>"},{"location":"user/jena-cli/#see-also","title":"See also","text":"<ul> <li>Installing Jelly with Jena</li> <li>Jena CLI documentation</li> </ul>"},{"location":"user/jena/","title":"Apache Jena integration","text":"<p>This guide explains the functionalities of the <code>jelly-jena</code> module, which provides Jelly support for Apache Jena.</p> <p>If you just want to add Jelly format support to Apache Jena / Apache Jena Fuseki, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/jena/#base-facilities","title":"Base facilities","text":"<p><code>jelly-jena</code> implements the <code>eu.ostrzyciel.jelly.core.ConverterFactory</code>  trait in <code>eu.ostrzyciel.jelly.convert.jena.JenaConverterFactory</code> . This factory allows you to build encoders and decoders that convert between Jelly's <code>RdfStreamFrame</code>s and Apache Jena's <code>Triple</code> and <code>Quad</code> objects. The <code>eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame</code>  class is an object representation of Jelly's binary format.</p> <p>The module also implements the <code>eu.ostrzyciel.jelly.core.IterableAdapter</code>  trait in <code>eu.ostrzyciel.jelly.convert.jena.JenaIterableAdapter</code> . This adapter provides extension methods for Apache Jena's <code>Model</code>, <code>Dataset</code>, <code>Graph</code>, and <code>DatasetGraph</code> classes to convert them into an iterable of triples (<code>.asTriples</code>), quads (<code>.asQuads</code>), or named graphs (<code>.asGraphs</code>). This is useful when working with Jelly on a lower level or when using the <code>jelly-stream</code> module.</p>"},{"location":"user/jena/#serialization-and-deserialization-with-riot","title":"Serialization and deserialization with RIOT","text":"<p><code>jelly-jena</code> implements an RDF writer and reader for Apache Jena's RIOT library. This means you can use Jelly just like, for example, Turtle or RDF/XML. See the example below:</p> Example: JenaRiot.scala (click to expand) <p> Source code on GitHub</p> JenaRiot.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport eu.ostrzyciel.jelly.convert.jena.riot.*\nimport eu.ostrzyciel.jelly.core.*\nimport org.apache.jena.rdf.model.ModelFactory\nimport org.apache.jena.riot.{RDFDataMgr, RDFFormat, RDFParser, RDFWriterRegistry, RIOT}\n\nimport java.io.{File, FileOutputStream}\nimport scala.util.Using\n\n/**\n * Example of using Jelly's integration with Apache Jena's RIOT library for\n * writing and reading RDF graphs and datasets to/from disk.\n *\n * See also: https://jena.apache.org/documentation/io/\n */\nobject JenaRiot extends shared.Example:\n  def main(args: Array[String]): Unit =\n    // Load the RDF graph from an N-Triples file\n    val model = RDFDataMgr.loadModel(File(getClass.getResource(\"/weather.nt\").toURI).toURI.toString)\n\n    // Print the size of the model\n    println(s\"Loaded an RDF graph from N-Triples with size: ${model.size}\")\n\n    Using.resource(new FileOutputStream(\"weather.jelly\")) { out =&gt;\n      // Write the model to a Jelly file\n      // Note: by default this will use the [[JellyFormat.JELLY_SMALL_STRICT]] format variant\n      RDFDataMgr.write(out, model, JellyLanguage.JELLY)\n      println(\"Saved the model to a Jelly file\")\n    }\n\n    // Load the RDF graph from a Jelly file\n    val model2 = RDFDataMgr.loadModel(\"weather.jelly\", JellyLanguage.JELLY)\n\n    // Print the size of the model\n    println(s\"Loaded an RDF graph from Jelly with size: ${model2.size}\")\n\n\n\n    // ---------------------------------\n    println(\"\\n\")\n\n    // Try the same with an RDF dataset and some different settings\n    val dataset = RDFDataMgr.loadDataset(File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString)\n    println(s\"Loaded an RDF dataset from a Trig file with ${dataset.asDatasetGraph.size} named graphs and \" +\n      s\"${dataset.asDatasetGraph.stream.count} quads\")\n\n    Using.resource(new FileOutputStream(\"weather-quads.jelly\")) { out =&gt;\n      // Write the dataset to a Jelly file, using the \"BIG\" settings\n      // (better compression for big files, more memory usage)\n      RDFDataMgr.write(out, dataset, JellyFormat.JELLY_BIG_STRICT)\n      println(\"Saved the dataset to a Jelly file\")\n    }\n\n    // Load the RDF dataset from a Jelly file\n    val dataset2 = RDFDataMgr.loadDataset(\"weather-quads.jelly\", JellyLanguage.JELLY)\n    println(s\"Loaded an RDF dataset from Jelly with ${dataset2.asDatasetGraph.size} named graphs and \" +\n      s\"${dataset2.asDatasetGraph.stream.count} quads\")\n\n    // ---------------------------------\n    println(\"\\n\")\n\n    // Custom Jelly format \u2013 change any settings you like\n    val customFormat = new RDFFormat(\n      JellyLanguage.JELLY,\n      JellyFormatVariant(\n        opt = JellyOptions.smallStrict\n          .withMaxPrefixTableSize(0) // disable the prefix table\n          .withStreamName(\"My weather stream\"), // add metadata to the stream\n        frameSize = 16 // make RdfStreamFrames with 16 rows each\n      )\n    )\n\n    // Jena requires us to register the custom format \u2013 once for graphs and once for datasets,\n    // as Jelly supports both.\n    RDFWriterRegistry.register(customFormat, JellyGraphWriterFactory)\n    RDFWriterRegistry.register(customFormat, JellyDatasetWriterFactory)\n\n    Using.resource(new FileOutputStream(\"weather-quads-custom.jelly\")) { out =&gt;\n      // Write the dataset to a Jelly file using the custom format\n      RDFDataMgr.write(out, dataset, customFormat)\n      println(\"Saved the dataset to a Jelly file with custom settings\")\n    }\n\n    // Load the RDF dataset from a Jelly file with the custom format\n    val dataset3 = RDFDataMgr.loadDataset(\"weather-quads-custom.jelly\", JellyLanguage.JELLY)\n    println(s\"Loaded an RDF dataset from Jelly with custom settings with ${dataset3.asDatasetGraph.size} named graphs\" +\n      s\" and ${dataset3.asDatasetGraph.stream.count} quads\")\n\n    // ---------------------------------\n    println(\"\\n\")\n\n    // By default, the parser has limits on for example the maximum size of the lookup tables.\n    // The default supported options are [[JellyOptions.defaultSupportedOptions]].\n    // You can change these limits by creating your own options object.\n    val customOptions = JellyOptions.defaultSupportedOptions\n      .withMaxNameTableSize(50) // set the maximum size of the name table to 100\n    // Create a Context object with the custom options\n    val parserContext = RIOT.getContext.copy()\n      .set(JellyLanguage.SYMBOL_SUPPORTED_OPTIONS, customOptions)\n\n    println(\"Trying to load the model with custom supported options...\")\n    val model3 = ModelFactory.createDefaultModel()\n    try\n      // The loading operation should fail because our allowed max name table size is too low\n      RDFParser.create()\n        .source(\"weather.jelly\")\n        .lang(JellyLanguage.JELLY)\n        // Set the context object with the custom options\n        .context(parserContext)\n        .parse(model3)\n    catch\n      case e: RdfProtoDeserializationError =&gt;\n        // The stream uses a name table size of 128, which is larger than the maximum supported size of 50.\n        // To read this stream, set maxNameTableSize to at least 128 in the supportedOptions for this decoder.\n        println(s\"Failed to load the model with custom options: ${e.getMessage}\")\n</code></pre> <p>Usage notes:</p> <ul> <li><code>eu.ostrzyciel.jelly.core.JellyOptions</code>  provides a few common presets for Jelly serialization options construct a <code>JellyFormatVariant</code>, as shown in the example above. You can also further customize the serialization options (e.g., dictionary size).</li> <li>The RIOT writer (serializer) integration implements only the delimited variant of Jelly. It is used for writing Jelly to files on disk or sockets. Because of this, you cannot use RIOT to write non-delimited Jelly data (e.g., a single message to a Kafka stream). For this, you should use the <code>jelly-stream</code> module or the more low-level API: Low-level usage.</li> <li>However, the RIOT parser (deserializer) integration will automatically detect if the parsed Jelly data is delimited or not. If it's non-delimited, the parser will assume that there is only one <code>RdfStreamFrame</code> in the file.</li> <li>Jelly's parsers and writers are registered in the <code>eu.ostrzyciel.jelly.convert.jena.riot.JellyLanguage</code>  object (source code). This registration should happen automatically when you include the <code>jelly-jena</code> module in your project, using Jena's component initialization mechanism.</li> </ul>"},{"location":"user/jena/#streaming-serialization-with-riot","title":"Streaming serialization with RIOT","text":"<p><code>jelly-jena</code> also implements a streaming writer (<code>StreamRDF</code> API in Jena). Using it is similar to the regular RIOT writer, with a slightly different setup:</p> Example: JenaRiotStreaming.scala (click to expand) <p> Source code on GitHub</p> JenaRiotStreaming.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport eu.ostrzyciel.jelly.convert.jena.riot.*\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType\nimport org.apache.jena.graph.{NodeFactory, Triple}\nimport org.apache.jena.riot.system.{StreamRDFLib, StreamRDFWriter}\nimport org.apache.jena.riot.{RDFDataMgr, RDFParser, RIOT}\n\nimport java.io.{File, FileOutputStream}\nimport scala.util.Using\n\n/**\n * Example of using Apache Jena's streaming IO API with Jelly.\n *\n * See also: https://jena.apache.org/documentation/io/streaming-io.html\n */\nobject JenaRiotStreaming extends shared.Example:\n  def main(args: Array[String]): Unit =\n    // Initialize a Jena StreamRDF to consume the statements\n    val readerStream = StreamRDFLib.count()\n\n    println(\"Reading a stream of triples from a Jelly file...\")\n\n    // Parse a Jelly file as a stream of triples\n    val inputFileTriples = new File(getClass.getResource(\"/jelly/weather.jelly\").toURI)\n    RDFParser\n      .source(inputFileTriples.toURI.toString)\n      .lang(JellyLanguage.JELLY)\n      .parse(readerStream)\n\n    println(f\"Read ${readerStream.countTriples()} triples\")\n    println()\n    println(\"Reading a stream of quads from a Jelly file...\")\n\n    // Parse a different Jelly file as a stream of quads and send it to the same sink\n    val inputFileQuads = new File(getClass.getResource(\"/jelly/weather-quads.jelly\").toURI)\n    RDFParser\n      .source(inputFileQuads.toURI.toString)\n      .lang(JellyLanguage.JELLY)\n      .parse(readerStream)\n\n    // Print the number of triples and quads\n    //\n    // The number of triples here is the sum of the triples from the first file and the triples\n    // in the default graph of the second file. This is just how Jena handles it.\n    println(f\"Read ${readerStream.countTriples()} triples (in total)\" +\n      f\" and ${readerStream.countQuads()} quads\")\n\n    // -------------------------------------\n    println(\"\\n\")\n\n    println(\"Writing a stream of 10 triples to a file...\")\n\n    // Try writing some triples to a file\n    // We need to create an instance of RdfStreamOptions to pass to the writer:\n    val options = JellyOptions.smallStrict\n      // The stream writer does not know if we will be writing triples or quads \u2013 we\n      // have to specify the physical stream type explicitly.\n      .withPhysicalType(PhysicalStreamType.TRIPLES)\n      .withStreamName(\"A stream of 10 triples\")\n\n    // To pass the options, we use Jena's Context mechanism\n    val context = RIOT.getContext.copy()\n      .set(JellyLanguage.SYMBOL_STREAM_OPTIONS, options)\n      .set(JellyLanguage.SYMBOL_FRAME_SIZE, 128) // optional, default is 256\n\n    Using.resource(new FileOutputStream(\"stream-riot.jelly\")) { out =&gt;\n      // Create the writer \u2013 remember to pass the context!\n      val writerStream = StreamRDFWriter.getWriterStream(out, JellyLanguage.JELLY, context)\n      writerStream.start()\n\n      for i &lt;- 1 to 10 do\n        writerStream.triple(Triple.create(\n          NodeFactory.createBlankNode(),\n          NodeFactory.createURI(\"https://example.org/p\"),\n          NodeFactory.createLiteralString(s\"object $i\")\n        ))\n\n      writerStream.finish()\n    }\n\n    println(\"Done writing triples\")\n\n    // Load the RDF graph that we just saved using normal RIOT API\n    val model = RDFDataMgr.loadModel(\"stream-riot.jelly\", JellyLanguage.JELLY)\n\n    println(\"Loaded the stream from disk, contents:\\n\")\n    model.write(System.out, \"NT\")\n</code></pre>"},{"location":"user/jena/#see-also","title":"See also","text":"<ul> <li>Useful utilities</li> <li>Reactive streaming with Jelly-JVM</li> <li>Using Jelly with Jena's CLI tools</li> </ul>"},{"location":"user/low-level/","title":"Low-level usage","text":"<p>Warning</p> <p>This page describes a low-level API that is a bit of a hassle to use directly. It's recommended to use the higher-level abstractions provided by the <code>jelly-stream</code> module, or the integrations with Apache Jena's RIOT or RDF4J's Rio libraries. If you really want to use this, it is highly recommended that you first get a basic understanding of how Jelly works under the hood and take a look at the code in the <code>jelly-stream</code> module to see how it's done there.</p> <p>Note</p> <p>The following guide uses the Apache Jena library as an example. The exact same thing can be done with RDF4J or any other RDF library that has a Jelly integration.</p>"},{"location":"user/low-level/#deserialization","title":"Deserialization","text":"<p>To parse a serialized stream frame into triples/quads:</p> <ol> <li>Call <code>eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame.parseFrom</code>  if it's a non-delimited frame (like you would see, e.g., in a Kafka or gRPC stream), or <code>parseDelimitedFrom</code> if it's a delimited stream (like you would see in a file or a socket).<ul> <li>There is also a utility method to detect if the stream is delimited or not: <code>eu.ostrzyciel.jelly.core.IoUtils.autodetectDelimiting</code> . In most cases you will not need to use it. It is used internally by the Jena and RDF4J integrations for user convenience.</li> </ul> </li> <li>Obtain a decoder that turns <code>RdfStreamFrame</code>s into triples/quads: <code>eu.ostrzyciel.jelly.convert.jena.JenaConverterFactory</code>  has different methods for different physical stream types:<ul> <li><code>anyStatementDecoder</code> for any physical stream type, outputs <code>Triple</code> or <code>Quad</code></li> <li><code>triplesDecoder</code> for TRIPLES streams, outputs <code>Triple</code></li> <li><code>quadsDecoder</code> for QUADS streams, outputs <code>Quad</code></li> <li><code>graphsDecoder</code> for GRAPHS streams, outputs <code>(Node, Iterable[Triple])</code></li> <li><code>graphsAsQuadsDecoder</code> for GRAPHS streams, outputs <code>Quad</code></li> </ul> </li> <li>For each row in the frame, call the decoder's <code>ingestRow</code> method to get the output iteratively.</li> </ol>"},{"location":"user/low-level/#serialization","title":"Serialization","text":"<p>To serialize triples/quads into a stream frame:</p> <ol> <li>If you want to serialize an RDF graph/dataset, transform them first into triples/quads in an iterable form. Use the <code>asTriples</code>/<code>asQuads</code>/<code>asGraphs</code> extension methods provided by the <code>eu.ostrzyciel.jelly.convert.jena.JenaIterableAdapter</code>  object.</li> <li>Obtain an encoder that turns triples/quads into <code>RdfStreamRow</code>s (the rows of a stream frame): use the <code>eu.ostrzyciel.jelly.convert.jena.JenaConverterFactory.encoder</code>  method to get an instance of <code>eu.ostrzyciel.jelly.convert.jena.JenaProtoEncoder</code> .</li> <li>Call the encoder's methods to add quads, triples, or named graphs to the stream frame.<ul> <li>Note that YOU are responsible for sticking to a specific physical stream type. For example, you should not mix triples with quads. It is highly recommended that you first read on the available stream types in Jelly.</li> <li>You are also responsible for setting the appropriate stream options with proper stream types. See the guide on Jelly options presets for more information.</li> </ul> </li> <li>The encoder will be returning batches or rows. You are responsible for grouping those rows logically into <code>RdfStreamFrame</code>s. What you do here depends highly on the logical stream type you are working with.</li> </ol>"},{"location":"user/low-level/#see-also","title":"See also","text":"<ul> <li>Useful utilities</li> <li>Reactive streaming with Jelly-JVM</li> <li>Implementing Jelly-JVM for a new RDF library</li> </ul>"},{"location":"user/rdf4j/","title":"RDF4J integration","text":"<p>This guide explains the functionalities of the <code>jelly-rdf4j</code> module, which provides Jelly support for Eclipse RDF4J.</p> <p>If you just want to add Jelly format support to your RDF4J application, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/rdf4j/#base-facilities","title":"Base facilities","text":"<p><code>jelly-rdf4j</code> implements the <code>eu.ostrzyciel.jelly.core.ConverterFactory</code>  trait in <code>eu.ostrzyciel.jelly.convert.rdf4j.Rdf4jConverterFactory</code> . This factory allows you to build encoders and decoders that convert between Jelly's <code>RdfStreamFrame</code>s and RDF4J's <code>Statement</code> objects. The <code>eu.ostrzyciel.jelly.core.proto.v1.RdfStreamFrame</code>  class is an object representation of Jelly's binary format.</p> <p>The module also implements the <code>eu.ostrzyciel.jelly.core.IterableAdapter</code>  trait in <code>eu.ostrzyciel.jelly.convert.rdf4j.Rdf4jIterableAdapter</code> . This adapter provides extension methods for RDF4J's <code>Model</code> class to convert it into an iterable of triples (<code>.asTriples</code>), quads (<code>.asQuads</code>), or named graphs (<code>.asGraphs</code>). This is useful when working with Jelly on a lower level or when using the <code>jelly-stream</code> module.</p>"},{"location":"user/rdf4j/#serialization-and-deserialization-with-rdf4j-rio","title":"Serialization and deserialization with RDF4J Rio","text":"<p><code>jelly-rdf4j</code> implements an RDF writer and parser for Eclipse RDF4J's Rio library. This means you can use Jelly just like any other RDF serialization format (e.g., RDF/XML, Turtle). See the example below:</p> Example: Rdf4jRio.scala (click to expand) <p> Source code on GitHub</p> Rdf4jRio.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport eu.ostrzyciel.jelly.convert.rdf4j.rio.*\nimport eu.ostrzyciel.jelly.core.*\nimport eu.ostrzyciel.jelly.core.proto.v1.{PhysicalStreamType, RdfStreamOptions}\nimport org.eclipse.rdf4j.model.Statement\nimport org.eclipse.rdf4j.rio.helpers.StatementCollector\nimport org.eclipse.rdf4j.rio.{RDFFormat, Rio}\n\nimport java.io.{File, FileOutputStream}\nimport scala.jdk.CollectionConverters.*\nimport scala.util.Using\n\n/**\n * Example of using RDF4J's Rio library to read and write RDF data.\n *\n * See also: https://rdf4j.org/documentation/programming/rio/\n */\nobject Rdf4jRio extends shared.Example:\n  def main(args: Array[String]): Unit =\n    // Load the RDF graph from an N-Triples file\n    val inputFile = File(getClass.getResource(\"/weather.nt\").toURI)\n    val triples = readRdf4j(inputFile, RDFFormat.TURTLE, None)\n\n    // Print the size of the graph\n    println(s\"Loaded ${triples.size} triples from an N-Triples file\")\n\n    // Write the RDF graph to a Jelly file\n    // Fist, create the stream's options:\n    val options = JellyOptions.smallStrict\n      // Setting the physical stream type is mandatory! It will always be either TRIPLES or QUADS.\n      .withPhysicalType(PhysicalStreamType.TRIPLES)\n      // Set other optional options\n      .withStreamName(\"My weather data\")\n    // Create the config object to pass to the writer\n    val config = JellyWriterSettings.configFromOptions(options, frameSize = 128)\n\n    // Do the actual writing\n    Using.resource(new FileOutputStream(\"weather.jelly\")) { out =&gt;\n      val writer = Rio.createWriter(JELLY, out)\n      writer.setWriterConfig(config)\n      writer.startRDF()\n      triples.foreach(writer.handleStatement)\n      writer.endRDF()\n    }\n\n    println(\"Saved the model to a Jelly file\")\n\n    // Load the RDF graph from the Jelly file\n    val jellyFile = File(\"weather.jelly\")\n    val jellyTriples = readRdf4j(jellyFile, JELLY, None)\n\n    // Print the size of the graph\n    println(s\"Loaded ${jellyTriples.size} triples from a Jelly file\")\n\n    // ---------------------------------\n    println(\"\\n\")\n    // By default, the parser has limits on for example the maximum size of the lookup tables.\n    // The default supported options are [[JellyOptions.defaultSupportedOptions]].\n    // You can change these limits by creating your own options object.\n    val customOptions = JellyOptions.defaultSupportedOptions\n      .withMaxPrefixTableSize(10) // set the maximum size of the prefix table to 10\n    println(\"Trying to read the Jelly file with custom options...\")\n    try\n      // This operation should fail because the Jelly file uses a prefix table larger than 10\n      val customTriples = readRdf4j(jellyFile, JELLY, Some(customOptions))\n    catch\n      case e: RdfProtoDeserializationError =&gt;\n        // The stream uses a prefix table size of 16, which is larger than the maximum supported size of 10.\n        // To read this stream, set maxPrefixTableSize to at least 16 in the supportedOptions for this decoder.\n        println(s\"Failed to read the Jelly file with custom options: ${e.getMessage}\")\n\n\n  /**\n   * Helper function to read RDF data using RDF4J's Rio library.\n   * @param file file to read from\n   * @param format RDF format\n   * @param supportedOptions supported options for reading Jelly streams (optional)\n   * @return sequence of RDF statements\n   */\n  private def readRdf4j(file: File, format: RDFFormat, supportedOptions: Option[RdfStreamOptions]): Seq[Statement] =\n    val parser = Rio.createParser(format)\n    val collector = new StatementCollector()\n    parser.setRDFHandler(collector)\n    supportedOptions.foreach(opt =&gt;\n      // If the user provided supported options, set them on the parser\n      parser.setParserConfig(JellyParserSettings.configFromOptions(opt))\n    )\n    Using.resource(file.toURI.toURL.openStream()) { is =&gt;\n      parser.parse(is)\n    }\n    collector.getStatements.asScala.toSeq\n</code></pre> <p>Usage notes:</p> <ul> <li><code>eu.ostrzyciel.jelly.core.JellyOptions</code>  provides a few common presets for Jelly serialization options. These options are passed through <code>eu.ostrzyciel.jelly.convert.rdf4j.rio.JellyWriterSettings.configFromOptions</code>  and used to configure the writer, as shown in the example above. You can also further customize the serialization options (e.g., dictionary size).</li> <li>The RDF4J Rio writer (serializer) integration implements only the delimited variant of Jelly. It is used for writing Jelly to files on disk or sockets. Because of this, you cannot use Rio to write non-delimited Jelly data (e.g., a single message to a Kafka stream). For this, you should use the <code>jelly-stream</code> module or the more low-level API: Low-level usage.</li> <li>However, the Rio parser (deserializer) integration will automatically detect if the parsed Jelly data is delimited or not. If it's non-delimited, the parser will assume that there is only one <code>RdfStreamFrame</code> in the file.</li> <li>Jelly's parsers and writers are in the <code>eu.ostrzyciel.jelly.convert.rdf4j.rio</code>  package (source code). They are automatically registered on startup using the <code>RDFParserFactory</code> and <code>RDFWriterFactory</code> SPIs provided by RDF4J.</li> </ul>"},{"location":"user/rdf4j/#see-also","title":"See also","text":"<ul> <li>Useful utilities</li> <li>Reactive streaming with Jelly-JVM</li> </ul>"},{"location":"user/reactive/","title":"User guide \u2013 reactive streaming","text":"<p>This guide explains the reactive streaming functionalities of the <code>jelly-stream</code> module.</p> <p>Prerequisites</p> <p>If you are unfamiliar with the concept of reactive streams or Apache Pekko Streams, we highly recommend you start from reading about the basic concepts of Pekko Streams.</p> <p>We also recommend you first read about the RDF stream types in Jelly. Otherwise, this guide may not make much sense.</p> <p>You can use <code>jelly-stream</code> with any RDF library that has a Jelly integration, such as Apache Jena (using <code>jelly-jena</code>) or RDF4J (using <code>jelly-rdf4j</code>). The streaming API is generic and identical across all libraries.</p>"},{"location":"user/reactive/#basic-concepts","title":"Basic concepts","text":"<p>A key notion of this API are the encoders and decoders.</p> <ul> <li>An encoder turns objects from your RDF library of choice (e.g., <code>Triple</code> in Apache Jena) into an object representation of Jelly's binary format (<code>RdfStreamFrame</code>).</li> <li>A decoder does the opposite: it turns <code>RdfStreamFrame</code>s into objects from your RDF library of choice.</li> </ul> <p>So, for example, an encoder flow for flat triple streams would have a type of <code>Flow[Triple, RdfStreamFrame, NotUsed]</code> in Apache Jena. The opposite (a flat triple stream decoder) would have a type of <code>Flow[RdfStreamFrame, Triple, NotUsed]</code>.</p> <p><code>RdfStreamFrame</code>s can be converted to and from raw bytes using a range of methods, depending on your use case. See the sections below for examples.</p>"},{"location":"user/reactive/#encoding-any-rdf-data-as-a-flat-or-grouped-stream-encoderflow","title":"Encoding any RDF data as a flat or grouped stream (<code>EncoderFlow</code>)","text":"<p>The <code>eu.ostrzyciel.jelly.stream.EncoderFlow</code>  provides many options for turning RDF data into Jelly streams, including both grouped and flat streams. Every type of RDF stream in Jelly can be created using this API.</p> Example: PekkoStreamsEncoderFlow.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsEncoderFlow.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.stream.*\nimport org.apache.jena.graph.{Node, Triple}\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.jena.sparql.core.Quad\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport java.io.File\nimport scala.collection.immutable\nimport scala.concurrent.{Await, ExecutionContext}\nimport scala.concurrent.duration.*\n\n/**\n * Example of using the [[eu.ostrzyciel.jelly.stream.EncoderFlow]] utility to encode RDF data as Jelly streams.\n * \n * Here, the RDF data is turned into a series of byte buffers, with each buffer corresponding to exactly one frame.\n * This is suitable if your streaming protocol (e.g., Kafka, MQTT, AMQP) already frames the messages.\n * If you are writing to a raw socket or file, then you must use the DELIMITED variant of Jelly instead.\n * See [[eu.ostrzyciel.jelly.examples.PekkoStreamsWithIo]] for examples of that.\n *\n * In this example we are using Apache Jena as the RDF library (note the import:\n * `import eu.ostrzyciel.jelly.convert.jena.given`).\n * The same can be achieved with RDF4J just by importing a different module.\n */\nobject PekkoStreamsEncoderFlow extends shared.Example:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // Load the example dataset\n    val dataset = RDFDataMgr.loadDataset(File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString)\n\n    // First, let's see what views of the dataset can we obtain using Jelly's Iterable adapters:\n    // 1. Iterable of all quads in the dataset\n    val quads: immutable.Iterable[Quad] = dataset.asQuads\n    // 2. Iterable of all graphs (named and default) in the dataset\n    val graphs: immutable.Iterable[(Node, Iterable[Triple])] = dataset.asGraphs\n    // 3. Iterable of all triples in the default graph\n    val triples: immutable.Iterable[Triple] = dataset.getDefaultModel.asTriples\n\n    // Note: here we are not turning the frames into bytes, but just printing their size in bytes.\n    // You can find an example of how to turn a frame into a byte array in the `PekkoStreamsEncoderSource` example.\n    // This is done with: .via(JellyIo.toBytes)\n\n    // Let's try encoding this as flat RDF streams (streams of triples or quads)\n    // https://w3id.org/stax/ontology#flatQuadStream\n    println(f\"Encoding ${quads.size} quads as a flat RDF quad stream\")\n    val flatQuadsFuture = Source(quads)\n      .via(EncoderFlow.builder\n        // This encoder requires a size limiter \u2013 otherwise a stream frame could have infinite length!\n        .withLimiter(StreamRowCountLimiter(20))\n        .flatQuads(JellyOptions.smallStrict)\n        .flow\n      )\n      .runWith(Sink.foreach(frame =&gt; println(s\"Frame with ${frame.rows.size} rows, ${frame.serializedSize} bytes\")))\n\n    Await.ready(flatQuadsFuture, 10.seconds)\n\n    // https://w3id.org/stax/ontology#flatTripleStream\n    println(f\"\\n\\nEncoding ${triples.size} triples as a flat RDF triple stream\")\n    val flatTriplesFuture = Source(triples)\n      .via(EncoderFlow.builder\n        // This encoder requires a size limiter \u2013 otherwise a stream frame could have infinite length!\n        .withLimiter(ByteSizeLimiter(500))\n        .flatTriples(JellyOptions.smallStrict)\n        .flow\n      )\n      .runWith(Sink.foreach(frame =&gt; println(s\"Frame with ${frame.rows.size} rows, ${frame.serializedSize} bytes\")))\n\n    Await.ready(flatTriplesFuture, 10.seconds)\n\n    // We can also stream already grouped triples or quads \u2013 for example, if your system generates batches of\n    // N triples, you can just send those batches straight to be encoded, with one batch = one stream frame.\n    // https://w3id.org/stax/ontology#flatQuadStream\n    println(f\"\\n\\nEncoding ${quads.size} quads as a flat RDF quad stream, grouped in batches of 10\")\n    // First, group the quads into batches of 8\n    val groupedQuadsFuture = Source.fromIterator(() =&gt; quads.grouped(10))\n      .via(EncoderFlow.builder\n        // Do not use a size limiter here \u2013 we want exactly one batch in each frame\n        .flatQuadsGrouped(JellyOptions.smallStrict)\n        .flow\n      )\n      .runWith(Sink.foreach(frame =&gt; println(s\"Frame with ${frame.rows.size} rows, ${frame.serializedSize} bytes\")))\n\n    Await.ready(groupedQuadsFuture, 10.seconds)\n\n    // Now, let's try grouped streams. Let's say we want to stream all graphs in a dataset, but put exactly one\n    // graph in each frame (message). This is very common in (for example) IoT systems.\n    // https://w3id.org/stax/ontology#namedGraphStream\n    println(f\"\\n\\nEncoding ${graphs.size} graphs as a named graph stream\")\n    val namedGraphsFuture = Source(graphs)\n      .via(EncoderFlow.builder\n        // Do not use a size limiter here \u2013 we want exactly one graph in each frame\n        .namedGraphs(JellyOptions.smallStrict)\n        .flow\n      )\n      // Note that we will see exactly as many frames as there are graphs in the dataset\n      .runWith(Sink.foreach(frame =&gt; println(s\"Frame with ${frame.rows.size} rows, ${frame.serializedSize} bytes\")))\n\n    Await.ready(namedGraphsFuture, 10.seconds)\n\n    // As a last example, we will stream a series of RDF graphs. In our case this will be just the default graph\n    // repeated a few times. This type of stream is also pretty common in practical applications.\n    // https://w3id.org/stax/ontology#graphStream\n    println(f\"\\n\\nEncoding 5 RDF graphs as a graph stream\")\n    val graphsFuture = Source.repeat(triples)\n      .take(5)\n      .via(EncoderFlow.builder\n        // Do not use a size limiter here \u2013 we want exactly one graph in each frame\n        .graphs(JellyOptions.smallStrict)\n        .flow\n      )\n      // Note that we will see exactly 5 frames \u2013 the number of graphs we streamed\n      .runWith(Sink.foreach(frame =&gt; println(s\"Frame with ${frame.rows.size} rows, ${frame.serializedSize} bytes\")))\n\n    Await.ready(graphsFuture, 10.seconds)\n    actorSystem.terminate()\n</code></pre>"},{"location":"user/reactive/#encoding-a-single-rdf-graph-or-dataset-as-a-flat-stream-encodersource","title":"Encoding a single RDF graph or dataset as a flat stream (<code>EncoderSource</code>)","text":"<p>There are also convenience methods for creating flat RDF streams (i.e., flat streams of triples or quads) from  a single graph or dataset. You can do this by chaining <code>eu.ostrzyciel.jelly.stream.RdfSource</code>  with <code>eu.ostrzyciel.jelly.stream.EncoderFlow</code> , as shown in the example.</p> Example: PekkoStreamsEncoderSource.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsEncoderSource.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.stream.*\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport java.io.File\nimport scala.concurrent.{Await, ExecutionContext}\nimport scala.concurrent.duration.*\n\n/**\n * Example of using the [[eu.ostrzyciel.jelly.stream.RdfSource]] and [[eu.ostrzyciel.jelly.stream.EncoderFlow]] \n * utilities to encode single RDF graphs and datasets as Jelly streams.\n *\n * In this example we are using Apache Jena as the RDF library (note the import:\n * `import eu.ostrzyciel.jelly.convert.jena.given`).\n * The same can be achieved with RDF4J just by importing a different module.\n */\nobject PekkoStreamsEncoderSource extends shared.Example:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // Load an example RDF graph from an N-Triples file\n    val model = RDFDataMgr.loadModel(File(getClass.getResource(\"/weather.nt\").toURI).toURI.toString)\n\n    println(s\"Loaded model with ${model.size()} triples\")\n    println(s\"Streaming the model to memory...\")\n\n    // Create a Pekko Streams Source[Triple] from the Jena model\n    val encodedModelFuture = RdfSource.builder.graphAsTriples(model).source\n      // Encode the stream as a flat RDF triple stream\n      .via(EncoderFlow.builder\n        .withLimiter(ByteSizeLimiter(2000))\n        .flatTriples(JellyOptions.smallStrict)\n        .flow\n      )\n      // wireTap: print the size of the frames\n      // Notice in the output that the frames are slightly bigger than 2000 bytes.\n      .wireTap(frame =&gt; println(s\"Frame with ${frame.rows.size} rows, ${frame.serializedSize} bytes on wire\"))\n      // Convert each stream frame to bytes\n      .via(JellyIo.toBytes)\n      // Collect the stream into a sequence\n      .runWith(Sink.seq)\n\n    // Wait for the stream to complete and collect the result\n    val encodedModel = Await.result(encodedModelFuture, 10.seconds)\n\n    println(s\"Streamed model to memory with ${encodedModel.size} frames and\" +\n      s\" ${encodedModel.map(_.length).sum} bytes on wire\")\n\n    println(\"\\n\")\n\n    // -------------------------------------------------------------------\n    // Second example: try encoding an RDF dataset as a GRAPHS stream\n    // This time we will also preserve the namespace/prefix declarations (@prefix in Turtle) as a cosmetic feature\n    val dataset = RDFDataMgr.loadDataset(File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString)\n    println(s\"Loaded dataset with ${dataset.asDatasetGraph.size} named graphs\")\n    println(s\"Streaming the dataset to memory...\")\n\n    // Here we stream this is as a GRAPHS stream (physical type)\n    // You can also use .datasetAsQuads to stream as QUADS\n    val encodedDatasetFuture = RdfSource.builder\n      .datasetAsGraphs(dataset)\n      .withNamespaceDeclarations // Include namespace declarations in the stream\n      .source\n      .via(EncoderFlow.builder\n        // This time we limit the number of rows in each frame to 30\n        // Note that for this particular encoder, we can skip the limiter entirely \u2013 but this can lead to huge frames!\n        // So, be careful with that, or may get an out-of-memory error.\n        .withLimiter(StreamRowCountLimiter(30))\n        .namedGraphs(JellyOptions.smallStrict)\n        // We must also allow for namespace declarations, because our source contains them\n        .withNamespaceDeclarations\n        .flow\n      )\n      // wireTap: print the size of the frames\n      // Note that some frames smaller than the limit \u2013 this is because this encoder will always split frames\n      // on graph boundaries.\n      .wireTap(frame =&gt; println(s\"Frame with ${frame.rows.size} rows, ${frame.serializedSize} bytes on wire\"))\n      // Convert each stream frame to bytes\n      .via(JellyIo.toBytes)\n      // Collect the stream into a sequence\n      .runWith(Sink.seq)\n\n    // Wait for the stream to complete and collect the result\n    val encodedDataset = Await.result(encodedDatasetFuture, 10.seconds)\n\n    println(s\"Streamed dataset to memory with ${encodedDataset.size} frames and\" +\n      s\" ${encodedDataset.map(_.length).sum} bytes on wire\")\n\n    actorSystem.terminate()\n</code></pre>"},{"location":"user/reactive/#decoding-rdf-streams-decoderflow","title":"Decoding RDF streams (<code>DecoderFlow</code>)","text":"<p>The <code>eu.ostrzyciel.jelly.stream.DecoderFlow</code>  provides methods for decoding flat and grouped streams. There is no opposite equivalent to <code>EncoderSource</code> for decoding, though. This would require constructing an RDF graph or dataset from statements, which is a process that can vary a lot depending on your application. You will have to do this part yourself.</p> Example: PekkoStreamsDecoderFlow.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsDecoderFlow.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.stream.*\nimport org.apache.jena.graph.{Node, Triple}\nimport org.apache.jena.query.Dataset\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.jena.sparql.core.Quad\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport java.io.File\nimport scala.collection.immutable\nimport scala.concurrent.{Await, ExecutionContext}\nimport scala.concurrent.duration.*\n\n/**\n * Example of using the [[eu.ostrzyciel.jelly.stream.DecoderFlow]] utility to turn incoming Jelly streams\n * into usable RDF data.\n *\n * In this example we are using Apache Jena as the RDF library (note the import:\n * `import eu.ostrzyciel.jelly.convert.jena.given`).\n * The same can be achieved with RDF4J just by importing a different module.\n */\nobject PekkoStreamsDecoderFlow extends shared.Example:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // Load the example dataset\n    val dataset = RDFDataMgr.loadDataset(File(getClass.getResource(\"/weather-graphs.trig\").toURI).toURI.toString)\n\n    // To decode something, we first need to encode it...\n    // See [[PekkoStreamsEncoderFlow]] and [[PekkoStreamsEncoderSource]] for an explanation of what is happening here.\n    // We have four seqences of byte arrays, with each byte array corresponding to one encoded stream frame:\n    // - encodedQuads: a flat RDF quad stream, physical type: QUADS\n    // - encodedTriples: a flat RDF triple stream, physical type: TRIPLES\n    // - encodedGraphs: a flat RDF quad stream, physical type: GRAPHS\n    val (encodedQuads, encodedTriples, encodedGraphs) = getEncodedData(dataset)\n\n    // Now we can decode the encoded data back into something useful.\n    // Let's start by simply decoding the quads as a flat RDF quad stream:\n    println(\"Decoding quads as a flat RDF quad stream...\")\n    val decodedQuadsFuture = Source(encodedQuads)\n      // We need to parse the bytes into a Jelly stream frame\n      .via(JellyIo.fromBytes)\n      // And then decode the frame into Jena quads.\n      // We use \"decodeQuads\" because the physical stream type is QUADS.\n      // And then we want to treat it as a flat RDF quad stream, so we call \"asFlatQuadStreamStrict\".\n      // We use the \"Strict\" method to tell the decoder to check if the incoming logical stream type is the same\n      // as we are expecting: flat RDF quad stream.\n      .via(DecoderFlow.decodeQuads.asFlatQuadStreamStrict)\n      .runWith(Sink.seq)\n\n    val decodedQuads: Seq[Quad] = Await.result(decodedQuadsFuture, 10.seconds)\n    println(s\"Decoded ${decodedQuads.size} quads.\")\n\n    // We can also treat each stream frame as a separate dataset. This way we would get an\n    // RDF dataset stream.\n    println(f\"\\n\\nDecoding quads as an RDF dataset stream from ${encodedQuads.size} frames...\")\n    val decodedDatasetFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // Note that we cannot use the strict variant (asDatasetStreamOfQuadsStrict) here, because the stream says its\n      // logical type is flat RDF quad stream.\n      .via(DecoderFlow.decodeQuads.asDatasetStreamOfQuads)\n      .runWith(Sink.seq)\n\n    val decodedDatasets: Seq[IterableOnce[Quad]] = Await.result(decodedDatasetFuture, 10.seconds)\n    println(s\"Decoded ${decodedDatasets.size} datasets with\" +\n      s\" ${decodedDatasets.map(_.iterator.size).sum} quads in total.\")\n\n    // If we tried that with the strict variant, we would get an exception:\n    println(f\"\\n\\nDecoding quads as an RDF dataset stream with strict logical type handling...\")\n    val future = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      .via(DecoderFlow.decodeQuads.asDatasetStreamOfQuadsStrict)\n      .runWith(Sink.seq)\n    Await.result(future.recover {\n      // eu.ostrzyciel.jelly.core.JellyExceptions$RdfProtoDeserializationError:\n      // Expected logical stream type LOGICAL_STREAM_TYPE_DATASETS, got LOGICAL_STREAM_TYPE_FLAT_QUADS.\n      // LOGICAL_STREAM_TYPE_FLAT_QUADS is not a subtype of LOGICAL_STREAM_TYPE_DATASETS.\n      case e: Exception =&gt; println(e.getCause)\n    }, 10.seconds)\n\n    // We can also pass entirely custom supported options to the decoder, instead of the defaults\n    // (see [[JellyOptions.defaultSupportedOptions]]). This is useful if we want to decode a stream with\n    // for example very large lookup tables or we want to put stricter limits on the streams that we accept.\n    println(f\"\\n\\nDecoding quads as an RDF dataset stream with custom supported options...\")\n    val customSupportedOptions = JellyOptions.defaultSupportedOptions\n      .withMaxNameTableSize(50) // This is too small for the stream we are decoding\n    val customSupportedOptionsFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      .via(DecoderFlow.decodeQuads.asDatasetStreamOfQuads(customSupportedOptions))\n      .runWith(Sink.seq)\n    Await.result(customSupportedOptionsFuture.recover {\n      // eu.ostrzyciel.jelly.core.JellyExceptions$RdfProtoDeserializationError:\n      // The stream uses a name table size of 128, which is larger than the maximum supported size of 50.\n      // To read this stream, set maxNameTableSize to at least 128 in the supportedOptions for this decoder.\n      case e: Exception =&gt; println(e.getCause)\n    }, 10.seconds)\n\n    // Flat RDF triple stream\n    println(f\"\\n\\nDecoding triples as a flat RDF triple stream...\")\n    val decodedTriplesFuture = Source(encodedTriples)\n      .via(JellyIo.fromBytes)\n      .via(DecoderFlow.decodeTriples.asFlatTripleStreamStrict)\n      .runWith(Sink.seq)\n\n    val decodedTriples: Seq[Triple] = Await.result(decodedTriplesFuture, 10.seconds)\n    println(s\"Decoded ${decodedTriples.size} triples.\")\n\n    // We can interpret the GRAPHS stream in a few ways, see\n    // [[eu.ostrzyciel.jelly.stream.DecoderFlow.GraphsIngestFlowOps]] for more details.\n    // Here we will treat it as an RDF named graph stream.\n    println(f\"\\n\\nDecoding graphs as an RDF named graph stream...\")\n    val decodedGraphsFuture = Source(encodedGraphs)\n      .via(JellyIo.fromBytes)\n      // Non-strict because the original logical stream type is flat RDF quad stream.\n      .via(DecoderFlow.decodeGraphs.asNamedGraphStream)\n      .runWith(Sink.seq)\n\n    val decodedGraphs: Seq[(Node, Iterable[Triple])] = Await.result(decodedGraphsFuture, 10.seconds)\n    println(s\"Decoded ${decodedGraphs.size} graphs.\")\n\n    // If we tried using a decoder for a physical stream type that does not match the type of the stream,\n    // we would get an exception. Here let's try to decode a QUADS stream with a TRIPLES decoder.\n    println(f\"\\n\\nDecoding quads as a flat RDF triple stream...\")\n    val future2 = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // Note the \"decodeTriples\" here\n      .via(DecoderFlow.decodeTriples.asFlatTripleStream)\n      .runWith(Sink.seq)\n    Await.result(future2.recover {\n      // eu.ostrzyciel.jelly.core.JellyExceptions$RdfProtoDeserializationError:\n      // Incoming stream type is not TRIPLES.\n      case e: Exception =&gt; println(e.getCause)\n    }, 10.seconds)\n\n    // We can get around this by using the \"decodeAny\" method, which will pick the appropriate decoder\n    // based on the stream options in the stream.\n    // In this case we can only ask the decoder to output a flat or grouped RDF stream.\n    println(f\"\\n\\nDecoding quads as a flat RDF stream using decodeAny...\")\n    val decodedAnyFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // The is no strict variant at all for decodeAny, as we don't care about the stream type anyway.\n      .via(DecoderFlow.decodeAny.asFlatStream)\n      .runWith(Sink.seq)\n\n    val decodedAny: Seq[Triple | Quad] = Await.result(decodedAnyFuture, 10.seconds)\n    println(s\"Decoded ${decodedAny.size} statements.\")\n\n    // One last trick up our sleeves is the snoopStreamOptions method, which allows us to inspect the stream options\n    // and carry on with the decoding as normal.\n    // In this case, we will reuse the first example (flat RDF quad stream) and snoop the stream options.\n    println(f\"\\n\\nSnooping the stream options of the first frame while decoding a flat RDF quad stream...\")\n    val snoopFuture = Source(encodedQuads)\n      .via(JellyIo.fromBytes)\n      // We add a .viaMat here to capture the materialized value of this stage.\n      .viaMat(DecoderFlow.snoopStreamOptions)(Keep.right)\n      .via(DecoderFlow.decodeQuads.asFlatQuadStreamStrict)\n      .toMat(Sink.seq)(Keep.both)\n      .run()\n\n    val streamOptions = Await.result(snoopFuture._1, 10.seconds)\n    val decodedQuads2 = Await.result(snoopFuture._2, 10.seconds)\n\n    val streamOptionsIndented = (\"\\n\" + streamOptions.get.toProtoString.strip).replace(\"\\n\", \"\\n  \")\n    println(s\"Stream options: $streamOptionsIndented\")\n    println(s\"Decoded ${decodedQuads2.size} quads.\")\n\n    actorSystem.terminate()\n\n\n  /**\n   * Helper method to produce encoded data from a dataset.\n   */\n  private def getEncodedData(dataset: Dataset)(using ActorSystem, ExecutionContext):\n  (Seq[Array[Byte]], Seq[Array[Byte]], Seq[Array[Byte]]) =\n    val quadStream = RdfSource.builder.datasetAsQuads(dataset).source\n      .via(EncoderFlow.builder.withLimiter(ByteSizeLimiter(500)).flatQuads(JellyOptions.smallStrict).flow)\n\n    val tripleStream = RdfSource.builder.graphAsTriples(dataset.getDefaultModel).source\n      .via(EncoderFlow.builder.withLimiter(ByteSizeLimiter(250)).flatTriples(JellyOptions.smallStrict).flow)\n\n    val graphStream = RdfSource.builder.datasetAsGraphs(dataset).source\n      .via(EncoderFlow.builder.withLimiter(ByteSizeLimiter(500)).namedGraphs(JellyOptions.smallStrict).flow)\n\n    val results = Seq(quadStream, tripleStream, graphStream).map { stream =&gt;\n      val streamFuture = stream\n        .via(JellyIo.toBytes)\n        .runWith(Sink.seq)\n      Await.result(streamFuture, 10.seconds)\n    }\n    (results.head, results(1), results(2))\n</code></pre>"},{"location":"user/reactive/#byte-streams-delimited-variant","title":"Byte streams (delimited variant)","text":"<p>In all of the examples above, we used the non-delimited variant of Jelly, which is appropriate for, e.g., sending Jelly data over gRPC or Kafka. If you want to write Jelly data to a file or a socket, you will need to use the delimited variant. <code>jelly-stream</code> provides a few methods for this in <code>eu.ostrzyciel.jelly.stream.JellyIo</code> .</p> Example: PekkoStreamsWithIo.scala (click to expand) <p> Source code on GitHub</p> PekkoStreamsWithIo.scala<pre><code>package eu.ostrzyciel.jelly.examples\n\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.stream.*\nimport org.apache.jena.graph.{Node, Triple}\nimport org.apache.jena.query.Dataset\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.jena.sparql.core.Quad\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\nimport org.apache.pekko.util.ByteString\n\nimport java.io.{File, FileInputStream, FileOutputStream}\nimport java.util.zip.GZIPInputStream\nimport scala.collection.immutable\nimport scala.concurrent.{Await, ExecutionContext}\nimport scala.concurrent.duration.*\nimport scala.util.Using\n\n/**\n * Example of using Pekko Streams to read/write Jelly to a file or any other byte stream (e.g., socket).\n *\n * The examples here use the DELIMITED variant of Jelly, which is suitable only for situations where there is\n * no framing in the underlying stream. You should always use the delimited variant with raw files and sockets,\n * as otherwise it would be impossible to tell where one stream frame ends and another one begins.\n *\n * If you are working with something like MQTT, Kafka, JMS, AMQP... then check the examples in\n * [[eu.ostrzyciel.jelly.examples.PekkoStreamsEncoderFlow]].\n *\n * In this example we are using Apache Jena as the RDF library (note the import:\n * `import eu.ostrzyciel.jelly.convert.jena.given`).\n * The same can be achieved with RDF4J just by importing a different module.\n */\nobject PekkoStreamsWithIo extends shared.Example:\n  def main(args: Array[String]): Unit =\n    // We will need a Pekko actor system to run the streams\n    given actorSystem: ActorSystem = ActorSystem()\n    // And an execution context for the futures\n    given ExecutionContext = actorSystem.getDispatcher\n\n    // We will read a gzipped Jelly file from disk and decode it on the fly, as we are decompressing it.\n    println(\"Decoding a gzipped Jelly file with Pekko Streams...\")\n    // The input file is a GZipped Jelly file\n    val inputFile = File(getClass.getResource(\"/jelly/weather.jelly.gz\").toURI)\n\n    // Use Java's GZIPInputStream to decompress the input file on the fly\n    val decodedTriples: Seq[Triple] = Using.resource(new GZIPInputStream(FileInputStream(inputFile))) { inputStream =&gt;\n      val decodedTriplesFuture = JellyIo.fromIoStream(inputStream)\n        // Decode the Jelly frames to triples.\n        // Under the hood it uses the RdfStreamFrame.parseDelimitedFrom method.\n        .via(DecoderFlow.decodeTriples.asFlatTripleStream)\n        .runWith(Sink.seq)\n\n      Await.result(decodedTriplesFuture, 10.seconds)\n    }\n\n    println(s\"Decoded ${decodedTriples.size} triples\")\n\n    // -----------------------------------------------------------\n    // Now we will write the decoded triples to a new Jelly file\n    println(\"\\n\\nWriting the decoded triples to a new Jelly file with Pekko Streams...\")\n    Using.resource(new FileOutputStream(\"weather.jelly\")) { outputStream =&gt;\n      val writeFuture = Source(decodedTriples)\n        // Encode the triples to Jelly\n        .via(EncoderFlow.builder\n          .withLimiter(ByteSizeLimiter(500))\n          .flatTriples(JellyOptions.smallStrict)\n          .flow\n        )\n        // Write the Jelly frames to a Java byte stream.\n        // Under the hood it uses the RdfStreamFrame.writeDelimitedTo method.\n        .runWith(JellyIo.toIoStream(outputStream))\n\n      Await.ready(writeFuture, 10.seconds)\n      println(\"Done writing the Jelly file.\")\n    }\n\n    // -----------------------------------------------------------\n    // Pekko Streams offers its own utilities for reading and writing bytes that do not involve using Java's\n    // blocking implementation of streams.\n    // We will again write the decoded triples to a Jelly file, but this time use Pekko's facilities.\n    println(\"\\n\\nWriting the decoded triples to a new Jelly file with Pekko Streams' utilities...\")\n    val writeFuture = Source(decodedTriples)\n      .via(EncoderFlow.builder\n        .withLimiter(ByteSizeLimiter(500))\n        .flatTriples(JellyOptions.smallStrict)\n        .flow\n      )\n      // Convert the frames into Pekko's byte strings.\n      // Note: we are using the DELIMITED variant because we will write this to disk!\n      .via(JellyIo.toBytesDelimited)\n      .map(bytes =&gt; ByteString(bytes))\n      .runWith(FileIO.toPath(File(\"weather2.jelly\").toPath))\n\n    Await.ready(writeFuture, 10.seconds)\n    println(\"Done writing the Jelly file.\")\n\n    actorSystem.terminate()\n</code></pre>"},{"location":"user/reactive/#see-also","title":"See also","text":"<ul> <li>Using Jelly gRPC servers and clients</li> <li>Useful utilities<ul> <li>Using Typesafe config to configure Jelly</li> </ul> </li> <li>Low-level usage</li> </ul>"},{"location":"user/utilities/","title":"Useful utilities","text":"<p>This guide presents some useful utilities in the <code>jelly-core</code> and <code>jelly-stream</code> modules.</p>"},{"location":"user/utilities/#jelly-options-presets","title":"Jelly options presets","text":"<p>Every Jelly stream begins with a header that specifies the serialization options used to encode the stream \u2013 see the details in the specification. So, whenever you serialize some RDF with Jelly (e.g., using Apache Jena RIOT, RDF4J Rio, or the <code>jelly-stream</code> module), you need to specify these options.</p> <p>The <code>eu.ostrzyciel.jelly.core.JellyOptions</code>  object provides a few common presets for Jelly serialization options. They return an instance of <code>eu.ostrzyciel.jelly.core.proto.v1.RdfStreamOptions</code>  that you can further customize. For example:</p> <pre><code>import eu.ostrzyciel.jelly.core.JellyOptions\n\nval options = JellyOptions.smallStrict\n\nval optionsWithRdfStarSupport = JellyOptions.smallRdfStar\n\nval bigWithCustomDictionarySize = JellyOptions.bigStrict\n  .withMaxNameTableSize(2000)  \n</code></pre> <p>Warning</p> <p>These presets do not specify the physical or logical stream type. In most cases, the Jelly library will take care of this for you and set these types automatically later. However, if you use the low-level API, you need to set the stream types manually. For example:</p> <pre><code>import eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.core.proto.v1.*\n\nJellyOptions.smallStrict\n  .withPhysicalType(PhysicalStreamType.QUADS)\n  .withLogicalType(LogicalStreamType.DATASETS)\n</code></pre>"},{"location":"user/utilities/#checking-supported-options","title":"Checking supported options","text":"<p>There is also the <code>eu.ostrzyciel.jelly.core.JellyOptions.defaultSupportedOptions</code>  method which specifies the maximum set of options supported by default in Jelly-JVM, when parsing a stream. By default, Jelly-JVM will refuse to parse any stream that uses options that are beyond what is specified in this method. This is important for security reasons, as it prevents the library from, for example, allocating a 10 GB dictionary (potential Denial of Service attack).</p> <p>The supported options check is carried out automatically by the decoder when parsing a stream. You cannot disable the check, but you can customize the supported options by constructing a new <code>RdfStreamOptions</code> object from <code>eu.ostrzyciel.jelly.core.JellyOptions.defaultSupportedOptions</code> , customizing it, and passing it to the decoder.</p> <p>If you want to do this kind of check in some other context (e.g., in a gRPC service to check if you can support the options requested by the client), you can use the <code>eu.ostrzyciel.jelly.core.JellyOptions.checkCompatibility</code>  method. It will throw an exception if the options are not supported.</p>"},{"location":"user/utilities/#useful-constants","title":"Useful constants","text":"<p>The <code>eu.ostrzyciel.jelly.core.Constants</code>  object defines some useful constants, such as the file extension for Jelly, its content type, and the version of the Jelly protocol.</p>"},{"location":"user/utilities/#rdf-stream-taxonomy-rdf-stax-stream-type-utilities","title":"RDF Stream Taxonomy (RDF-STaX) stream type utilities","text":"<p>Jelly uses RDF-STaX to define the logical stream types (more details here). Jelly-JVM defines each of these types as a case object in <code>eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType</code> .</p> <p>These objects have a few useful methods for working with the RDF-STaX ontology:</p> <pre><code>import eu.ostrzyciel.jelly.core.*\nimport eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType\n\n// Get the RDF-STaX IRI of a stream type\n// returns \"https://w3id.org/stax/ontology#flatTripleStream\"\nLogicalStreamType.TRIPLES.getRdfStaxType\n</code></pre> <p>You can also obtain a full RDF-STaX annotation for your stream if you also import an RDF library interop module (e.g., <code>jelly-jena</code> or <code>jelly-rdf4j</code>):</p> <pre><code>// Here we import `jena.given` to get the necessary implicit conversions.\n// You can do the same with `rdf4j.given` if you are using RDF4J.\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.core.*\nimport eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType\nimport org.apache.jena.graph.NodeFactory\n\nval subjectNode: Node = NodeFactory.createURI(\"http://example.org/subject\")\nval triples: Seq[Triple] = LogicalStreamType.QUADS.getRdfStaxAnnotation\n// Returns a Seq of three triples that would look like this in Turtle:\n// &lt;http://example.org/subject&gt; stax:hasStreamTypeUsage [\n//   a stax:RdfStreamTypeUsage ;\n//   stax:hasStreamType stax:flatQuadStream\n// ] .\n</code></pre> <p>You can then take this annotation and expose as semantic metadata of your stream.</p> <p>You can also do the opposite and construct an instance of <code>LogicalStreamType</code> from an RDF-STaX IRI:</p> <pre><code>import eu.ostrzyciel.jelly.core.LogicalStreamTypeFactory\n\nval iri = \"https://w3id.org/stax/ontology#flatQuadStream\"\n// returns LogicalStreamType.QUADS\nval streamType = LogicalStreamTypeFactory.fromOntologyIri(iri)\n</code></pre> <p>Finally, there are also stream type checking and manipulation utilities:</p> <pre><code>import eu.ostrzyciel.jelly.core.*\nimport eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType\n\n// Check if this type is equal or a subtype of another type.\n// This is useful for performing compatibility checks.\n// Returns false\nLogicalStreamType.TRIPLES.isEqualOrSubtypeOf(LogicalStreamType.DATASETS)\n// Returns true\nLogicalStreamType.NAMED_GRAPHS.isEqualOrSubtypeOf(LogicalStreamType.DATASETS)\n\n// Get the \"base\" type of a stream type. Base types are concrete stream types \n// that have no parent types. \n// There are only 4 base types: GRAPHS, DATASETS, TRIPLES, QUADS.\n// Returns LogicalStreamType.TRIPLES\nLogicalStreamType.TRIPLES.toBaseType\n// Returns LogicalStreamType.DATASETS\nLogicalStreamType.NAMED_GRAPHS.toBaseType\n// Returns LogicalStreamType.DATASETS\nLogicalStreamType.TIMESTAMPED_NAMED_GRAPHS.toBaseType\n</code></pre>"},{"location":"user/utilities/#jelly-configuration-from-typesafe-config","title":"Jelly configuration from Typesafe config","text":"<p>The <code>jelly-stream</code> module also implements a utility for configuring Jelly serialization options using the Typesafe config library, which is commonly used in Apache Pekko applications.</p> <p>The utility is provided by the <code>eu.ostrzyciel.jelly.stream.JellyOptionsFromTypesafe</code>  object. For example:</p> <pre><code>import com.typesafe.config.ConfigFactory\nimport eu.ostrzyciel.jelly.stream.JellyOptionsFromTypesafe\n\nval config = ConfigFactory.parseString(\"\"\"\n  |jelly.physical-type = QUADS\n  |jelly.name-table-size = 1024\n  |jelly.prefix-table-size = 64\n  |\"\"\".stripMargin)\n\nval options = JellyOptionsFromTypesafe.fromConfig(config.getConfig(\"jelly\"))\noptions.physicalType // returns PhysicalStreamType.QUADS\noptions.maxNameTableSize // returns 1024\noptions.maxPrefixTableSize // returns 64\noptions.maxDatatypeTableSize // returns 16 (the default)\n</code></pre> <p>See the source code of this class for more details.</p>"},{"location":"user/utilities/#see-also","title":"See also","text":"<ul> <li>Reactive streaming with Jelly-JVM</li> <li>Low-level usage of Jelly-JVM</li> </ul>"}]}