// Code generated by protocol buffer compiler. Do not edit!
package eu.neverblink.jelly.core.proto.v1;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.LimitedCodedInputStream;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import java.io.IOException;
import java.io.InputStream;

/**
 * Protobuf type {@code RdfStreamOptions}
 */
@SuppressWarnings("hiding")
public final class RdfStreamOptions extends ProtoMessage<RdfStreamOptions> implements Cloneable {

    /**
     * <code>optional string stream_name = 1;</code>
     */
    private String streamName = "";

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     */
    private int physicalType;

    /**
     * <code>optional bool generalized_statements = 3;</code>
     */
    private boolean generalizedStatements;

    /**
     * <code>optional bool rdf_star = 4;</code>
     */
    private boolean rdfStar;

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     */
    private int maxNameTableSize;

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     */
    private int maxPrefixTableSize;

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     */
    private int maxDatatypeTableSize;

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     */
    private int logicalType;

    /**
     * <code>optional uint32 version = 15;</code>
     */
    private int version;

    private RdfStreamOptions() {}

    /**
     * @return a new empty instance of {@code RdfStreamOptions}
     */
    public static RdfStreamOptions newInstance() {
        return new RdfStreamOptions();
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @return this
     */
    public RdfStreamOptions clearStreamName() {
        streamName = "";
        return this;
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @return the streamName
     */
    public String getStreamName() {
        return streamName;
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @param value the streamName to set
     * @return this
     */
    public RdfStreamOptions setStreamName(final String value) {
        streamName = value;
        return this;
    }

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @return this
     */
    public RdfStreamOptions clearPhysicalType() {
        physicalType = 0;
        return this;
    }

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @return the physicalType
     */
    public PhysicalStreamType getPhysicalType() {
        return PhysicalStreamType.forNumber(physicalType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link RdfStreamOptions#getPhysicalType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getPhysicalTypeValue() {
        return physicalType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link PhysicalStreamType}. Setting an invalid value
     * can cause {@link RdfStreamOptions#getPhysicalType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public RdfStreamOptions setPhysicalTypeValue(final int value) {
        physicalType = value;
        return this;
    }

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @param value the physicalType to set
     * @return this
     */
    public RdfStreamOptions setPhysicalType(final PhysicalStreamType value) {
        physicalType = value.getNumber();
        return this;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @return this
     */
    public RdfStreamOptions clearGeneralizedStatements() {
        generalizedStatements = false;
        return this;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @return the generalizedStatements
     */
    public boolean getGeneralizedStatements() {
        return generalizedStatements;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @param value the generalizedStatements to set
     * @return this
     */
    public RdfStreamOptions setGeneralizedStatements(final boolean value) {
        generalizedStatements = value;
        return this;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @return this
     */
    public RdfStreamOptions clearRdfStar() {
        rdfStar = false;
        return this;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @return the rdfStar
     */
    public boolean getRdfStar() {
        return rdfStar;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @param value the rdfStar to set
     * @return this
     */
    public RdfStreamOptions setRdfStar(final boolean value) {
        rdfStar = value;
        return this;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @return this
     */
    public RdfStreamOptions clearMaxNameTableSize() {
        maxNameTableSize = 0;
        return this;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @return the maxNameTableSize
     */
    public int getMaxNameTableSize() {
        return maxNameTableSize;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @param value the maxNameTableSize to set
     * @return this
     */
    public RdfStreamOptions setMaxNameTableSize(final int value) {
        maxNameTableSize = value;
        return this;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @return this
     */
    public RdfStreamOptions clearMaxPrefixTableSize() {
        maxPrefixTableSize = 0;
        return this;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @return the maxPrefixTableSize
     */
    public int getMaxPrefixTableSize() {
        return maxPrefixTableSize;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @param value the maxPrefixTableSize to set
     * @return this
     */
    public RdfStreamOptions setMaxPrefixTableSize(final int value) {
        maxPrefixTableSize = value;
        return this;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @return this
     */
    public RdfStreamOptions clearMaxDatatypeTableSize() {
        maxDatatypeTableSize = 0;
        return this;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @return the maxDatatypeTableSize
     */
    public int getMaxDatatypeTableSize() {
        return maxDatatypeTableSize;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @param value the maxDatatypeTableSize to set
     * @return this
     */
    public RdfStreamOptions setMaxDatatypeTableSize(final int value) {
        maxDatatypeTableSize = value;
        return this;
    }

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @return this
     */
    public RdfStreamOptions clearLogicalType() {
        logicalType = 0;
        return this;
    }

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @return the logicalType
     */
    public LogicalStreamType getLogicalType() {
        return LogicalStreamType.forNumber(logicalType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link RdfStreamOptions#getLogicalType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getLogicalTypeValue() {
        return logicalType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link LogicalStreamType}. Setting an invalid value
     * can cause {@link RdfStreamOptions#getLogicalType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public RdfStreamOptions setLogicalTypeValue(final int value) {
        logicalType = value;
        return this;
    }

    /**
     * <code>optional .eu.neverblink.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @param value the logicalType to set
     * @return this
     */
    public RdfStreamOptions setLogicalType(final LogicalStreamType value) {
        logicalType = value.getNumber();
        return this;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @return this
     */
    public RdfStreamOptions clearVersion() {
        version = 0;
        return this;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @return the version
     */
    public int getVersion() {
        return version;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @param value the version to set
     * @return this
     */
    public RdfStreamOptions setVersion(final int value) {
        version = value;
        return this;
    }

    @Override
    public RdfStreamOptions copyFrom(final RdfStreamOptions other) {
        cachedSize = other.cachedSize;
        streamName = other.streamName;
        physicalType = other.physicalType;
        generalizedStatements = other.generalizedStatements;
        rdfStar = other.rdfStar;
        maxNameTableSize = other.maxNameTableSize;
        maxPrefixTableSize = other.maxPrefixTableSize;
        maxDatatypeTableSize = other.maxDatatypeTableSize;
        logicalType = other.logicalType;
        version = other.version;
        return this;
    }

    @Override
    public RdfStreamOptions mergeFrom(final RdfStreamOptions other) {
        cachedSize = -1;
        streamName = other.streamName;
        setPhysicalTypeValue(other.physicalType);
        setGeneralizedStatements(other.generalizedStatements);
        setRdfStar(other.rdfStar);
        setMaxNameTableSize(other.maxNameTableSize);
        setMaxPrefixTableSize(other.maxPrefixTableSize);
        setMaxDatatypeTableSize(other.maxDatatypeTableSize);
        setLogicalTypeValue(other.logicalType);
        setVersion(other.version);
        return this;
    }

    @Override
    public RdfStreamOptions clear() {
        cachedSize = -1;
        streamName = "";
        physicalType = 0;
        generalizedStatements = false;
        rdfStar = false;
        maxNameTableSize = 0;
        maxPrefixTableSize = 0;
        maxDatatypeTableSize = 0;
        logicalType = 0;
        version = 0;
        return this;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof RdfStreamOptions)) {
            return false;
        }
        RdfStreamOptions other = (RdfStreamOptions) o;
        return (
            streamName.equals(other.streamName) &&
            physicalType == other.physicalType &&
            generalizedStatements == other.generalizedStatements &&
            rdfStar == other.rdfStar &&
            maxNameTableSize == other.maxNameTableSize &&
            maxPrefixTableSize == other.maxPrefixTableSize &&
            maxDatatypeTableSize == other.maxDatatypeTableSize &&
            logicalType == other.logicalType &&
            version == other.version
        );
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
        if (!streamName.isEmpty()) {
            output.writeRawByte((byte) 10);
            output.writeStringNoTag(streamName);
        }
        if (physicalType != 0) {
            output.writeRawByte((byte) 16);
            output.writeEnumNoTag(physicalType);
        }
        if (generalizedStatements != false) {
            output.writeRawByte((byte) 24);
            output.writeBoolNoTag(generalizedStatements);
        }
        if (rdfStar != false) {
            output.writeRawByte((byte) 32);
            output.writeBoolNoTag(rdfStar);
        }
        if (maxNameTableSize != 0) {
            output.writeRawByte((byte) 72);
            output.writeUInt32NoTag(maxNameTableSize);
        }
        if (maxPrefixTableSize != 0) {
            output.writeRawByte((byte) 80);
            output.writeUInt32NoTag(maxPrefixTableSize);
        }
        if (maxDatatypeTableSize != 0) {
            output.writeRawByte((byte) 88);
            output.writeUInt32NoTag(maxDatatypeTableSize);
        }
        if (logicalType != 0) {
            output.writeRawByte((byte) 112);
            output.writeEnumNoTag(logicalType);
        }
        if (version != 0) {
            output.writeRawByte((byte) 120);
            output.writeUInt32NoTag(version);
        }
    }

    @Override
    protected int computeSerializedSize() {
        int size = 0;
        if (!streamName.isEmpty()) {
            size += 1 + CodedOutputStream.computeStringSizeNoTag(streamName);
        }
        if (physicalType != 0) {
            size += 1 + CodedOutputStream.computeEnumSizeNoTag(physicalType);
        }
        if (generalizedStatements != false) {
            size += 2;
        }
        if (rdfStar != false) {
            size += 2;
        }
        if (maxNameTableSize != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxNameTableSize);
        }
        if (maxPrefixTableSize != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxPrefixTableSize);
        }
        if (maxDatatypeTableSize != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxDatatypeTableSize);
        }
        if (logicalType != 0) {
            size += 1 + CodedOutputStream.computeEnumSizeNoTag(logicalType);
        }
        if (version != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(version);
        }
        return size;
    }

    @Override
    @SuppressWarnings("fallthrough")
    public RdfStreamOptions mergeFrom(final LimitedCodedInputStream inputLimited) throws IOException {
        // Enabled Fall-Through Optimization (Quickbuf)
        final CodedInputStream input = inputLimited.in();
        int tag = input.readTag();
        while (true) {
            switch (tag) {
                case 10: {
                    // streamName
                    streamName = input.readStringRequireUtf8();
                    tag = input.readTag();
                    if (tag != 16) {
                        break;
                    }
                }
                case 16: {
                    // physicalType
                    final int value = input.readInt32();
                    if (PhysicalStreamType.forNumber(value) != null) {
                        physicalType = value;
                    }
                    tag = input.readTag();
                    if (tag != 24) {
                        break;
                    }
                }
                case 24: {
                    // generalizedStatements
                    generalizedStatements = input.readBool();
                    tag = input.readTag();
                    if (tag != 32) {
                        break;
                    }
                }
                case 32: {
                    // rdfStar
                    rdfStar = input.readBool();
                    tag = input.readTag();
                    if (tag != 72) {
                        break;
                    }
                }
                case 72: {
                    // maxNameTableSize
                    maxNameTableSize = input.readUInt32();
                    tag = input.readTag();
                    if (tag != 80) {
                        break;
                    }
                }
                case 80: {
                    // maxPrefixTableSize
                    maxPrefixTableSize = input.readUInt32();
                    tag = input.readTag();
                    if (tag != 88) {
                        break;
                    }
                }
                case 88: {
                    // maxDatatypeTableSize
                    maxDatatypeTableSize = input.readUInt32();
                    tag = input.readTag();
                    if (tag != 112) {
                        break;
                    }
                }
                case 112: {
                    // logicalType
                    final int value = input.readInt32();
                    if (LogicalStreamType.forNumber(value) != null) {
                        logicalType = value;
                    }
                    tag = input.readTag();
                    if (tag != 120) {
                        break;
                    }
                }
                case 120: {
                    // version
                    version = input.readUInt32();
                    tag = input.readTag();
                    if (tag != 0) {
                        break;
                    }
                }
                case 0: {
                    return this;
                }
                default: {
                    if (!input.skipField(tag)) {
                        return this;
                    }
                    tag = input.readTag();
                    break;
                }
            }
        }
    }

    @Override
    public RdfStreamOptions clone() {
        return new RdfStreamOptions().copyFrom(this);
    }

    public static RdfStreamOptions parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(new RdfStreamOptions(), data).checkInitialized();
    }

    public static RdfStreamOptions parseFrom(final LimitedCodedInputStream input) throws IOException {
        return ProtoMessage.mergeFrom(new RdfStreamOptions(), input).checkInitialized();
    }

    public static RdfStreamOptions parseDelimitedFrom(final InputStream input) throws IOException {
        return ProtoMessage.parseDelimitedFrom(input, RdfStreamOptions.getFactory());
    }

    /**
     * @return factory for creating RdfStreamOptions messages
     */
    public static MessageFactory<RdfStreamOptions> getFactory() {
        return RdfStreamOptionsFactory.INSTANCE;
    }

    private enum RdfStreamOptionsFactory implements MessageFactory<RdfStreamOptions> {
        INSTANCE;

        @Override
        public RdfStreamOptions create() {
            return RdfStreamOptions.newInstance();
        }
    }
}
