// Code generated by NeverBlink protoc-java-fast. Do not edit!
package eu.neverblink.jelly.core.proto.v1;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.Descriptors;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.LimitedCodedInputStream;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import java.io.IOException;
import java.io.InputStream;

/**
 * Protobuf type {@code RdfStreamOptions}
 * DO NOT INHERIT FROM THIS CLASS!
 * It's not <code>final</code> only to facilitate the Mutable nested subclass.
 */
@SuppressWarnings("hiding")
public abstract class RdfStreamOptions extends ProtoMessage<RdfStreamOptions> implements Cloneable {

    /**
     * <code>optional string stream_name = 1;</code>
     */
    protected String streamName = "";

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     */
    protected int physicalType;

    /**
     * <code>optional bool generalized_statements = 3;</code>
     */
    protected boolean generalizedStatements;

    /**
     * <code>optional bool rdf_star = 4;</code>
     */
    protected boolean rdfStar;

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     */
    protected int maxNameTableSize;

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     */
    protected int maxPrefixTableSize;

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     */
    protected int maxDatatypeTableSize;

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     */
    protected int logicalType;

    /**
     * <code>optional uint32 version = 15;</code>
     */
    protected int version;

    private RdfStreamOptions() {}

    /**
     * @return a new empty instance of {@code Mutable}
     */
    public static Mutable newInstance() {
        return new Mutable();
    }

    /**
     * <code>optional string stream_name = 1;</code>
     * @return the streamName
     */
    public String getStreamName() {
        return streamName;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
     * @return the physicalType
     */
    public PhysicalStreamType getPhysicalType() {
        return PhysicalStreamType.forNumber(physicalType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link RdfStreamOptions#getPhysicalType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getPhysicalTypeValue() {
        return physicalType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link PhysicalStreamType}. Setting an invalid value
     * can cause {@link RdfStreamOptions#getPhysicalType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public RdfStreamOptions setPhysicalTypeValue(final int value) {
        physicalType = value;
        return this;
    }

    /**
     * <code>optional bool generalized_statements = 3;</code>
     * @return the generalizedStatements
     */
    public boolean getGeneralizedStatements() {
        return generalizedStatements;
    }

    /**
     * <code>optional bool rdf_star = 4;</code>
     * @return the rdfStar
     */
    public boolean getRdfStar() {
        return rdfStar;
    }

    /**
     * <code>optional uint32 max_name_table_size = 9;</code>
     * @return the maxNameTableSize
     */
    public int getMaxNameTableSize() {
        return maxNameTableSize;
    }

    /**
     * <code>optional uint32 max_prefix_table_size = 10;</code>
     * @return the maxPrefixTableSize
     */
    public int getMaxPrefixTableSize() {
        return maxPrefixTableSize;
    }

    /**
     * <code>optional uint32 max_datatype_table_size = 11;</code>
     * @return the maxDatatypeTableSize
     */
    public int getMaxDatatypeTableSize() {
        return maxDatatypeTableSize;
    }

    /**
     * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
     * @return the logicalType
     */
    public LogicalStreamType getLogicalType() {
        return LogicalStreamType.forNumber(logicalType);
    }

    /**
     * Gets the value of the internal enum store. The result is
     * equivalent to {@link RdfStreamOptions#getLogicalType()}.getNumber().
     *
     * @return numeric wire representation
     */
    public int getLogicalTypeValue() {
        return logicalType;
    }

    /**
     * Sets the value of the internal enum store. This does not
     * do any validity checks, so be sure to use appropriate value
     * constants from {@link LogicalStreamType}. Setting an invalid value
     * can cause {@link RdfStreamOptions#getLogicalType()} to return null
     *
     * @param value the numeric wire value to set
     * @return this
     */
    public RdfStreamOptions setLogicalTypeValue(final int value) {
        logicalType = value;
        return this;
    }

    /**
     * <code>optional uint32 version = 15;</code>
     * @return the version
     */
    public int getVersion() {
        return version;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof RdfStreamOptions)) {
            return false;
        }
        RdfStreamOptions other = (RdfStreamOptions) o;
        return (
            streamName.equals(other.streamName) &&
            physicalType == other.physicalType &&
            generalizedStatements == other.generalizedStatements &&
            rdfStar == other.rdfStar &&
            maxNameTableSize == other.maxNameTableSize &&
            maxPrefixTableSize == other.maxPrefixTableSize &&
            maxDatatypeTableSize == other.maxDatatypeTableSize &&
            logicalType == other.logicalType &&
            version == other.version
        );
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
        if (!streamName.isEmpty()) {
            output.writeRawByte((byte) 10);
            output.writeStringNoTag(streamName);
        }
        if (physicalType != 0) {
            output.writeRawByte((byte) 16);
            output.writeEnumNoTag(physicalType);
        }
        if (generalizedStatements != false) {
            output.writeRawByte((byte) 24);
            output.writeBoolNoTag(generalizedStatements);
        }
        if (rdfStar != false) {
            output.writeRawByte((byte) 32);
            output.writeBoolNoTag(rdfStar);
        }
        if (maxNameTableSize != 0) {
            output.writeRawByte((byte) 72);
            output.writeUInt32NoTag(maxNameTableSize);
        }
        if (maxPrefixTableSize != 0) {
            output.writeRawByte((byte) 80);
            output.writeUInt32NoTag(maxPrefixTableSize);
        }
        if (maxDatatypeTableSize != 0) {
            output.writeRawByte((byte) 88);
            output.writeUInt32NoTag(maxDatatypeTableSize);
        }
        if (logicalType != 0) {
            output.writeRawByte((byte) 112);
            output.writeEnumNoTag(logicalType);
        }
        if (version != 0) {
            output.writeRawByte((byte) 120);
            output.writeUInt32NoTag(version);
        }
    }

    @Override
    protected int computeSerializedSize() {
        int size = 0;
        if (!streamName.isEmpty()) {
            size += 1 + CodedOutputStream.computeStringSizeNoTag(streamName);
        }
        if (physicalType != 0) {
            size += 1 + CodedOutputStream.computeEnumSizeNoTag(physicalType);
        }
        if (generalizedStatements != false) {
            size += 2;
        }
        if (rdfStar != false) {
            size += 2;
        }
        if (maxNameTableSize != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxNameTableSize);
        }
        if (maxPrefixTableSize != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxPrefixTableSize);
        }
        if (maxDatatypeTableSize != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(maxDatatypeTableSize);
        }
        if (logicalType != 0) {
            size += 1 + CodedOutputStream.computeEnumSizeNoTag(logicalType);
        }
        if (version != 0) {
            size += 1 + CodedOutputStream.computeUInt32SizeNoTag(version);
        }
        return size;
    }

    @Override
    public Mutable clone() {
        return newInstance().copyFrom(this);
    }

    public static RdfStreamOptions parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(newInstance(), data);
    }

    public static RdfStreamOptions parseFrom(final LimitedCodedInputStream input) throws IOException {
        return ProtoMessage.mergeFrom(newInstance(), input);
    }

    public static RdfStreamOptions parseDelimitedFrom(final InputStream input) throws IOException {
        return ProtoMessage.parseDelimitedFrom(input, RdfStreamOptions.getFactory());
    }

    /**
     * @return factory for creating RdfStreamOptions messages
     */
    public static MessageFactory<RdfStreamOptions> getFactory() {
        return RdfStreamOptionsFactory.INSTANCE;
    }

    /**
     * @return this type's descriptor.
     */
    public static Descriptors.Descriptor getDescriptor() {
        return Rdf.eu_ostrzyciel_jelly_core_proto_v1_RdfStreamOptions_descriptor;
    }

    private enum RdfStreamOptionsFactory implements MessageFactory<RdfStreamOptions> {
        INSTANCE;

        @Override
        public RdfStreamOptions create() {
            return RdfStreamOptions.newInstance();
        }
    }

    /**
     * Mutable subclass of the parent class.
     * You can call setters on this class to set the values.
     * When passing the constructed message to the serializer,
     * you should use the parent class (using .asImmutable()) to
     * ensure the message won't be modified by accident.
     */
    public static final class Mutable extends RdfStreamOptions {

        private Mutable() {}

        /**
         * <code>optional string stream_name = 1;</code>
         * @param value the streamName to set
         * @return this
         */
        public Mutable setStreamName(final String value) {
            streamName = value;
            return this;
        }

        /**
         * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.PhysicalStreamType physical_type = 2;</code>
         * @param value the physicalType to set
         * @return this
         */
        public Mutable setPhysicalType(final PhysicalStreamType value) {
            physicalType = value.getNumber();
            return this;
        }

        /**
         * <code>optional bool generalized_statements = 3;</code>
         * @param value the generalizedStatements to set
         * @return this
         */
        public Mutable setGeneralizedStatements(final boolean value) {
            generalizedStatements = value;
            return this;
        }

        /**
         * <code>optional bool rdf_star = 4;</code>
         * @param value the rdfStar to set
         * @return this
         */
        public Mutable setRdfStar(final boolean value) {
            rdfStar = value;
            return this;
        }

        /**
         * <code>optional uint32 max_name_table_size = 9;</code>
         * @param value the maxNameTableSize to set
         * @return this
         */
        public Mutable setMaxNameTableSize(final int value) {
            maxNameTableSize = value;
            return this;
        }

        /**
         * <code>optional uint32 max_prefix_table_size = 10;</code>
         * @param value the maxPrefixTableSize to set
         * @return this
         */
        public Mutable setMaxPrefixTableSize(final int value) {
            maxPrefixTableSize = value;
            return this;
        }

        /**
         * <code>optional uint32 max_datatype_table_size = 11;</code>
         * @param value the maxDatatypeTableSize to set
         * @return this
         */
        public Mutable setMaxDatatypeTableSize(final int value) {
            maxDatatypeTableSize = value;
            return this;
        }

        /**
         * <code>optional .eu.ostrzyciel.jelly.core.proto.v1.LogicalStreamType logical_type = 14;</code>
         * @param value the logicalType to set
         * @return this
         */
        public Mutable setLogicalType(final LogicalStreamType value) {
            logicalType = value.getNumber();
            return this;
        }

        /**
         * <code>optional uint32 version = 15;</code>
         * @param value the version to set
         * @return this
         */
        public Mutable setVersion(final int value) {
            version = value;
            return this;
        }

        @Override
        public Mutable copyFrom(final RdfStreamOptions other) {
            cachedSize = other.cachedSize;
            streamName = other.streamName;
            physicalType = other.physicalType;
            generalizedStatements = other.generalizedStatements;
            rdfStar = other.rdfStar;
            maxNameTableSize = other.maxNameTableSize;
            maxPrefixTableSize = other.maxPrefixTableSize;
            maxDatatypeTableSize = other.maxDatatypeTableSize;
            logicalType = other.logicalType;
            version = other.version;
            return this;
        }

        @Override
        public Mutable mergeFrom(final RdfStreamOptions other) {
            cachedSize = -1;
            streamName = other.streamName;
            setPhysicalTypeValue(other.physicalType);
            setGeneralizedStatements(other.generalizedStatements);
            setRdfStar(other.rdfStar);
            setMaxNameTableSize(other.maxNameTableSize);
            setMaxPrefixTableSize(other.maxPrefixTableSize);
            setMaxDatatypeTableSize(other.maxDatatypeTableSize);
            setLogicalTypeValue(other.logicalType);
            setVersion(other.version);
            return this;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public Mutable mergeFrom(final LimitedCodedInputStream inputLimited) throws IOException {
            // Enabled Fall-Through Optimization
            final CodedInputStream input = inputLimited.in();
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 10: {
                        // streamName
                        streamName = input.readStringRequireUtf8();
                        tag = input.readTag();
                        if (tag != 16) {
                            break;
                        }
                    }
                    case 16: {
                        // physicalType
                        final int value = input.readInt32();
                        if (PhysicalStreamType.forNumber(value) != null) {
                            physicalType = value;
                        }
                        tag = input.readTag();
                        if (tag != 24) {
                            break;
                        }
                    }
                    case 24: {
                        // generalizedStatements
                        generalizedStatements = input.readBool();
                        tag = input.readTag();
                        if (tag != 32) {
                            break;
                        }
                    }
                    case 32: {
                        // rdfStar
                        rdfStar = input.readBool();
                        tag = input.readTag();
                        if (tag != 72) {
                            break;
                        }
                    }
                    case 72: {
                        // maxNameTableSize
                        maxNameTableSize = input.readUInt32();
                        tag = input.readTag();
                        if (tag != 80) {
                            break;
                        }
                    }
                    case 80: {
                        // maxPrefixTableSize
                        maxPrefixTableSize = input.readUInt32();
                        tag = input.readTag();
                        if (tag != 88) {
                            break;
                        }
                    }
                    case 88: {
                        // maxDatatypeTableSize
                        maxDatatypeTableSize = input.readUInt32();
                        tag = input.readTag();
                        if (tag != 112) {
                            break;
                        }
                    }
                    case 112: {
                        // logicalType
                        final int value = input.readInt32();
                        if (LogicalStreamType.forNumber(value) != null) {
                            logicalType = value;
                        }
                        tag = input.readTag();
                        if (tag != 120) {
                            break;
                        }
                    }
                    case 120: {
                        // version
                        version = input.readUInt32();
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        /**
         * Returns this message as an immutable message, without any copies.
         */
        public RdfStreamOptions asImmutable() {
            return this;
        }
    }
}
