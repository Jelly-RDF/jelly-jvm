// Code generated by NeverBlink protoc-java-fast. Do not edit!
package eu.neverblink.jelly.core.proto.v1;

import com.google.protobuf.CodedInputStream;
import com.google.protobuf.CodedOutputStream;
import com.google.protobuf.Descriptors;
import com.google.protobuf.InvalidProtocolBufferException;
import eu.neverblink.protoc.java.runtime.LimitedCodedInputStream;
import eu.neverblink.protoc.java.runtime.MessageFactory;
import eu.neverblink.protoc.java.runtime.ProtoMessage;
import java.io.IOException;
import java.io.InputStream;

/**
 * Protobuf type {@code RdfLiteral}
 * DO NOT INHERIT FROM THIS CLASS!
 * It's not <code>final</code> only to facilitate the Mutable nested subclass.
 */
@SuppressWarnings("hiding")
public abstract class RdfLiteral extends ProtoMessage<RdfLiteral> implements Cloneable {

    public static final byte LANGTAG = 2;

    public static final byte DATATYPE = 3;

    /**
     * <code>optional string lex = 1;</code>
     */
    protected String lex = "";

    /**
     * <code>oneof literalKind { ... }</code>
     */
    protected Object literalKind = null;

    protected byte literalKindNumber = 0;

    private RdfLiteral() {}

    /**
     * @return a new empty instance of {@code Mutable}
     */
    public static Mutable newInstance() {
        return new Mutable();
    }

    public boolean hasLiteralKind() {
        return literalKindNumber != 0;
    }

    /**
     * Returns the <code>literalKind</code> oneof field.
     */
    public Object getLiteralKind() {
        return literalKind;
    }

    /**
     * Returns the set field number of the <code>literalKind</code> oneof field.
     */
    public byte getLiteralKindFieldNumber() {
        return literalKindNumber;
    }

    /**
     * Returns the <code>literalKind</code> oneof field.
     * Use with care, as it will not check if the correct field number is actually set.
     */
    public String getLangtag() {
        return (String) literalKind;
    }

    /**
     * Checks if the <code>literalKind</code> oneof is set to langtag.
     */
    public boolean hasLangtag() {
        return literalKindNumber == 2;
    }

    /**
     * Returns the <code>literalKind</code> oneof field.
     * Use with care, as it will not check if the correct field number is actually set.
     */
    public int getDatatype() {
        return (int) literalKind;
    }

    /**
     * Checks if the <code>literalKind</code> oneof is set to datatype.
     */
    public boolean hasDatatype() {
        return literalKindNumber == 3;
    }

    /**
     * <code>optional string lex = 1;</code>
     * @return the lex
     */
    public String getLex() {
        return lex;
    }

    @Override
    public boolean equals(Object o) {
        if (o == this) {
            return true;
        }
        if (!(o instanceof RdfLiteral)) {
            return false;
        }
        RdfLiteral other = (RdfLiteral) o;
        return (
            lex.equals(other.lex) &&
            literalKindNumber == other.literalKindNumber &&
            (literalKindNumber == 0 || literalKind.equals(other.literalKind))
        );
    }

    @Override
    public void writeTo(final CodedOutputStream output) throws IOException {
        if (!lex.isEmpty()) {
            output.writeRawByte((byte) 10);
            output.writeStringNoTag(lex);
        }
        switch (literalKindNumber) {
            case 2: {
                final var langtag = getLangtag();
                output.writeRawByte((byte) 18);
                output.writeStringNoTag(langtag);
                break;
            }
            case 3: {
                final var datatype = getDatatype();
                output.writeRawByte((byte) 24);
                output.writeUInt32NoTag(datatype);
                break;
            }
        }
    }

    @Override
    protected int computeSerializedSize() {
        int size = 0;
        if (!lex.isEmpty()) {
            size += 1 + CodedOutputStream.computeStringSizeNoTag(lex);
        }
        switch (literalKindNumber) {
            case 2: {
                final var langtag = getLangtag();
                size += 1 + CodedOutputStream.computeStringSizeNoTag(langtag);
                break;
            }
            case 3: {
                final var datatype = getDatatype();
                size += 1 + CodedOutputStream.computeUInt32SizeNoTag(datatype);
                break;
            }
        }
        return size;
    }

    @Override
    public Mutable clone() {
        return newInstance().copyFrom(this);
    }

    public static RdfLiteral parseFrom(final byte[] data) throws InvalidProtocolBufferException {
        return ProtoMessage.mergeFrom(newInstance(), data);
    }

    public static RdfLiteral parseFrom(final LimitedCodedInputStream input) throws IOException {
        return ProtoMessage.mergeFrom(newInstance(), input);
    }

    public static RdfLiteral parseDelimitedFrom(final InputStream input) throws IOException {
        return ProtoMessage.parseDelimitedFrom(input, RdfLiteral.getFactory());
    }

    /**
     * @return factory for creating RdfLiteral messages
     */
    public static MessageFactory<RdfLiteral> getFactory() {
        return RdfLiteralFactory.INSTANCE;
    }

    /**
     * @return this type's descriptor.
     */
    public static Descriptors.Descriptor getDescriptor() {
        return Rdf.eu_ostrzyciel_jelly_core_proto_v1_RdfLiteral_descriptor;
    }

    private enum RdfLiteralFactory implements MessageFactory<RdfLiteral> {
        INSTANCE;

        @Override
        public RdfLiteral create() {
            return RdfLiteral.newInstance();
        }
    }

    /**
     * Mutable subclass of the parent class.
     * You can call setters on this class to set the values.
     * When passing the constructed message to the serializer,
     * you should use the parent class (using .asImmutable()) to
     * ensure the message won't be modified by accident.
     */
    public static final class Mutable extends RdfLiteral {

        private Mutable() {}

        /**
         * Low-level setter for the <code>literalKind</code> oneof field.
         * Use with care, as it will not check the type of the value.
         */
        public Mutable setLiteralKind(Object literalKind, byte number) {
            this.literalKind = literalKind;
            this.literalKindNumber = number;
            return this;
        }

        /**
         * Sets the <code>literalKind</code> oneof field to langtag.
         */
        public Mutable setLangtag(String langtag) {
            this.literalKind = langtag;
            this.literalKindNumber = 2;
            return this;
        }

        /**
         * Sets the <code>literalKind</code> oneof field to datatype.
         */
        public Mutable setDatatype(int datatype) {
            this.literalKind = datatype;
            this.literalKindNumber = 3;
            return this;
        }

        /**
         * <code>optional string lex = 1;</code>
         * @param value the lex to set
         * @return this
         */
        public Mutable setLex(final String value) {
            lex = value;
            return this;
        }

        @Override
        public Mutable copyFrom(final RdfLiteral other) {
            cachedSize = other.cachedSize;
            lex = other.lex;
            this.literalKind = other.literalKind;
            this.literalKindNumber = other.literalKindNumber;
            return this;
        }

        @Override
        public Mutable mergeFrom(final RdfLiteral other) {
            cachedSize = -1;
            lex = other.lex;
            this.literalKind = other.literalKind;
            this.literalKindNumber = other.literalKindNumber;
            return this;
        }

        @Override
        @SuppressWarnings("fallthrough")
        public Mutable mergeFrom(final LimitedCodedInputStream inputLimited) throws IOException {
            // Enabled Fall-Through Optimization
            final CodedInputStream input = inputLimited.in();
            int tag = input.readTag();
            while (true) {
                switch (tag) {
                    case 10: {
                        // lex
                        lex = input.readStringRequireUtf8();
                        tag = input.readTag();
                        if (tag != 18) {
                            break;
                        }
                    }
                    case 18: {
                        // langtag
                        setLangtag(input.readStringRequireUtf8());
                        tag = input.readTag();
                        if (tag != 24) {
                            break;
                        }
                    }
                    case 24: {
                        // datatype
                        setDatatype(input.readUInt32());
                        tag = input.readTag();
                        if (tag != 0) {
                            break;
                        }
                    }
                    case 0: {
                        return this;
                    }
                    default: {
                        if (!input.skipField(tag)) {
                            return this;
                        }
                        tag = input.readTag();
                        break;
                    }
                }
            }
        }

        /**
         * Returns this message as an immutable message, without any copies.
         */
        public RdfLiteral asImmutable() {
            return this;
        }
    }
}
