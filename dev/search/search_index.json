{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jelly-JVM","text":"<p>Jelly-JVM is an implementation of the Jelly serialization format and the gRPC streaming protocol for the Java Virtual Machine (JVM), written in Scala 3<sup>1</sup>. The supported RDF libraries are Apache Jena and Eclipse RDF4J.</p> <p>This collection of libraries aims to provide the full stack of utilities for fast and scalable RDF streaming with the Jelly protocol.</p> <p>Getting started with plugins \u2013 no code required</p> <p>See the getting started guide with plugins for a quick way to use Jelly with your Apache Jena or RDF4J application without writing any code.</p> <p>Getting started for application developers</p> <p>If you want to use the full feature set of Jelly-JVM in your code, see the getting started guide for application developers.</p> <p>This documentation is for the latest development version of Jelly-JVM \u2013 it is not considered stable. If you are looking for the documentation of a stable release, use the version selector on the left of the top navigation bar. See: latest stable version.</p>"},{"location":"#library-modules","title":"Library modules","text":"<p>The implementation is split into a few modules that can be used separately:</p> <ul> <li> <p><code>jelly-core</code> \u2013 implementation of the Jelly serialization format (using the scalapb library), along with generic utilities for converting the deserialized RDF data to/from the representations of RDF libraries (like Apache Jena or RDF4J). </p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-jena</code> \u2013 conversions and interop code for the Apache Jena library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-rdf4j</code> \u2013 conversions and interop code for the RDF4J library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-stream</code> \u2013 utilities for building Reactive Streams of RDF data (based on Pekko Streams). Useful for integrating with gRPC or other streaming protocols (e.g., Kafka, MQTT).</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-grpc</code> \u2013 implementation of a gRPC client and server for the Jelly gRPC streaming protocol.</p> <ul> <li> </li> </ul> </li> </ul>"},{"location":"#plugin-jars","title":"Plugin JARs","text":"<p>We also publish plugin JARs which allow you to use Jelly-JVM with Apache Jena and RDF4J just by dropping the JARs into the classpath. Find out more about using the plugins.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>The Jelly-JVM implementation is compatible with Java 11 and newer. Java 11, 17, and 21 are tested in CI and are guaranteed to work. Jelly is built with Scala 3 LTS releases.</p> <p>The following table shows the compatibility of the Jelly-JVM implementation with other libraries:</p> Jelly Scala Java RDF4J Apache Jena Apache Pekko 1.0.x (current) 3.3.x (LTS)2.13.x<sup>1</sup> 11+ 4.x.x 4.x.x 1.0.x"},{"location":"#documentation","title":"Documentation","text":"<p>Below is a list of all documentation pages about Jelly-JVM. You can also browse the Javadoc using the badges in the module list above. The documentation uses examples written in Scala, but the libraries can be used from Java as well.</p> <ul> <li>Getting started with Jena/RDF4J plugins \u2013 how to use Jelly-JVM as a plugin for Apache Jena or RDF4J, without writing any code.</li> <li>Getting started for application developers \u2013 how to use Jelly-JVM in code.</li> <li>User guide<ul> <li>Apache Jena integration</li> <li>RDF4J integration</li> <li>Reactive streaming</li> <li>gRPC</li> <li>Useful utilities</li> </ul> </li> <li>Developer guide<ul> <li>Releases</li> <li>Implementing Jelly for other libraries</li> </ul> </li> <li>Main Jelly website \u2013 including the Jelly protocol specification and explanation of the various stream types.</li> </ul> <ol> <li> <p>Scala 2.13-compatible builds of Jelly-JVM are available as well. See more details.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"contributing/","title":"Contributing to Jelly-JVM","text":"<p>Jelly-JVM is an open project \u2013 you are welcome to submit issues, pull requests, or just ask questions!</p>"},{"location":"contributing/#submitting-issues","title":"Submitting issues","text":"<p>If you have a question, found a bug, or have an idea for a new feature, please open an issue in the GitHub issue tracker.</p>"},{"location":"contributing/#security-issues","title":"Security issues","text":"<p>If you find a security issue, please do not open a public issue. Instead, send an email to the maintainer \u2013 the email address is listed in the GitHub profile.</p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Pull requests are welcome! Simply fork the GitHub repository and create a new branch for your changes. When you are ready, open a pull request to the <code>main</code> branch.</p> <p>If you are working on a larger feature or a significant change, it is recommended to open an issue first to discuss the idea.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Jelly-JVM uses the exact same documentation system as the main Jelly documentation. Further information on editing the documentation can be found in the Contributing to the Jelly documentation guide.</p>"},{"location":"contributing/#releases","title":"Releases","text":"<p>See the dedicated page on making releases.</p>"},{"location":"contributing/#see-also","title":"See also","text":"<ul> <li>Licensing and citation</li> </ul>"},{"location":"getting-started-devs/","title":"Jelly-JVM \u2013 getting started for developers","text":"<p>If you don't want to code anything and only use Jelly with your Apache Jena/RDF4J application, see the dedicated guide about using Jelly-JVM as a plugin.</p> <p>TODO: for </p> <p>Jelly-JVM can also be used in Java ... TODO ... maybe some example in Java?</p> <p>Although Jelly-JVM is written in Scala 3, we do have Scala 2.13-compatible builds available on Maven Central. Read more about the details and caveats.</p>"},{"location":"getting-started-plugins/","title":"Jelly-JVM \u2013 getting started with Jena/RDF4J plugins","text":"<p>This guide explains how to use Jelly-JVM with Apache Jena or RDF4J as a plugin, without writing a single line of code. Jelly-JVM provides plugin JARs that you can simply drop in the appropriate directory to get Jelly format support in your application.</p>"},{"location":"getting-started-plugins/#installation","title":"Installation","text":""},{"location":"getting-started-plugins/#apache-jena-apache-jena-fuseki","title":"Apache Jena, Apache Jena Fuseki","text":"<p>You can simply add Jelly format support to Apache Jena or Apacha Jena Fuseki with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  latest development version from here,  or you can go the the releases page on GitHub to download a different version of the <code>jelly-jena-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your Apache Jena version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath:<ul> <li>For Apache Jena Fuseki, simply place the file in <code>$FUSEKI_BASE/extra/</code> directory. <code>$FUSEKI_BASE</code> is the directory usually called <code>run</code> where you have files such as <code>config.ttl</code> and <code>shiro.ini</code>. You will most likely need to create the <code>extra</code> directory yourself.</li> <li>For Apache Jena, place the file in the <code>lib/</code> directory of your Jena installation.</li> <li>For other applications, consult the manual of the application.</li> </ul> </li> <li>You can now use Jelly format for parsing, serialization, and streaming serialization in your Jena application.</li> </ul>"},{"location":"getting-started-plugins/#eclipse-rdf4j","title":"Eclipse RDF4J","text":"<p>You can simply add Jelly format support to an application based on RDF4J with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  latest development version from here,  or you can go the the releases page on GitHub to download a specific version of the <code>jelly-rdf4j-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your RDF4J version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath. Consult the manual of your application for the exact location.</li> <li>You can now use Jelly format for parsing, serialization, and streaming serialization in your RDF4J application.</li> </ul>"},{"location":"getting-started-plugins/#supported-features","title":"Supported features","text":"<p>The Jelly-JVM plugin JARs provide the following features:</p> <ul> <li>Full support for parsing and serialization of RDF data (triples and quads) in the Jelly format.<ul> <li>In Apache Jena also the stream serialization is supported.</li> </ul> </li> <li>Recognizing the <code>.jelly</code> file extension.</li> <li>Recognizing the <code>application/x-jelly-rdf</code> media type.</li> </ul> <p>The Jelly format is registered under the name <code>jelly</code> in the RDF libraries, so you can use it in the same way as other formats like Turtle, RDF/XML, or JSON-LD.</p>"},{"location":"getting-started-plugins/#see-also","title":"See also","text":"<ul> <li>Getting started for developers \u2013 if you want to get your hands dirty with code and get more features out of Jelly.</li> </ul>"},{"location":"licensing/","title":"Licensing and citation","text":"<p>Jelly-JVM is licensed under the Apache License 2.0.</p>"},{"location":"licensing/#attribution-citation","title":"Attribution / citation","text":"<p>If you use Jelly-JVM in your research, please the most recent paper about Jelly:</p> <p>Sowi\u0144ski, P., Wasielewska-Michniewska, K., Ganzha, M., &amp; Paprzycki, M. (2022, October). Efficient RDF streaming for the edge-cloud continuum. In 2022 IEEE 8th World Forum on Internet of Things (WF-IoT) (pp. 1-8). IEEE.</p> <p>Or use this BibTeX entry:</p> <pre><code>@inproceedings{sowinski2022efficient,\n  title={Efficient RDF streaming for the edge-cloud continuum},\n  author={Sowi{\\'n}ski, Piotr and Wasielewska-Michniewska, Katarzyna and Ganzha, Maria and Paprzycki, Marcin and others},\n  booktitle={2022 IEEE 8th World Forum on Internet of Things (WF-IoT)},\n  pages={1--8},\n  year={2022},\n  organization={IEEE},\n  doi={10.1109/WF-IoT54382.2022.10152225}\n}\n</code></pre> <p>This paper describes an earlier version of Jelly from 2022. A new paper is in preparation.</p>"},{"location":"licensing/#jelly-maintainer","title":"Jelly maintainer","text":"<p>Jelly-JVM was created and is maintained by Piotr Sowi\u0144ski (Ostrzyciel) \u2013 GitHub.</p>"},{"location":"licensing/#see-also","title":"See also","text":"<ul> <li>Contributing to Jelly-JVM</li> </ul>"},{"location":"dev/implementing/","title":"Developer guide \u2013 implementing conversions for other libraries","text":"<p>Currently converters for the two most popular RDF JVM libraries are implemented \u2013 RDF4J and Jena. But it is possible to implement your own converters and adapt the Jelly serialization code to any RDF library with little effort.</p> <p>To do this, you will need to implement three traits (interfaces in Java) from the <code>jelly-core</code> module: <code>ProtoEncoder</code>, <code>ProtoDecoderConverter</code>, and <code>ConverterFactory</code>.</p> <ul> <li> <p>ProtoEncoder (serialization)</p> <ul> <li><code>get*</code> methods deconstruct triple statements, quad statements, and quoted triples (RDF-star). You can make them <code>inline</code>.</li> <li><code>nodeToProto</code> and <code>graphToProto</code> should translate into Jelly's representation all possible variations of RDF terms in the SPO and G positions, respectively.</li> <li>Example implementation for Jena: JenaProtoEncoder</li> <li>You can skip implementing this trait if you don't need serialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</li> </ul> </li> <li> <p>ProtoDecoderConverter (deserialization)</p> <ul> <li>The <code>make*</code> methods should construct new RDF terms and statements. You can make them <code>inline</code>.</li> <li>Example implementation for Jena: JenaDecoderConverter</li> <li>You can skip implementing this trait if you don't need deserialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</li> </ul> </li> <li> <p>ConverterFactory \u2013 wrapper that allows other modules to use your converter.</p> <ul> <li>The methods should just return new instances of your <code>ProtoEncoder</code> and <code>ProtoDecoderConverter</code> implementations.</li> <li>Example for Jena: JenaConverterFactory</li> </ul> </li> </ul>"},{"location":"dev/releases/","title":"Developer guide \u2013 releases","text":""},{"location":"dev/releases/#full-versioned-releases","title":"Full (versioned) releases","text":"<p>Full (versioned) releases are created manually and follow the Semantic Versioning scheme for binary compatibility.</p> <p>To create a new tagged release (example for version 1.2.3): <pre><code>$ git checkout main\n$ git pull\n$ git tag v1.2.3\n$ git push origin v1.2.3\n</code></pre></p> <p>The rest (packaging and release creation) will be handled automatically by the CI. The release will be pushed to Maven Central.</p>"},{"location":"dev/releases/#snapshot-releases","title":"Snapshot releases","text":"<p>Snapshot releases are triggered automatically by commits in the <code>main</code> branch. Snapshots are pushed to the Sonatype snapshot repository.</p>"},{"location":"user/grpc/","title":"User guide \u2013 gRPC","text":""},{"location":"user/grpc/#example-grpc-pubsub","title":"Example \u2013 gRPC pub/sub","text":""},{"location":"user/jena/","title":"Apache Jena integration","text":"<p>...</p> <p>If you just want to use Jelly with your Apache Jena / Apache Jena Fuseki, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/rdf4j/","title":"RDF4J integration","text":"<p>...</p> <p>If you just want to use Jelly with your RDF4J application, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/reactive/","title":"User guide \u2013 reactive streaming","text":"<p>TODO</p>"},{"location":"user/reactive/#example-streaming-with-kafka","title":"Example: streaming with Kafka","text":""},{"location":"user/reactive/#byte-streams","title":"Byte streams","text":"<p>TODO</p> <p>(referenced by specification/serialization.md)</p>"},{"location":"user/scala2/","title":"Scala 2 builds","text":"<p>Jelly-JVM is written in Scala 3, but we also provide packages that mostly work with Scala 2.13. They include only Scala 2 dependencies and are published to Maven Central.</p>"},{"location":"user/scala2/#how-to-use-this","title":"How to use this?","text":"<ul> <li>In your project enable the Scala 2.13 TASTy reader \u2013 read more in Scala docs.</li> <li>Add Jelly-JVM dependencies with the <code>_2.13</code> suffilx, e.g., <code>eu.ostrzyciel.jelly %% jelly-core % 0.14.0</code> in sbt (assuming you are building a Scala 2.13 project).</li> <li>If you get conflicting Scala version suffix errors from sbt, you may need to add exclusion rules like this:     <pre><code>libraryDependencies ++= List(\n  \"eu.ostrzyciel.jelly\" %% \"jelly-stream\" % jellyVersion,\n  \"eu.ostrzyciel.jelly\" %% \"jelly-grpc\" % jellyVersion,\n  \"eu.ostrzyciel.jelly\" %% \"jelly-rdf4j\" % jellyVersion,\n).map(_ excludeAll (\n  // These are two leftover Scala 3 dependencies that are improperly handled in the pseudo-Scala 2\n  // version of Jelly due to a quirk with how the scalapb plugin works. We must exclude them here.\n  ExclusionRule(organization = \"org.apache.pekko\", name = \"pekko-grpc-runtime_3\"),\n  ExclusionRule(organization = \"com.thesamet.scalapb\", name = \"scalapb-runtime_3\"),\n))\n</code></pre></li> </ul> <p>That's it!</p>"},{"location":"user/scala2/#is-this-supported","title":"Is this supported?","text":"<p>Kind of. It does work (we tested it), but it's not a perfect solution, as Jelly-JVM was from the start designed only for Scala 3. Support for Scala 2 will be dropped in Jelly-JVM 1.2.0 \u2013 the support will remain as-is in versions 1.0.x and 1.1.x.</p>"},{"location":"user/scala2/#technical-notes-maintainer-guide","title":"Technical notes \u2013 maintainer guide","text":"<p>The thing is a rather ugly hack in sbt. On the one hand, we need sbt to think we need Scala 2 dependencies for one build, and that we want to publish these artifacts with the <code>_2.13</code> suffix in Maven. On the other, this is still Scala 3 code and it must be compiled with the Scala 3 compiler.</p> <p>The solution looks like this \u2013 we trick sbt, by having two Scala 3 builds (one with a slightly different version), and then treating one of them differently using conditionals. Don't judge me.</p>"},{"location":"user/utilities/","title":"Useful utilities","text":"<p>TODO: all utilities defined in <code>core</code>, including obtaining RDF-STaX annotations (describe its potential uses \u2013 external metadata, etc. \u2013 in the docs.) and constructing logical types from RDF-STaX IRIs.</p>"}]}