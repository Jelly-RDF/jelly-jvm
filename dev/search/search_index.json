{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Jelly-JVM","text":"<p>Jelly-JVM is an implementation of the Jelly serialization format and the gRPC streaming protocol for the Java Virtual Machine (JVM), written in Scala 3<sup>1</sup>. The supported RDF libraries are Apache Jena and Eclipse RDF4J.</p> <p>This collection of libraries aims to provide the full stack of utilities for fast and scalable RDF streaming with the Jelly protocol.</p> <p>Getting started with plugins \u2013 no code required</p> <p>See the getting started guide with plugins for a quick way to use Jelly with your Apache Jena or RDF4J application without writing any code.</p> <p>Getting started for application developers</p> <p>If you want to use the full feature set of Jelly-JVM in your code, see the getting started guide for application developers.</p> <p>This documentation is for the latest development version of Jelly-JVM \u2013 it is not considered stable. If you are looking for the documentation of a stable release, use the version selector on the left of the top navigation bar. See: latest stable version.</p>"},{"location":"#library-modules","title":"Library modules","text":"<p>The implementation is split into a few modules that can be used separately:</p> <ul> <li> <p><code>jelly-core</code> \u2013 implementation of the Jelly serialization format (using the scalapb library), along with generic utilities for converting the deserialized RDF data to/from the representations of RDF libraries (like Apache Jena or RDF4J). </p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-jena</code> \u2013 conversions and interop code for the Apache Jena library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-rdf4j</code> \u2013 conversions and interop code for the RDF4J library.</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-stream</code> \u2013 utilities for building Reactive Streams of RDF data (based on Pekko Streams). Useful for integrating with gRPC or other streaming protocols (e.g., Kafka, MQTT).</p> <ul> <li> </li> </ul> </li> <li> <p><code>jelly-grpc</code> \u2013 implementation of a gRPC client and server for the Jelly gRPC streaming protocol.</p> <ul> <li> </li> </ul> </li> </ul>"},{"location":"#plugin-jars","title":"Plugin JARs","text":"<p>We also publish plugin JARs which allow you to use Jelly-JVM with Apache Jena and RDF4J just by dropping the JARs into the classpath. Find out more about using the plugins.</p>"},{"location":"#compatibility","title":"Compatibility","text":"<p>The Jelly-JVM implementation is compatible with Java 11 and newer. Java 11, 17, and 21 are tested in CI and are guaranteed to work. Jelly is built with Scala 3 LTS releases.</p> <p>The following table shows the compatibility of the Jelly-JVM implementation with other libraries:</p> Jelly Scala Java RDF4J Apache Jena Apache Pekko 1.0.x (current) 3.3.x (LTS)2.13.x<sup>1</sup> 11+ 4.x.x 4.x.x 1.0.x <p>See the compatibility policy for more details and the release notes on GitHub.</p>"},{"location":"#documentation","title":"Documentation","text":"<p>Below is a list of all documentation pages about Jelly-JVM. You can also browse the Javadoc using the badges in the module list above. The documentation uses examples written in Scala, but the libraries can be used from Java as well.</p> <ul> <li>Getting started with Jena/RDF4J plugins \u2013 how to use Jelly-JVM as a plugin for Apache Jena or RDF4J, without writing any code.</li> <li>Getting started for application developers \u2013 how to use Jelly-JVM in code.</li> <li>User guide<ul> <li>Apache Jena integration</li> <li>RDF4J integration</li> <li>Reactive streaming</li> <li>gRPC</li> <li>Useful utilities</li> <li>Compatibility policy</li> <li>Scala 2.13 builds</li> </ul> </li> <li>Developer guide<ul> <li>Releases</li> <li>Implementing Jelly for other libraries</li> </ul> </li> <li>Contributing to Jelly-JVM</li> <li>License and citation</li> <li>Release notes on GitHub</li> <li>Main Jelly website \u2013 including the Jelly protocol specification and explanation of the various stream types.</li> </ul> <ol> <li> <p>Scala 2.13-compatible builds of Jelly-JVM are available as well. See more details.\u00a0\u21a9\u21a9</p> </li> </ol>"},{"location":"contributing/","title":"Contributing to Jelly-JVM","text":"<p>Jelly-JVM is an open project \u2013 you are welcome to submit issues, pull requests, or just ask questions!</p>"},{"location":"contributing/#submitting-issues","title":"Submitting issues","text":"<p>If you have a question, found a bug, or have an idea for a new feature, please open an issue in the GitHub issue tracker.</p>"},{"location":"contributing/#security-issues","title":"Security issues","text":"<p>If you find a security issue or vulnerability, please do not open a public issue. Instead, use the dedicated vulnerability reporting page.</p>"},{"location":"contributing/#pull-requests","title":"Pull requests","text":"<p>Pull requests are welcome! Simply fork the GitHub repository and create a new branch for your changes. When you are ready, open a pull request to the <code>main</code> branch.</p> <p>If you are working on a larger feature or a significant change, it is recommended to open an issue first to discuss the idea.</p>"},{"location":"contributing/#documentation","title":"Documentation","text":"<p>Jelly-JVM uses the exact same documentation system as the main Jelly documentation. Further information on editing the documentation can be found in the Contributing to the Jelly documentation guide.</p>"},{"location":"contributing/#releases","title":"Releases","text":"<p>See the dedicated page on making releases.</p>"},{"location":"contributing/#see-also","title":"See also","text":"<ul> <li>Licensing and citation</li> </ul>"},{"location":"getting-started-devs/","title":"Jelly-JVM \u2013 getting started for developers","text":"<p>If you don't want to code anything and only use Jelly with your Apache Jena/RDF4J application, see the dedicated guide about using Jelly-JVM as a plugin.</p> <p>This guide explains a few of the basic functionalities of Jelly-JVM and how to use them in your code. Jelly-JVM is written in Scala, but it can be used from Java as well. However, in this guide, we will focus on Scala 3<sup>1</sup>.</p>"},{"location":"getting-started-devs/#quick-start-plain-old-files","title":"Quick start \u2013 plain old files","text":"<p>Depending on your RDF library of choice (Apache Jena or RDF4J), you should import one of two dependencies: <code>jelly-jena</code> or <code>jelly-rdf4j</code><sup>2</sup>. In our examples we will use Jena, so let's add this to your <code>build.sbt</code> file (this would be the same for other build tools like Maven or Gradle):</p> build.sbt<pre><code>lazy val jellyVersion = \"0.14.1\"\n\nlibraryDependencies ++= Seq(\n  \"eu.ostrzyciel.jelly\" %% \"jelly-jena\" % jellyVersion,\n)\n</code></pre> <p>Now you can serialize/deserialize Jelly data with Apache Jena. Jelly is fully integrated with Jena, so it should all just magically work. Here is a simple example of reading a <code>.jelly</code> file (in this case, a metadata file from RiverBench) with RIOT:</p> Deserialization example (Scala 3)<pre><code>import eu.ostrzyciel.jelly.convert.jena.riot.*\nimport org.apache.jena.riot.RDFDataMgr\n\n// Load an RDF graph from a Jelly file\nval model = RDFDataMgr.loadModel(\n  \"https://w3id.org/riverbench/v/2.0.1.jelly\", \n  JellyLanguage.JELLY\n)\n// Print the size of the model\nprintln(s\"Loaded an RDF graph with ${model.size} triples\")\n</code></pre> <p>Serialization is just as easy:</p> Serialization example (Scala 3)<pre><code>import eu.ostrzyciel.jelly.convert.jena.riot.*\nimport org.apache.jena.riot.RDFDataMgr\n\nimport java.io.FileOutputStream\nimport scala.util.Using\n\n// Omitted here: creating an RDF model.\n// You can use the one from the previous example.\n\nUsing.resource(new FileOutputStream(\"metadata.jelly\")) { out =&gt;\n  // Write the model to a Jelly file\n  RDFDataMgr.write(out, model, JellyLanguage.JELLY)\n  println(\"Saved the model to metadata.jelly\")\n}\n</code></pre> <p> Read more about using Jelly-JVM with Apache Jena</p> <p> Read more about using Jelly-JVM with RDF4J</p>"},{"location":"getting-started-devs/#rdf-streams","title":"RDF streams","text":"<p>Now, the real power of Jelly lies in its streaming capabilities. Not only can it stream individual RDF triples/quads (this is called flat streaming), but it can also very effectively handle streams of RDF graphs or datasets. To work with streams, you need to use the <code>jelly-stream</code> module, which is based on the Apache Pekko Streams library. So, let's update our dependencies:</p> build.sbt<pre><code>lazy val jellyVersion = \"0.14.1\"\n\nlibraryDependencies ++= Seq(\n  \"eu.ostrzyciel.jelly\" %% \"jelly-jena\" % jellyVersion,\n  \"eu.ostrzyciel.jelly\" %% \"jelly-stream\" % jellyVersion,\n)\n</code></pre> <p>Now, let's say we have a stream of RDF graphs \u2013 for example each graph corresponds to one set of measurements from an IoT sensor. We want to have a stream that turns these graphs into their serialized representations (byte arrays), which we can then send over the network. Here is how to do it:</p> Reactive streaming example (Scala 3)<pre><code>// We need to import \"jena.given\" for Jena-to-Jelly conversions\nimport eu.ostrzyciel.jelly.convert.jena.given\nimport eu.ostrzyciel.jelly.convert.jena.riot.*\nimport eu.ostrzyciel.jelly.core.JellyOptions\nimport eu.ostrzyciel.jelly.stream.*\nimport org.apache.jena.riot.RDFDataMgr\nimport org.apache.pekko.actor.ActorSystem\nimport org.apache.pekko.stream.scaladsl.*\n\nimport scala.concurrent.ExecutionContext\n\n// We will need a Pekko actor system to run the streams\ngiven actorSystem: ActorSystem = ActorSystem()\n// And an execution context for the futures\ngiven ExecutionContext = actorSystem.getDispatcher\n\n// Load an RDF graph for testing\nval model = RDFDataMgr.loadModel(\n  \"https://w3id.org/riverbench/v/2.0.1.jelly\", \n  JellyLanguage.JELLY\n)\n\nSource.repeat(model) // Create a stream of the same model over and over\n  .take(10) // Take only the first 10 elements in the stream\n  .map(_.asTriples) // Convert each model to an iterable of triples\n  .via(EncoderFlow.graphStream( // Encode each iterable to a Jelly stream frame\n    maybeLimiter = None, // 1 RDF graph = 1 message\n    JellyOptions.smallStrict, // Jelly compression settings preset\n  ))\n  .via(JellyIo.toBytes) // Convert the stream frames to a byte arrays\n  .runForeach { bytes =&gt;\n    // Just print the length of each byte array in the stream.\n    // You can also hook this up to MQTT, Kafka, etc.\n    println(s\"Streamed ${bytes.length} bytes\")\n  }\n  .onComplete(_ =&gt; actorSystem.terminate())\n</code></pre> <p>Jelly will compress this stream on-the-fly, so if the data is repetitive, it will be very efficient. If you run this code, you will notice that the byte sizes for the later graphs are smaller, even though we are sending the same graph over and over again. But, even if each graph is completely different, Jelly still should be much faster than other serialization formats.</p> <p>These streams are very powerful, because they are reactive and asynchronous \u2013 in short, this means you can hook this up to any data source and any data sink \u2013 and you can scale it up as much as you want. If you are unfamiliar with the concept of reactive streams, we recommend you start with this Apache Pekko Streams guide.</p> <p>Jelly-JVM supports streaming serialization and deserialization of all types of streams in the RDF Stream Taxonomy. You can read more about the theory of this and all available stream types in the Jelly protocol documentation.</p> <p> Learn more about reactive streaming with Jelly-JVM</p> <p> Learn more about the types of streams in Jelly</p>"},{"location":"getting-started-devs/#grpc-streaming","title":"gRPC streaming","text":"<p>Jelly is a bit more than just a serialization format \u2013 it also defines a gRPC-based straming protocol. You can use it for streaming RDF data between microservices, to build a pub/sub system, or to publish RDF data to the web.</p> <p> Learn more about using Jelly gRPC protocol servers and clients</p>"},{"location":"getting-started-devs/#further-reading","title":"Further reading","text":"<ul> <li>Using Jelly-JVM with Apache Jena</li> <li>Using Jelly-JVM with RDF4J</li> <li>Reactive streaming with Jelly-JVM \u2013 using the <code>jelly-stream</code> module and Apache Pekko Streams</li> <li>Using Jelly gRPC protocol servers and clients</li> <li>Other useful utilities in Jelly-JVM</li> </ul>"},{"location":"getting-started-devs/#example-applications-using-jelly-jvm","title":"Example applications using Jelly-JVM","text":"<ul> <li>The <code>examples</code> directory in the Jelly-JVM repo contains code snippets that demonstrate how to use the library in various scenarios.</li> <li>Jelly JVM benchmarks \u2013 research software for testing the performance of Jelly-JVM and other RDF serializations in Apache Jena. It uses most Jelly-JVM features.</li> <li>RiverBench ci-worker \u2013 a real-world application that is used for processing large RDF datasets in a CI/CD pipeline. It uses Jelly-JVM for serialization and deserialization with Apache Jena. It also uses extensively Apache Pekko Streams.</li> </ul>"},{"location":"getting-started-devs/#questions","title":"Questions?","text":"<p>If you have any questions about using Jelly-JVM, feel free to open an issue on GitHub.</p> <ol> <li> <p>Jelly-JVM is written in Scala 3, but we do have Scala 2.13-compatible builds available on Maven Central. Read more about the details and caveats.\u00a0\u21a9</p> </li> <li> <p>There is nothing stopping you from using both at the same time. You can also pretty easily add support for any other Java-based RDF library by implementing a few interfaces. More details here.\u00a0\u21a9</p> </li> </ol>"},{"location":"getting-started-plugins/","title":"Jelly-JVM \u2013 getting started with Jena/RDF4J plugins","text":"<p>This guide explains how to use Jelly-JVM with Apache Jena or RDF4J as a plugin, without writing a single line of code. Jelly-JVM provides plugin JARs that you can simply drop in the appropriate directory to get Jelly format support in your application.</p>"},{"location":"getting-started-plugins/#installation","title":"Installation","text":""},{"location":"getting-started-plugins/#apache-jena-apache-jena-fuseki","title":"Apache Jena, Apache Jena Fuseki","text":"<p>You can simply add Jelly format support to Apache Jena or Apacha Jena Fuseki with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  latest development version from here,  or you can go the the releases page on GitHub to download a different version of the <code>jelly-jena-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your Apache Jena version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath:<ul> <li>For Apache Jena Fuseki, simply place the file in <code>$FUSEKI_BASE/extra/</code> directory. <code>$FUSEKI_BASE</code> is the directory usually called <code>run</code> where you have files such as <code>config.ttl</code> and <code>shiro.ini</code>. You will most likely need to create the <code>extra</code> directory yourself.</li> <li>For Apache Jena, place the file in the <code>lib/</code> directory of your Jena installation.</li> <li>For other applications, consult the manual of the application.</li> </ul> </li> <li>You can now use Jelly format for parsing, serialization, and streaming serialization in your Jena application.</li> </ul>"},{"location":"getting-started-plugins/#eclipse-rdf4j","title":"Eclipse RDF4J","text":"<p>You can simply add Jelly format support to an application based on RDF4J with Jelly's plugin JAR.</p> <ul> <li>First, download the plugin JAR. You can download the  latest development version from here,  or you can go the the releases page on GitHub to download a specific version of the <code>jelly-rdf4j-plugin.jar</code> file.<ul> <li>Note that the Jelly version must be compatible with your RDF4J version. Consult the compatibility table.</li> </ul> </li> <li>Place the file in your classpath. Consult the manual of your application for the exact location.</li> <li>You can now use Jelly format for parsing, serialization, and streaming serialization in your RDF4J application.</li> </ul>"},{"location":"getting-started-plugins/#supported-features","title":"Supported features","text":"<p>The Jelly-JVM plugin JARs provide the following features:</p> <ul> <li>Full support for parsing and serialization of RDF data (triples and quads) in the Jelly format.<ul> <li>In Apache Jena also the stream serialization is supported.</li> </ul> </li> <li>Recognizing the <code>.jelly</code> file extension.</li> <li>Recognizing the <code>application/x-jelly-rdf</code> media type.</li> </ul> <p>The Jelly format is registered under the name <code>jelly</code> in the RDF libraries, so you can use it in the same way as other formats like Turtle, RDF/XML, or JSON-LD.</p>"},{"location":"getting-started-plugins/#see-also","title":"See also","text":"<ul> <li>Getting started for developers \u2013 if you want to get your hands dirty with code and get more features out of Jelly.</li> </ul>"},{"location":"licensing/","title":"Licensing and citation","text":"<p>Jelly-JVM is licensed under the Apache License 2.0.</p>"},{"location":"licensing/#attribution-citation","title":"Attribution / citation","text":"<p>If you use Jelly-JVM in your research, please the most recent paper about Jelly:</p> <p>Sowi\u0144ski, P., Wasielewska-Michniewska, K., Ganzha, M., &amp; Paprzycki, M. (2022, October). Efficient RDF streaming for the edge-cloud continuum. In 2022 IEEE 8th World Forum on Internet of Things (WF-IoT) (pp. 1-8). IEEE.</p> <p>Or use this BibTeX entry:</p> <pre><code>@inproceedings{sowinski2022efficient,\n  title={Efficient RDF streaming for the edge-cloud continuum},\n  author={Sowi{\\'n}ski, Piotr and Wasielewska-Michniewska, Katarzyna and Ganzha, Maria and Paprzycki, Marcin and others},\n  booktitle={2022 IEEE 8th World Forum on Internet of Things (WF-IoT)},\n  pages={1--8},\n  year={2022},\n  organization={IEEE},\n  doi={10.1109/WF-IoT54382.2022.10152225}\n}\n</code></pre> <p>This paper describes an earlier version of Jelly from 2022. A new paper is in preparation.</p>"},{"location":"licensing/#jelly-maintainer","title":"Jelly maintainer","text":"<p>Jelly-JVM was created and is maintained by Piotr Sowi\u0144ski (Ostrzyciel) \u2013 GitHub.</p>"},{"location":"licensing/#see-also","title":"See also","text":"<ul> <li>Contributing to Jelly-JVM</li> </ul>"},{"location":"dev/implementing/","title":"Developer guide \u2013 implementing conversions for other libraries","text":"<p>Currently converters for the two most popular RDF JVM libraries are implemented \u2013 RDF4J and Jena. But it is possible to implement your own converters and adapt the Jelly serialization code to any RDF library with little effort.</p> <p>To do this, you will need to implement three traits (interfaces in Java) from the <code>jelly-core</code> module: <code>ProtoEncoder</code>, <code>ProtoDecoderConverter</code>, and <code>ConverterFactory</code>.</p> <ul> <li> <p>ProtoEncoder (serialization)</p> <ul> <li><code>get*</code> methods deconstruct triple statements, quad statements, and quoted triples (RDF-star). You can make them <code>inline</code>.</li> <li><code>nodeToProto</code> and <code>graphToProto</code> should translate into Jelly's representation all possible variations of RDF terms in the SPO and G positions, respectively.</li> <li>Example implementation for Jena: JenaProtoEncoder</li> <li>You can skip implementing this trait if you don't need serialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</li> </ul> </li> <li> <p>ProtoDecoderConverter (deserialization)</p> <ul> <li>The <code>make*</code> methods should construct new RDF terms and statements. You can make them <code>inline</code>.</li> <li>Example implementation for Jena: JenaDecoderConverter</li> <li>You can skip implementing this trait if you don't need deserialization.</li> <li>You can also skip implementing some methods (make them throw an exception or return null) if, for example, you don't want to work with quads or RDF-start.</li> </ul> </li> <li> <p>ConverterFactory \u2013 wrapper that allows other modules to use your converter.</p> <ul> <li>The methods should just return new instances of your <code>ProtoEncoder</code> and <code>ProtoDecoderConverter</code> implementations.</li> <li>Example for Jena: JenaConverterFactory</li> </ul> </li> </ul>"},{"location":"dev/releases/","title":"Developer guide \u2013 releases","text":""},{"location":"dev/releases/#full-versioned-releases","title":"Full (versioned) releases","text":"<p>Full (versioned) releases are created manually and follow the Semantic Versioning scheme for binary compatibility.</p> <p>To create a new tagged release (example for version 1.2.3): <pre><code>$ git checkout main\n$ git pull\n$ git tag v1.2.3\n$ git push origin v1.2.3\n</code></pre></p> <p>The rest (packaging and release creation) will be handled automatically by the CI. The release will be pushed to Maven Central.</p>"},{"location":"dev/releases/#snapshot-releases","title":"Snapshot releases","text":"<p>Snapshot releases are triggered automatically by commits in the <code>main</code> branch. Snapshots are pushed to the Sonatype snapshot repository.</p>"},{"location":"user/compatibility/","title":"Compatibility policy","text":"<p>Jelly-JVM follows Semantic Versioning 2.0.0, with MAJOR.MINOR.PATCH releases. Please see the compatibility table on the main page for the current compatibility information. The documentation is versioned to match each Jelly-JVM MAJOR.MINOR version.</p>"},{"location":"user/compatibility/#jvm-and-scala","title":"JVM and Scala","text":"<p>The current version of Jelly-JVM is compatible with Java 11 and newer. Java 11, 17, and 21 are tested in CI and are guaranteed to work. We recommend using a recent release of GraalVM to get the best performance.</p> <p>Jelly is built with Scala 3 LTS releases, however, Scala 2.13-compatible builds are available as well.</p>"},{"location":"user/compatibility/#rdf-libraries","title":"RDF libraries","text":"<p>Major-version upgrades of RDF4J and Apache Jena (e.g., updating from 4.0.x to 5.0.x) are done in Jelly-JVM MINOR releases. Jelly-JVM generally does not use any complex features of these libraries, so you can expect it to work with multiple versions without any problems. For example, although Jelly-JVM 1.0.x officially supports only Jena 4.x.x, it works fine with 5.0.x.</p> <p>If you do encounter any compatibility issues, please report them on the issue tracker.</p>"},{"location":"user/compatibility/#apache-jena-4xx","title":"Apache Jena 4.x.x","text":"<p>Jelly-JVM 1.0.x only supports the RDF 1.1 mode of Apache Jena (enabled by default in Jena 4.x.x). The RDF 1.0 mode was removed entirely in Apache Jena 5.</p>"},{"location":"user/compatibility/#internal-vs-external-apis","title":"Internal vs external APIs","text":"<p>Generally, all public classes and methods in Jelly-JVM are considered part of the public API. However, there are some exceptions.</p> <p>Auto-generated classes in the <code>jelly-core</code> module, <code>eu.ostrzyciel.jelly.core.proto.v1</code> package are not considered part of the public API, although we will avoid any incompatibilities where possible. These classes may change between MINOR releases.</p>"},{"location":"user/compatibility/#see-also","title":"See also","text":"<ul> <li>Scala 2.13 builds</li> <li>Release notes on GitHub</li> <li>Making Jelly-JVM releases</li> <li>Contributing to Jelly-JVM</li> </ul>"},{"location":"user/grpc/","title":"User guide \u2013 gRPC","text":""},{"location":"user/grpc/#example-grpc-pubsub","title":"Example \u2013 gRPC pub/sub","text":""},{"location":"user/jena/","title":"Apache Jena integration","text":"<p>...</p> <p>If you just want to use Jelly with your Apache Jena / Apache Jena Fuseki, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/rdf4j/","title":"RDF4J integration","text":"<p>...</p> <p>If you just want to use Jelly with your RDF4J application, you can use the Jelly-JVM plugin JAR. See the dedicated guide for more information.</p>"},{"location":"user/reactive/","title":"User guide \u2013 reactive streaming","text":"<p>TODO</p>"},{"location":"user/reactive/#example-streaming-with-kafka","title":"Example: streaming with Kafka","text":""},{"location":"user/reactive/#byte-streams","title":"Byte streams","text":"<p>TODO</p> <p>(referenced by specification/serialization.md)</p>"},{"location":"user/scala2/","title":"Scala 2 builds","text":"<p>Jelly-JVM is written in Scala 3, but we also provide packages that mostly work with Scala 2.13. They include only Scala 2 dependencies and are published to Maven Central.</p>"},{"location":"user/scala2/#how-to-use-this","title":"How to use this?","text":"<ul> <li>In your project enable the Scala 2.13 TASTy reader \u2013 read more in Scala docs.</li> <li>Add Jelly-JVM dependencies with the <code>_2.13</code> suffilx, e.g., <code>eu.ostrzyciel.jelly %% jelly-core % 0.14.0</code> in sbt (assuming you are building a Scala 2.13 project).</li> <li>If you get conflicting Scala version suffix errors from sbt, you may need to add exclusion rules like this:     <pre><code>libraryDependencies ++= List(\n  \"eu.ostrzyciel.jelly\" %% \"jelly-stream\" % jellyVersion,\n  \"eu.ostrzyciel.jelly\" %% \"jelly-grpc\" % jellyVersion,\n  \"eu.ostrzyciel.jelly\" %% \"jelly-rdf4j\" % jellyVersion,\n).map(_ excludeAll (\n  // These are two leftover Scala 3 dependencies that are improperly handled in the pseudo-Scala 2\n  // version of Jelly due to a quirk with how the scalapb plugin works. We must exclude them here.\n  ExclusionRule(organization = \"org.apache.pekko\", name = \"pekko-grpc-runtime_3\"),\n  ExclusionRule(organization = \"com.thesamet.scalapb\", name = \"scalapb-runtime_3\"),\n))\n</code></pre></li> </ul> <p>That's it!</p>"},{"location":"user/scala2/#is-this-supported","title":"Is this supported?","text":"<p>Kind of. It does work (we tested it), but it's not a perfect solution, as Jelly-JVM was from the start designed only for Scala 3. Support for Scala 2 will be dropped in Jelly-JVM 1.2.0 \u2013 the support will remain as-is in versions 1.0.x and 1.1.x.</p>"},{"location":"user/scala2/#technical-notes-maintainer-guide","title":"Technical notes \u2013 maintainer guide","text":"<p>The thing is a rather ugly hack in sbt. On the one hand, we need sbt to think we need Scala 2 dependencies for one build, and that we want to publish these artifacts with the <code>_2.13</code> suffix in Maven. On the other, this is still Scala 3 code and it must be compiled with the Scala 3 compiler.</p> <p>The solution looks like this \u2013 we trick sbt, by having two Scala 3 builds (one with a slightly different version), and then treating one of them differently using conditionals. Don't judge me.</p>"},{"location":"user/utilities/","title":"Useful utilities","text":"<p>TODO: all utilities defined in <code>core</code>, including obtaining RDF-STaX annotations (describe its potential uses \u2013 external metadata, etc. \u2013 in the docs.) and constructing logical types from RDF-STaX IRIs.</p>"}]}